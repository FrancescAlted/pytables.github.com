
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Library Reference &mdash; PyTables v2.3rc1 documentation</title>
    <link rel="stylesheet" href="../_static/altered_nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.3rc1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="PyTables v2.3rc1 documentation" href="../index.html" />
    <link rel="up" title="PyTables User’s Guide" href="index.html" />
    <link rel="next" title="Optimization tips" href="optimization.html" />
    <link rel="prev" title="Tutorials" href="tutorials.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="optimization.html" title="Optimization tips"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">PyTables v2.3rc1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">PyTables User&#8217;s Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="library-reference">
<span id="id1"></span><h1>Library Reference<a class="headerlink" href="#library-reference" title="Permalink to this headline">¶</a></h1>
<p>PyTables implements several classes to represent the different
nodes in the object tree. They are named File,
Group, Leaf,
Table, Array,
CArray, EArray,
VLArray and UnImplemented. Another
one allows the user to complement the information on these different
objects; its name is AttributeSet. Finally, another
important class called IsDescription allows to build
a Table record description by declaring a subclass of
it. Many other classes are defined in PyTables, but they can be regarded
as helpers whose goal is mainly to declare the <em>data type
properties</em> of the different first class objects and will be
described at the end of this chapter as well.</p>
<p>An important function, called openFile is
responsible to create, open or append to files. In addition, a few
utility functions are defined to guess if the user supplied file is a
<em>PyTables</em> or <em>HDF5</em> file. These
are called isPyTablesFile() and
isHDF5File(), respectively. There exists also a
function called whichLibVersion() that informs about
the versions of the underlying C libraries (for example, HDF5 or
Zlib) and another called
print_versions() that prints all the versions of the
software that PyTables relies on. Finally, test()
lets you run the complete test suite from a Python console
interactively.</p>
<p>Let&#8217;s start discussing the first-level variables and functions
available to the user, then the different classes defined in
PyTables.</p>
<div class="section" id="tables-variables-and-functions">
<h2>tables variables and functions<a class="headerlink" href="#tables-variables-and-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="global-variables">
<h3>Global variables<a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h3>
<dl class="data">
<dt id="tables.__version__">
<tt class="descclassname">tables.</tt><tt class="descname">__version__</tt><a class="headerlink" href="#tables.__version__" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables version number.</p>
</dd></dl>

<dl class="data">
<dt id="tables.hdf5Version">
<tt class="descclassname">tables.</tt><tt class="descname">hdf5Version</tt><a class="headerlink" href="#tables.hdf5Version" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying HDF5 library version number.</p>
</dd></dl>

<dl class="data">
<dt id="tables.is_pro">
<tt class="descclassname">tables.</tt><tt class="descname">is_pro</tt><a class="headerlink" href="#tables.is_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>True for PyTables Professional edition, false otherwise.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">PyTables Professional edition has been released
under an open source license. Starting with version 2.3,
PyTables includes all features of PyTables Pro.
In order to reflect the presence of advanced
features <a class="reference internal" href="#tables.is_pro" title="tables.is_pro"><tt class="xref py py-data docutils literal"><span class="pre">is_pro</span></tt></a> is always
set to True.  <a class="reference internal" href="#tables.is_pro" title="tables.is_pro"><tt class="xref py py-data docutils literal"><span class="pre">is_pro</span></tt></a> should be
considered <em>deprecated</em>.
It will be removed in the next major release.</p>
</div>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 2.3.</span></p>
</dd></dl>

</div>
<div class="section" id="global-functions">
<h3>Global functions<a class="headerlink" href="#global-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="tables.copyFile">
<tt class="descclassname">tables.</tt><tt class="descname">copyFile</tt><big>(</big><em>srcfilename</em>, <em>dstfilename</em>, <em>overwrite=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.copyFile" title="Permalink to this definition">¶</a></dt>
<dd><p>An easy way of copying one PyTables file to another.</p>
<p>This function allows you to copy an existing PyTables file
named srcfilename to another file called
dstfilename. The source file must exist and be
readable. The destination file can be overwritten in place if
existing by asserting the overwrite
argument.</p>
<p>This function is a shorthand for the
<a class="reference internal" href="#tables.File.copyFile" title="tables.File.copyFile"><tt class="xref py py-meth docutils literal"><span class="pre">File.copyFile()</span></tt></a> method, which acts on an
already opened file. kwargs takes keyword
arguments used to customize the copying process. See the
documentation of <a class="reference internal" href="#tables.File.copyFile" title="tables.File.copyFile"><tt class="xref py py-meth docutils literal"><span class="pre">File.copyFile()</span></tt></a> for a description of those
arguments.</p>
</dd></dl>

<dl class="function">
<dt id="tables.isHDF5File">
<tt class="descclassname">tables.</tt><tt class="descname">isHDF5File</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#tables.isHDF5File" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a file is in the HDF5 format.</p>
<p>When successful, it returns a true value if the file is an
HDF5 file, false otherwise. If there were problems identifying the
file, an HDF5ExtError is raised.</p>
</dd></dl>

<dl class="function">
<dt id="tables.isPyTablesFile">
<tt class="descclassname">tables.</tt><tt class="descname">isPyTablesFile</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#tables.isPyTablesFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a file is in the PyTables format.</p>
<p>When successful, it returns the format version string if the
file is a PyTables file, None otherwise.  If
there were problems identifying the file,
an HDF5ExtError is raised.</p>
</dd></dl>

<dl class="function">
<dt id="tables.lrange">
<tt class="descclassname">tables.</tt><tt class="descname">lrange</tt><big>(</big><span class="optional">[</span><em>start</em><span class="optional">]</span>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#tables.lrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over long ranges.</p>
<p>This is similar to xrange(), but it
allows 64-bit arguments on all platforms.  The results of the
iteration are sequentially yielded in the form of
numpy.int64 values, but getting random
individual items is not supported.</p>
<p>Because of the Python 32-bit limitation on object lengths,
the length attribute (which is also a
numpy.int64 value) should be used instead of
the len() syntax.</p>
<p>Default start and step
arguments are supported in the same way as in
xrange().  When the standard
[x]range() Python objects support 64-bit
arguments, this iterator will be deprecated.</p>
</dd></dl>

<dl class="function">
<dt id="tables.openFile">
<tt class="descclassname">tables.</tt><tt class="descname">openFile</tt><big>(</big><em>filename</em>, <em>mode='r'</em>, <em>title=''</em>, <em>rootUEP=&quot;/&quot;</em>, <em>filters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.openFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a PyTables (or generic HDF5) file and return a File object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>The name of the file (supports environment variable
expansion). It is suggested that file names have any of the
.h5, .hdf or .hdf5 extensions, although this is not mandatory.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>The mode to open the file. It can be one of the
following:</p>
<ul class="simple">
<li><em>&#8216;r&#8217;</em>: Read-only; no data can be modified.</li>
<li><em>&#8216;w&#8217;</em>: Write; a new file is created (an existing file with the same name would be deleted).</li>
<li><em>&#8216;a&#8217;</em>: Append; an existing file is opened for reading and writing, and if the file
does not exist it is created.</li>
<li><em>&#8216;r+&#8217;</em>: It is similar to &#8216;a&#8217;, but the file must already exist.</li>
</ul>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>If the file is to be created, a
TITLE string attribute will be set on the
root group with the given value. Otherwise, the title will
be read from disk, and this will not have any effect.</p>
</div></blockquote>
<p><strong>rootUEP</strong> : str</p>
<blockquote>
<div><p>The root User Entry Point. This is a group in the HDF5
hierarchy which will be taken as the starting point to
create the object tree. It can be whatever existing group in
the file, named by its HDF5 path. If it does not exist, an
HDF5ExtError is issued. Use this if you
do not want to build the <em>entire</em> object
tree, but rather only a <em>subtree</em> of it.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote class="last">
<div><p>An instance of the Filters (see
<a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) class that provides
information about the desired I/O filters applicable to the
leaves that hang directly from the <em>root
group</em>, unless other filter properties are
specified for these leaves. Besides, if you do not specify
filter properties for child groups, they will inherit these
ones, which will in turn propagate to child nodes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In addition, it recognizes the names of parameters present
in <tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt> as additional keyword
arguments.  See <a class="reference internal" href="parameter_files.html#parameter-files"><em>PyTables parameter files</em></a> for a
detailed info on the supported parameters.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need to deal with a large number of nodes in an
efficient way, please see <a class="reference internal" href="optimization.html#lruoptim"><em>Getting the most from the node LRU cache</em></a> for more info and advices about
the integrated node cache engine.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="tables.setBloscMaxThreads">
<tt class="descclassname">tables.</tt><tt class="descname">setBloscMaxThreads</tt><big>(</big><em>nthreads</em><big>)</big><a class="headerlink" href="#tables.setBloscMaxThreads" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the maximum number of threads that Blosc can use.</p>
<p>This actually overrides the <a class="reference internal" href="parameter_files.html#tables.parameters.MAX_THREADS" title="tables.parameters.MAX_THREADS"><tt class="xref py py-data docutils literal"><span class="pre">parameters.MAX_THREADS</span></tt></a>
setting in <tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt>, so the new
value will be effective until this function is called again or a
new file with a different <a class="reference internal" href="parameter_files.html#tables.parameters.MAX_THREADS" title="tables.parameters.MAX_THREADS"><tt class="xref py py-data docutils literal"><span class="pre">parameters.MAX_THREADS</span></tt></a> value
is specified.</p>
<p>Returns the previous setting for maximum threads.</p>
</dd></dl>

<dl class="function">
<dt id="tables.print_versions">
<tt class="descclassname">tables.</tt><tt class="descname">print_versions</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.print_versions" title="Permalink to this definition">¶</a></dt>
<dd><p>Print all the versions of software that PyTables relies on.</p>
</dd></dl>

<dl class="function">
<dt id="tables.restrict_flavors">
<tt class="descclassname">tables.</tt><tt class="descname">restrict_flavors</tt><big>(</big><em>keep=['python']</em><big>)</big><a class="headerlink" href="#tables.restrict_flavors" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable all flavors except those in keep.</p>
<p>Providing an empty keep sequence implies
disabling all flavors (but the internal one).  If the sequence is
not specified, only optional flavors are disabled.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Once you disable a flavor, it can not be enabled again.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="tables.split_type">
<tt class="descclassname">tables.</tt><tt class="descname">split_type</tt><big>(</big><em>type</em><big>)</big><a class="headerlink" href="#tables.split_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a PyTables type into a PyTables
kind and an item size.</p>
<p>Returns a tuple of (kind, itemsize). If
no item size is present in the type (in the
form of a precision), the returned item size is
None:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
<span class="go">(&#39;int&#39;, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">)</span>
<span class="go">(&#39;string&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;int20&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: precision must be a multiple of 8</span>: <span class="n">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;foo bar&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: malformed type</span>: <span class="n">&#39;foo bar&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tables.test">
<tt class="descclassname">tables.</tt><tt class="descname">test</tt><big>(</big><em>verbose=False</em>, <em>heavy=False</em><big>)</big><a class="headerlink" href="#tables.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Run all the tests in the test suite.</p>
<p>If verbose is set, the test suite will
emit messages with full verbosity (not recommended unless you are
looking into a certain problem).</p>
<p>If heavy is set, the test suite will be
run in <em>heavy</em> mode (you should be careful with
this because it can take a lot of time and resources from your
computer).</p>
</dd></dl>

<p>..function:: whichLibVersion(name)</p>
<blockquote>
<div><p>Get version information about a C library.</p>
<p>If the library indicated by name is
available, this function returns a 3-tuple containing the major
library version as an integer, its full version as a string, and
the version date as a string. If the library is not available,
None is returned.</p>
<p>The currently supported library names are
hdf5, zlib,
lzo and bzip2. If another
name is given, a ValueError is raised.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="the-file-class">
<span id="fileclassdescr"></span><h2>The File Class<a class="headerlink" href="#the-file-class" title="Permalink to this headline">¶</a></h2>
<p>The in-memory representation of a PyTables file.</p>
<p>An instance of this class is returned when a PyTables file is
opened with the <a class="reference internal" href="#tables.openFile" title="tables.openFile"><tt class="xref py py-func docutils literal"><span class="pre">openFile()</span></tt></a> function. It offers methods to manipulate
(create, rename, delete...) nodes and handle their attributes, as well
as methods to traverse the object tree. The <em>user entry
point</em> to the object tree attached to the HDF5 file is
represented in the rootUEP attribute. Other
attributes are available.</p>
<p>File objects support an <em>Undo/Redo mechanism</em> which can be enabled with the
<a class="reference internal" href="#tables.File.enableUndo" title="tables.File.enableUndo"><tt class="xref py py-meth docutils literal"><span class="pre">File.enableUndo()</span></tt></a> method. Once the Undo/Redo mechanism is
enabled, explicit <em>marks</em> (with an optional unique
name) can be set on the state of the database using the
<a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>
method. There are two implicit marks which are always available: the
initial mark (0) and the final mark (-1).  Both the identifier of a
mark and its name can be used in <em>undo</em> and
<em>redo</em> operations.</p>
<p>Hierarchy manipulation operations (node creation, movement and
removal) and attribute handling operations (setting and deleting) made
after a mark can be undone by using the <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a> method, which returns the database to the
state of a past mark. If undo() is not followed by
operations that modify the hierarchy or attributes, the
<a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> method can
be used to return the database to the state of a future mark. Else,
future states of the database are forgotten.</p>
<p>Note that data handling operations can not be undone nor redone
by now. Also, hierarchy manipulation operations on nodes that do not
support the Undo/Redo mechanism issue an
UndoRedoWarning <em>before</em>
changing the database.</p>
<p>The Undo/Redo mechanism is persistent between sessions and can
only be disabled by calling the <a class="reference internal" href="#tables.File.disableUndo" title="tables.File.disableUndo"><tt class="xref py py-meth docutils literal"><span class="pre">File.disableUndo()</span></tt></a> method.</p>
<p>File objects can also act as context managers when using the
with statement introduced in Python 2.5.  When
exiting a context, the file is automatically closed.</p>
<dl class="class">
<dt id="tables.File">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">File</tt><a class="headerlink" href="#tables.File" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="tables.File.filename">
<tt class="descname">filename</tt><a class="headerlink" href="#tables.File.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the opened file.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.filters">
<tt class="descname">filters</tt><a class="headerlink" href="#tables.File.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Default filter properties for the root group (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.format_version">
<tt class="descname">format_version</tt><a class="headerlink" href="#tables.File.format_version" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables version number of this file.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.isopen">
<tt class="descname">isopen</tt><a class="headerlink" href="#tables.File.isopen" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the underlying file is open, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.mode">
<tt class="descname">mode</tt><a class="headerlink" href="#tables.File.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The mode in which the file was opened.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.open_count">
<tt class="descname">open_count</tt><a class="headerlink" href="#tables.File.open_count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of times this file has been opened currently.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.root">
<tt class="descname">root</tt><a class="headerlink" href="#tables.File.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>root</em> of the object tree hierarchy (a Group instance).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.rootUEP">
<tt class="descname">rootUEP</tt><a class="headerlink" href="#tables.File.rootUEP" title="Permalink to this definition">¶</a></dt>
<dd><p>The UEP (user entry point) group name in the file (see
the <a class="reference internal" href="#tables.openFile" title="tables.openFile"><tt class="xref py py-func docutils literal"><span class="pre">openFile()</span></tt></a> function).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.title">
<tt class="descname">title</tt><a class="headerlink" href="#tables.File.title" title="Permalink to this definition">¶</a></dt>
<dd><p>The title of the root group in the file.</p>
</dd></dl>

</dd></dl>

<div class="section" id="file-methods-file-handling">
<h3>File methods - file handling<a class="headerlink" href="#file-methods-file-handling" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.close">
<tt class="descclassname">File.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all the alive leaves in object tree and close the file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.copyFile">
<tt class="descclassname">File.</tt><tt class="descname">copyFile</tt><big>(</big><em>dstfilename</em>, <em>overwrite=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copyFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the contents of this file to dstfilename.</p>
<p>dstfilename must be a path string
indicating the name of the destination file. If it already exists,
the copy will fail with an IOError, unless the
overwrite argument is true, in which case the
destination file will be overwritten in place. In this last case,
the destination file should be closed or ugly errors will happen.</p>
<p>Additional keyword arguments may be passed to customize the
copying process. For instance, title and filters may be changed,
user attributes may be or may not be copied, data may be
sub-sampled, stats may be collected, etc. Arguments unknown to
nodes are simply ignored. Check the documentation for copying
operations of nodes to see which options they support.</p>
<p>In addition, it recognizes the names of parameters present
in <tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt> as additional keyword
arguments.  See <a class="reference internal" href="parameter_files.html#parameter-files"><em>PyTables parameter files</em></a> for a
detailed info on the supported parameters.</p>
<p>Copying a file usually has the beneficial side effect of
creating a more compact and cleaner version of the original
file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.flush">
<tt class="descclassname">File.</tt><tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all the alive leaves in the object tree.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.fileno">
<tt class="descclassname">File.</tt><tt class="descname">fileno</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.fileno" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying OS integer file descriptor.</p>
<p>This is needed for lower-level file interfaces, such as the
fcntl module.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__enter__">
<tt class="descclassname">File.</tt><tt class="descname">__enter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a context and return the same file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__exit__">
<tt class="descclassname">File.</tt><tt class="descname">__exit__</tt><big>(</big><span class="optional">[</span><em>*exc_info</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#tables.File.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a context and close the file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__str__">
<tt class="descclassname">File.</tt><tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the object tree.
Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span>
<span class="go">data/test.h5 (File) &#39;Table Benchmark&#39;</span>
<span class="go">Last modif.: &#39;Mon Sep 20 12:40:47 2004&#39;</span>
<span class="go">Object Tree:</span>
<span class="go">/ (Group) &#39;Table Benchmark&#39;</span>
<span class="go">/tuple0 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0 (Group) &#39;&#39;</span>
<span class="go">/group0/tuple1 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0/group1 (Group) &#39;&#39;</span>
<span class="go">/group0/group1/tuple2 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0/group1/group2 (Group) &#39;&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.__repr__">
<tt class="descclassname">File.</tt><tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a detailed string representation of the object tree.</p>
</dd></dl>

</div>
<div class="section" id="file-methods-hierarchy-manipulation">
<h3>File methods - hierarchy manipulation<a class="headerlink" href="#file-methods-hierarchy-manipulation" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.copyChildren">
<tt class="descclassname">File.</tt><tt class="descname">copyChildren</tt><big>(</big><em>srcgroup</em>, <em>dstgroup</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copyChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the children of a group into another group.</p>
<p>This method copies the nodes hanging from the source group
srcgroup into the destination group
dstgroup. Existing destination nodes can be
replaced by asserting the overwrite argument.
If the recursive argument is true, all
descendant nodes of srcnode are recursively
copied. If createparents is true, the needed
groups for the given destination parent group path to exist will
be created.</p>
<p>kwargs takes keyword arguments used to
customize the copying process. See the documentation of
<a class="reference internal" href="#tables.Group._f_copyChildren" title="tables.Group._f_copyChildren"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_copyChildren()</span></tt></a> for a description of those
arguments.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.copyNode">
<tt class="descclassname">File.</tt><tt class="descname">copyNode</tt><big>(</big><em>where</em>, <em>newparent=None</em>, <em>newname=None</em>, <em>name=None</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copyNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the node specified by where and name to newparent/newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted
upon.</p>
</div></blockquote>
<p><strong>newparent</strong> : str or Group</p>
<blockquote>
<div><p>The destination group that the node will be copied
into (a path name or a Group
instance). If not specified or None, the
current parent group is chosen as the new parent.</p>
</div></blockquote>
<p><strong>newname</strong> : str</p>
<blockquote>
<div><p>The name to be assigned to the new copy in its
destination (a string).  If it is not specified or
None, the current name is chosen as the
new name.</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote class="last">
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted
upon.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Additional keyword arguments may be passed to customize the
copying process. The supported arguments depend on the kind of
node being copied. See <a class="reference internal" href="#tables.Group._f_copy" title="tables.Group._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_copy()</span></tt></a> and
<a class="reference internal" href="#tables.Leaf.copy" title="tables.Leaf.copy"><tt class="xref py py-meth docutils literal"><span class="pre">Leaf.copy()</span></tt></a> for more information on their
allowed keyword arguments.</p>
<p>This method returns the newly created copy of the source
node (i.e. the destination node).  See
<a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a>
for further details on the semantics of copying nodes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createArray">
<tt class="descclassname">File.</tt><tt class="descname">createArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>object</em>, <em>title=''</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new array with the given name in where location.
See the Array class (in <a class="reference internal" href="#arrayclassdescr"><em>The Array class</em></a>) for more information on
arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>object</strong> : python object</p>
<blockquote>
<div><p>The array or scalar to be saved.  Accepted types are
NumPy arrays and scalars, numarray arrays
and string arrays (deprecated), Numeric arrays and scalars
(deprecated), as well as native Python sequences and scalars,
provided that values are regular (i.e. they are not like
[[1,2],2]) and homogeneous (i.e. all the
elements are of the same type).</p>
<p>Also, objects that have some of their dimensions equal to 0 are not
supported (use an EArray node (see <a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>) if you
want to store an array with one of its dimensions equal to 0).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str</p>
<blockquote class="last">
<div><p>The byteorder of the data <em>on disk</em>, specified as
&#8216;little&#8217; or
&#8216;big&#8217;.  If this is not specified, the
byteorder is that of the given object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See <a class="reference internal" href="#tables.File.createTable" title="tables.File.createTable"><tt class="xref py py-meth docutils literal"><span class="pre">File.createTable()</span></tt></a> for more
information on the rest of parameters.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createCArray">
<tt class="descclassname">File.</tt><tt class="descname">createCArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom</em>, <em>shape</em>, <em>title=''</em>, <em>filters=None</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createCArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new chunked array with the given name in where location.
See the CArray class (in <a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>) for more information on
chunked arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>)
instance representing the <em>type</em> and
<em>shape</em> of the atomic objects to be
saved.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>The shape of the new array.</p>
</div></blockquote>
<p><strong>chunkshape</strong> : tuple or number or None</p>
<blockquote class="last">
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation.  Filters are applied to those
chunks of data.  The dimensionality of
chunkshape must be the same as that of
shape.  If None, a
sensible value is calculated (which is recommended).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See <a class="reference internal" href="#tables.File.createTable" title="tables.File.createTable"><tt class="xref py py-meth docutils literal"><span class="pre">File.createTable()</span></tt></a> for more
information on the rest of parameters.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createEArray">
<tt class="descclassname">File.</tt><tt class="descname">createEArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom</em>, <em>shape</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=EXPECTED_ROWS_EARRAY</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createEArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new enlargeable array with the given name in where location.
See the EArray (in <a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>) class for more information on
enlargeable arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>)
instance representing the <em>type</em> and
<em>shape</em> of the atomic objects to be saved.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>The shape of the new array.  One (and only one) of the
shape dimensions <em>must</em> be 0.  The
dimension being 0 means that the resulting
EArray object can be extended along it.
Multiple enlargeable dimensions are not supported right now.</p>
</div></blockquote>
<p><strong>expectedrows</strong> :</p>
<blockquote>
<div><p>A user estimate about the number of row elements that
will be added to the growable dimension in the
EArray node.  If not provided, the
default value is EXPECTED_ROWS_EARRAY
(see tables/parameters.py).  If you plan
to create either a much smaller or a much bigger array try
providing a guess; this will optimize the HDF5 B-Tree
creation and management process time and the amount of
memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> : tuple, numeric, or None</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation.  Filters are applied to those
chunks of data.  The dimensionality of
chunkshape must be the same as that of
shape (beware: no dimension should be 0
this time!).  If None, a sensible value
is calculated based on the expectedrows
parameter (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str</p>
<blockquote class="last">
<div><p>The byteorder of the data <em>on
disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;. If this is not specified, the
byteorder is that of the platform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See <a class="reference internal" href="#tables.File.createTable" title="tables.File.createTable"><tt class="xref py py-meth docutils literal"><span class="pre">File.createTable()</span></tt></a> for more
information on the rest of parameters.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createExternalLink">
<tt class="descclassname">File.</tt><tt class="descname">createExternalLink</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em>, <em>warn16incompat=False</em><big>)</big><a class="headerlink" href="#tables.File.createExternalLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an external link to a target node
with the given name
in where location.  target
can be a node object in another file or a path string in the
form <cite>file:/path/to/node</cite>.  If
createparents is true, the intermediate
groups required for reaching where are
created (the default is not doing so).</p>
<p>The purpose of the warn16incompat
argument is to avoid an Incompat16Warning
(see below).  The default is to issue the warning.</p>
<p>The returned node is an ExternalLink
instance.  See the
ExternalLink class (in
<a class="reference internal" href="#externallinkclassdescr"><em>The ExternalLink class</em></a>) for more information on external links.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">External links are only supported when PyTables is
compiled against HDF5 1.8.x series.  When using PyTables with
HDF5 1.6.x, the <em>parent</em> group containing
external link objects will be mapped to
an Unknown instance (see <a class="reference internal" href="#unknownclassdescr"><em>The Unknown class</em></a>)
and you won&#8217;t be able to access <em>any</em>
node hanging of this parent group.  It follows that if the
parent group containing the external link is the root group,
you won&#8217;t be able to read <em>any</em> information
contained in the file when using HDF5 1.6.x.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.createGroup">
<tt class="descclassname">File.</tt><tt class="descname">createGroup</tt><big>(</big><em>where</em>, <em>name</em>, <em>title=''</em>, <em>filters=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new group with the given name in
where location.  See the
Group class (in <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) for more information on
groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>filters</strong> : Filters</p>
<blockquote class="last">
<div><p>An instance of the Filters class
(see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) that provides information
about the desired I/O filters applicable to the leaves that
hang directly from this new group (unless other filter
properties are specified for these leaves). Besides, if you
do not specify filter properties for its child groups, they
will inherit these ones.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See <a class="reference internal" href="#tables.File.createTable" title="tables.File.createTable"><tt class="xref py py-meth docutils literal"><span class="pre">File.createTable()</span></tt></a> for more
information on the rest of parameters.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createHardLink">
<tt class="descclassname">File.</tt><tt class="descname">createHardLink</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createHardLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hard link to a target node with
the given name in where
location.  target can be a node object or a
path string.  If createparents is true, the
intermediate groups required for
reaching where are created (the default is
not doing so).</p>
<p>The returned node is a regular Group
or Leaf instance.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createSoftLink">
<tt class="descclassname">File.</tt><tt class="descname">createSoftLink</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createSoftLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a soft link (aka symbolic link) to
a target node with the
given name in where
location.  target can be a node object or a
path string.  If createparents is true, the
intermediate groups required for
reaching where are created (the default is
not doing so).</p>
<p>The returned node is a SoftLink instance.
See the SoftLink class (in
<a class="reference internal" href="#softlinkclassdescr"><em>The SoftLink class</em></a>)
for more information on soft links.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createTable">
<tt class="descclassname">File.</tt><tt class="descname">createTable</tt><big>(</big><em>where</em>, <em>name</em>, <em>description</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=EXPECTED_ROWS_TABLE</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new table with the given name in
where location.  See the
Table (in <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>) class for more information on
tables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : path or Group</p>
<blockquote>
<div><p>The parent group where the new table will hang from.
It can be a path string (for example
&#8216;/level1/leaf5&#8217;), or a
Group instance (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new table.</p>
</div></blockquote>
<p><strong>description</strong> : Description</p>
<blockquote>
<div><p>This is an object that describes the table, i.e. how
many columns it has, their names, types, shapes, etc.  It
can be any of the following:</p>
<ul class="simple">
<li><em>A user-defined class</em>: This should inherit from the IsDescription
class (see <a class="reference internal" href="#isdescriptionclassdescr"><em>The IsDescription class</em></a>) where table fields are specified.</li>
<li><em>A dictionary</em>: For example, when you do not know beforehand which structure
your table will have).</li>
<li><em>A Description instance</em>: You can use the description attribute of another
table to create a new one with the same structure.</li>
<li><em>A NumPy dtype</em>: A completely general structured NumPy dtype.</li>
<li><em>A NumPy (record) array instance</em>: The dtype of this record array will be used
as the description.  Also, in case the array has actual data, it will be injected
into the newly created table.</li>
<li><em>A RecArray instance (deprecated)</em>: Object from the numarray package.  This does
not give you the possibility to create a nested table.  Array data is injected into
the new table.</li>
<li><em>A NestedRecArray instance (deprecated)</em>: If you want to have nested columns in
your table and you are using numarray, you can use this object. Array data is
injected into the new table.</li>
</ul>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class
(see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) that provides information
about the desired I/O filters to be applied during the life
of this object.</p>
</div></blockquote>
<p><strong>expectedrows</strong> : int</p>
<blockquote>
<div><p>A user estimate of the number of records that will be
in the table. If not provided, the default value is
EXPECTED_ROWS_TABLE (see
<tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt>). If you plan to
create a bigger table try providing a guess; this will
optimize the HDF5 B-Tree creation and management process
time and memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation. Filters are applied to those
chunks of data. The rank of the
chunkshape for tables must be 1. If
None, a sensible value is calculated
based on the expectedrows parameter
(which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str</p>
<blockquote>
<div><p>The byteorder of data <em>on disk</em>,
specified as &#8216;little&#8217; or
&#8216;big&#8217;. If this is not specified, the
byteorder is that of the platform, unless you passed an
array as the description, in which case
its byteorder will be used.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool</p>
<blockquote class="last">
<div><p>Whether to create the needed groups for the parent
path to exist (not done by default).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.createVLArray">
<tt class="descclassname">File.</tt><tt class="descname">createVLArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedsizeinMB=1.0</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createVLArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable-length array with the given
name in where location.  See
the VLArray (in <a class="reference internal" href="#vlarrayclassdescr"><em>The VLArray class</em></a>) class
for more information on variable-length arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>)
instance representing the <em>type</em> and
<em>shape</em> of the atomic objects to be
saved.</p>
</div></blockquote>
<p><strong>expectedsizeinMB</strong> :</p>
<blockquote>
<div><p>An user estimate about the size (in MB) in the final
VLArray node. If not provided, the
default value is 1 MB. If you plan to create either a much
smaller or a much bigger array try providing a guess; this
will optimize the HDF5 B-Tree creation and management
process time and the amount of memory used. If you want to
specify your own chunk size for I/O purposes, see also the
chunkshape parameter below.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote class="last">
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation. Filters are applied to those
chunks of data. The dimensionality of
chunkshape must be 1. If
None, a sensible value is calculated
(which is recommended).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See <a class="reference internal" href="#tables.File.createTable" title="tables.File.createTable"><tt class="xref py py-meth docutils literal"><span class="pre">File.createTable()</span></tt></a> for more
information on the rest of parameters.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.moveNode">
<tt class="descclassname">File.</tt><tt class="descname">moveNode</tt><big>(</big><em>where</em>, <em>newparent=None</em>, <em>newname=None</em>, <em>name=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.moveNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the node specified by where and name to newparent/newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> : path</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>newparent</strong> :</p>
<blockquote>
<div><p>The destination group the node will be moved into (a
path name or a Group instance). If it is
not specified or None, the current parent
group is chosen as the new parent.</p>
</div></blockquote>
<p><strong>newname</strong> :</p>
<blockquote class="last">
<div><p>The new name to be assigned to the node in its
destination (a string). If it is not specified or
None, the current name is chosen as the
new name.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The other arguments work as in
<a class="reference internal" href="#tables.Node._f_move" title="tables.Node._f_move"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_move()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.removeNode">
<tt class="descclassname">File.</tt><tt class="descname">removeNode</tt><big>(</big><em>where</em>, <em>name=None</em>, <em>recursive=False</em><big>)</big><a class="headerlink" href="#tables.File.removeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the object node <em>name</em> under <em>where</em> location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>recursive</strong> : bool</p>
<blockquote class="last">
<div><p>If not supplied or false, the node will be removed
only if it has no children; if it does, a
NodeError will be raised. If supplied
with a true value, the node and all its descendants will be
completely removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.renameNode">
<tt class="descclassname">File.</tt><tt class="descname">renameNode</tt><big>(</big><em>where</em>, <em>newname</em>, <em>name=None</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#tables.File.renameNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the name of the node specified by where and name to newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>newname</strong> : str</p>
<blockquote>
<div><p>The new name to be assigned to the node (a string).</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool</p>
<blockquote class="last">
<div><p>Whether to recursively remove a node with the same
newname if it already exists (not done by default).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="file-methods-tree-traversal">
<h3>File methods - tree traversal<a class="headerlink" href="#file-methods-tree-traversal" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.getNode">
<tt class="descclassname">File.</tt><tt class="descname">getNode</tt><big>(</big><em>where</em>, <em>name=None</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.getNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the node under where with the given name.</p>
<p>where can be a Node instance (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) or a path string leading to a node. If no
name is specified, that node is returned.</p>
<p>If a name is specified, this must be a
string with the name of a node under where.  In
this case the where argument can only lead to a
Group (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) instance (else a
TypeError is raised). The node called
name under the group where
is returned.</p>
<p>In both cases, if the node to be returned does not exist, a
NoSuchNodeError is raised. Please note that
hidden nodes are also considered.</p>
<p>If the classname argument is specified,
it must be the name of a class derived from
Node. If the node is found but it is not an
instance of that class, a NoSuchNodeError is
also raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.isVisibleNode">
<tt class="descclassname">File.</tt><tt class="descname">isVisibleNode</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#tables.File.isVisibleNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the node under path visible?</p>
<p>If the node does not exist, a
NoSuchNodeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.iterNodes">
<tt class="descclassname">File.</tt><tt class="descname">iterNodes</tt><big>(</big><em>where</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.iterNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over children nodes hanging from where.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> :</p>
<blockquote>
<div><p>This argument works as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>classname</strong> :</p>
<blockquote class="last">
<div><p>If the name of a class derived from
Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) is supplied, only instances of
that class (or subclasses of it) will be returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The returned nodes are alphanumerically sorted by their
name.  This is an iterator version of
<a class="reference internal" href="#tables.File.listNodes" title="tables.File.listNodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.listNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.listNodes">
<tt class="descclassname">File.</tt><tt class="descname">listNodes</tt><big>(</big><em>where</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.listNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <em>list</em> with children nodes
hanging from where.</p>
<p>This is a list-returning version of
<a class="reference internal" href="#tables.File.iterNodes" title="tables.File.iterNodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.iterNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.walkGroups">
<tt class="descclassname">File.</tt><tt class="descname">walkGroups</tt><big>(</big><em>where='/'</em><big>)</big><a class="headerlink" href="#tables.File.walkGroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over groups (not leaves) hanging from where.</p>
<p>The where group itself is listed first
(preorder), then each of its child groups (following an
alphanumerical order) is also traversed, following the same
procedure.  If where is not supplied, the root
group is used.</p>
<p>The where argument can be a path string
or a Group instance (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.walkNodes">
<tt class="descclassname">File.</tt><tt class="descname">walkNodes</tt><big>(</big><em>where=&quot;/&quot;</em>, <em>classname=&quot;&quot;</em><big>)</big><a class="headerlink" href="#tables.File.walkNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over nodes hanging from where.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> :</p>
<blockquote>
<div><p>If supplied, the iteration starts from (and includes)
this group. It can be a path string or a
Group instance (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>classname</strong> :</p>
<blockquote class="last">
<div><p>If the name of a class derived from
Node (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) is supplied, only instances of
that class (or subclasses of it) will be returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively print all the nodes hanging from &#39;/detector&#39;.</span>
<span class="k">print</span> <span class="s">&quot;Nodes hanging from group &#39;/detector&#39;:&quot;</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">walkNodes</span><span class="p">(</span><span class="s">&#39;/detector&#39;</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="s">&#39;EArray&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">node</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.__contains__">
<tt class="descclassname">File.</tt><tt class="descname">__contains__</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#tables.File.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there a node with that path?</p>
<p>Returns True if the file has a node with
the given path (a string),
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__iter__">
<tt class="descclassname">File.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over the nodes in the tree.</p>
<p>This is equivalent to calling
<a class="reference internal" href="#tables.File.walkNodes" title="tables.File.walkNodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.walkNodes()</span></tt></a> with no arguments.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively list all the nodes in the object tree.</span>
<span class="n">h5file</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;vlarray1.h5&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;All nodes in the object tree:&quot;</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">node</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="file-methods-undo-redo-support">
<h3>File methods - Undo/Redo support<a class="headerlink" href="#file-methods-undo-redo-support" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.disableUndo">
<tt class="descclassname">File.</tt><tt class="descname">disableUndo</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.disableUndo" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the Undo/Redo mechanism.</p>
<p>Disabling the Undo/Redo mechanism leaves the database in the
current state and forgets past and future database states. This
makes <a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>, <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>, <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> and other methods fail with an
UndoRedoError.</p>
<p>Calling this method when the Undo/Redo mechanism is already
disabled raises an UndoRedoError.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.enableUndo">
<tt class="descclassname">File.</tt><tt class="descname">enableUndo</tt><big>(</big><em>filters=Filters( complevel=1)</em><big>)</big><a class="headerlink" href="#tables.File.enableUndo" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the Undo/Redo mechanism.</p>
<p>This operation prepares the database for undoing and redoing
modifications in the node hierarchy. This allows
<a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>, <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>, <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> and other methods
to be called.</p>
<p>The filters argument, when specified,
must be an instance of class Filters (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) and is
meant for setting the compression values for the action log. The
default is having compression enabled, as the gains in terms of
space can be considerable. You may want to disable compression if
you want maximum speed for Undo/Redo operations.</p>
<p>Calling this method when the Undo/Redo mechanism is already
enabled raises an UndoRedoError.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.getCurrentMark">
<tt class="descclassname">File.</tt><tt class="descname">getCurrentMark</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.getCurrentMark" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the identifier of the current mark.</p>
<p>Returns the identifier of the current mark. This can be used
to know the state of a database after an application crash, or to
get the identifier of the initial implicit mark after a call to
<a class="reference internal" href="#tables.File.enableUndo" title="tables.File.enableUndo"><tt class="xref py py-meth docutils literal"><span class="pre">File.enableUndo()</span></tt></a>.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.goto">
<tt class="descclassname">File.</tt><tt class="descname">goto</tt><big>(</big><em>mark</em><big>)</big><a class="headerlink" href="#tables.File.goto" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a specific mark of the database.</p>
<p>Returns the database to the state associated with the
specified mark. Both the identifier of a mark
and its name can be used.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.isUndoEnabled">
<tt class="descclassname">File.</tt><tt class="descname">isUndoEnabled</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.isUndoEnabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the Undo/Redo mechanism enabled?</p>
<p>Returns True if the Undo/Redo mechanism
has been enabled for this file, False
otherwise. Please note that this mechanism is persistent, so a
newly opened PyTables file may already have Undo/Redo
support enabled.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.mark">
<tt class="descclassname">File.</tt><tt class="descname">mark</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the state of the database.</p>
<p>Creates a mark for the current state of the database. A
unique (and immutable) identifier for the mark is returned. An
optional name (a string) can be assigned to the
mark. Both the identifier of a mark and its name can be used in
<a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>
and <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> operations. When the name has already been
used for another mark, an UndoRedoError is raised.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.redo">
<tt class="descclassname">File.</tt><tt class="descname">redo</tt><big>(</big><em>mark=None</em><big>)</big><a class="headerlink" href="#tables.File.redo" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a future state of the database.</p>
<p>Returns the database to the state associated with the
specified mark. Both the identifier of a mark
and its name can be used. If the mark is
omitted, the next created mark is used. If there are no future
marks, or the specified mark is not newer than
the current one, an UndoRedoError is
raised.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.undo">
<tt class="descclassname">File.</tt><tt class="descname">undo</tt><big>(</big><em>mark=None</em><big>)</big><a class="headerlink" href="#tables.File.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a past state of the database.</p>
<p>Returns the database to the state associated with the
specified mark. Both the identifier of a mark
and its name can be used. If the mark is
omitted, the last created mark is used. If there are no past
marks, or the specified mark is not older than
the current one, an UndoRedoError is
raised.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

</div>
<div class="section" id="file-methods-attribute-handling">
<h3>File methods - attribute handling<a class="headerlink" href="#file-methods-attribute-handling" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.copyNodeAttrs">
<tt class="descclassname">File.</tt><tt class="descname">copyNodeAttrs</tt><big>(</big><em>where</em>, <em>dstnode</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.copyNodeAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy PyTables attributes from one node to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>dstnode</strong> :</p>
<blockquote class="last">
<div><p>The destination node where the attributes will be
copied to. It can be a path string or a
Node instance (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.delNodeAttr">
<tt class="descclassname">File.</tt><tt class="descname">delNodeAttr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.delNodeAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute from the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote class="last">
<div><p>The name of the attribute to delete.  If the named
attribute does not exist, an
AttributeError is raised.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.getNodeAttr">
<tt class="descclassname">File.</tt><tt class="descname">getNodeAttr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.getNodeAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PyTables attribute from the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote class="last">
<div><p>The name of the attribute to retrieve.  If the named
attribute does not exist, an
AttributeError is raised.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.setNodeAttr">
<tt class="descclassname">File.</tt><tt class="descname">setNodeAttr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>attrvalue</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.setNodeAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute for the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote>
<div><p>The name of the attribute to set.</p>
</div></blockquote>
<p><strong>attrvalue</strong> :</p>
<blockquote class="last">
<div><p>The value of the attribute to set. Any kind of Python
object (like strings, ints, floats, lists, tuples, dicts,
small NumPy/Numeric/numarray objects...) can be stored as an
attribute. However, if necessary, cPickle
is automatically used so as to serialize objects that you
might want to save. See the AttributeSet
class (in <a class="reference internal" href="#attributesetclassdescr"><em>The AttributeSet class</em></a>) for details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the node already has a large number of attributes, a
PerformanceWarning is issued.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-node-class">
<span id="nodeclassdescr"></span><h2>The Node class<a class="headerlink" href="#the-node-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Node">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Node</tt><a class="headerlink" href="#tables.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for all PyTables nodes.</p>
<p>This is the base class for <em>all</em> nodes in a
PyTables hierarchy. It is an abstract class, i.e. it may not be
directly instantiated; however, every node in the hierarchy is an
instance of this class.</p>
<p>A PyTables node is always hosted in a PyTables
<em>file</em>, under a <em>parent group</em>,
at a certain <em>depth</em> in the node hierarchy. A node
knows its own <em>name</em> in the parent group and its
own <em>path name</em> in the file.</p>
<p>All the previous information is location-dependent, i.e. it may
change when moving or renaming a node in the hierarchy. A node also
has location-independent information, such as its <em>HDF5
object identifier</em> and its <em>attribute set</em>.</p>
<p>This class gathers the operations and attributes (both
location-dependent and independent) which are common to all PyTables
nodes, whatever their type is. Nonetheless, due to natural naming
restrictions, the names of all of these members start with a reserved
prefix (see the Group class in <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
<p>Sub-classes with no children (e.g. <em>leaf
nodes</em>) may define new methods, attributes and properties to
avoid natural naming restrictions. For instance,
_v_attrs may be shortened to
attrs and _f_rename to
rename. However, the original methods and
attributes should still be available.</p>
</dd></dl>

<div class="section" id="node-instance-variables-location-dependent">
<h3>Node instance variables - location dependent<a class="headerlink" href="#node-instance-variables-location-dependent" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.Node._v_depth">
<tt class="descclassname">Node.</tt><tt class="descname">_v_depth</tt><a class="headerlink" href="#tables.Node._v_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of this node in the tree (an non-negative integer value).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_file">
<tt class="descclassname">Node.</tt><tt class="descname">_v_file</tt><a class="headerlink" href="#tables.Node._v_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The hosting File instance (see <a class="reference internal" href="#fileclassdescr"><em>The File Class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_name">
<tt class="descclassname">Node.</tt><tt class="descname">_v_name</tt><a class="headerlink" href="#tables.Node._v_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this node in its parent group (a string).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_parent">
<tt class="descclassname">Node.</tt><tt class="descname">_v_parent</tt><a class="headerlink" href="#tables.Node._v_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent Group instance (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_pathname">
<tt class="descclassname">Node.</tt><tt class="descname">_v_pathname</tt><a class="headerlink" href="#tables.Node._v_pathname" title="Permalink to this definition">¶</a></dt>
<dd><p>The path of this node in the tree (a string).</p>
</dd></dl>

</div>
<div class="section" id="node-instance-variables-location-independent">
<span id="nodeclassinstancevariables"></span><h3>Node instance variables - location independent<a class="headerlink" href="#node-instance-variables-location-independent" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.Node._v_attrs">
<tt class="descclassname">Node.</tt><tt class="descname">_v_attrs</tt><a class="headerlink" href="#tables.Node._v_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated AttributeSet instance
(see <a class="reference internal" href="#attributesetclassdescr"><em>The AttributeSet class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_isopen">
<tt class="descclassname">Node.</tt><tt class="descname">_v_isopen</tt><a class="headerlink" href="#tables.Node._v_isopen" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether this node is open or not.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_objectID">
<tt class="descclassname">Node.</tt><tt class="descname">_v_objectID</tt><a class="headerlink" href="#tables.Node._v_objectID" title="Permalink to this definition">¶</a></dt>
<dd><p>A node identifier (may change from run to run).</p>
</dd></dl>

</div>
<div class="section" id="node-instance-variables-attribute-shorthands">
<h3>Node instance variables - attribute shorthands<a class="headerlink" href="#node-instance-variables-attribute-shorthands" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.Node._v_title">
<tt class="descclassname">Node.</tt><tt class="descname">_v_title</tt><a class="headerlink" href="#tables.Node._v_title" title="Permalink to this definition">¶</a></dt>
<dd><p>A description of this node. A shorthand for TITLE attribute.</p>
</dd></dl>

</div>
<div class="section" id="node-methods-hierarchy-manipulation">
<h3>Node methods - hierarchy manipulation<a class="headerlink" href="#node-methods-hierarchy-manipulation" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Node._f_close">
<tt class="descclassname">Node.</tt><tt class="descname">_f_close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._f_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this node in the tree.</p>
<p>This releases all resources held by the node, so it should
not be used again. On nodes with data, it may be flushed to
disk.</p>
<p>You should not need to close nodes manually because they are
automatically opened/closed when they are loaded/evicted from the
integrated LRU cache.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_copy">
<tt class="descclassname">Node.</tt><tt class="descname">_f_copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Node._f_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node and return the new node.</p>
<p>Creates and returns a copy of the node, maybe in a different
place in the hierarchy. newparent can be a
Group object (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) or a
pathname in string form. If it is not specified or
None, the current parent group is chosen as the
new parent.  newname must be a string with a
new name. If it is not specified or None, the
current name is chosen as the new name. If
recursive copy is stated, all descendants are
copied as well. If createparents is true, the
needed groups for the given new parent group path to exist will be
created.</p>
<p>Copying a node across databases is supported but can not be
undone. Copying a node over itself is not allowed, nor it is
recursively copying a node into itself. These result in a
NodeError. Copying over another existing node
is similarly not allowed, unless the optional
overwrite argument is true, in which case that
node is recursively removed before copying.</p>
<p>Additional keyword arguments may be passed to customize the
copying process. For instance, title and filters may be changed,
user attributes may be or may not be copied, data may be
sub-sampled, stats may be collected, etc. See the documentation
for the particular node type.</p>
<p>Using only the first argument is equivalent to copying the
node to a new location without changing its name. Using only the
second argument is equivalent to making a copy of the node in the
same group.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_isVisible">
<tt class="descclassname">Node.</tt><tt class="descname">_f_isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._f_isVisible" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this node visible?</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_move">
<tt class="descclassname">Node.</tt><tt class="descname">_f_move</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.Node._f_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move or rename this node.</p>
<p>Moves a node into a new parent group, or changes the name of
the node. newparent can be a
Group object (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) or a
pathname in string form. If it is not specified or
None, the current parent group is chosen as the
new parent.  newname must be a string with a
new name. If it is not specified or None, the
current name is chosen as the new name. If
createparents is true, the needed groups for
the given new parent group path to exist will be created.</p>
<p>Moving a node across databases is not allowed, nor it is
moving a node <em>into</em> itself. These result in a
NodeError. However, moving a node
<em>over</em> itself is allowed and simply does
nothing. Moving over another existing node is similarly not
allowed, unless the optional overwrite argument
is true, in which case that node is recursively removed before
moving.</p>
<p>Usually, only the first argument will be used, effectively
moving the node to a new location without changing its name.
Using only the second argument is equivalent to renaming the node
in place.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_remove">
<tt class="descclassname">Node.</tt><tt class="descname">_f_remove</tt><big>(</big><em>recursive=False</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#tables.Node._f_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this node from the hierarchy.</p>
<p>If the node has children, recursive removal must be stated
by giving recursive a true value; otherwise, a
NodeError will be raised.</p>
<p>If the node is a link to a Group object,
and you are sure that you want to delete it, you can do this by
setting the force flag to true.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_rename">
<tt class="descclassname">Node.</tt><tt class="descname">_f_rename</tt><big>(</big><em>newname</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#tables.Node._f_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node in place.</p>
<p>Changes the name of a node to <em>newname</em>
(a string).  If a node with the same newname
already exists and overwrite is true,
recursively remove it before renaming.</p>
</dd></dl>

</div>
<div class="section" id="node-methods-attribute-handling">
<h3>Node methods - attribute handling<a class="headerlink" href="#node-methods-attribute-handling" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Node._f_delAttr">
<tt class="descclassname">Node.</tt><tt class="descname">_f_delAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Node._f_delAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute from this node.</p>
<p>If the named attribute does not exist, an
AttributeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_getAttr">
<tt class="descclassname">Node.</tt><tt class="descname">_f_getAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Node._f_getAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PyTables attribute from this node.</p>
<p>If the named attribute does not exist, an
AttributeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_setAttr">
<tt class="descclassname">Node.</tt><tt class="descname">_f_setAttr</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Node._f_setAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute for this node.</p>
<p>If the node already has a large number of attributes, a
PerformanceWarning is issued.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-group-class">
<span id="groupclassdescr"></span><h2>The Group class<a class="headerlink" href="#the-group-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Group">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Group</tt><a class="headerlink" href="#tables.Group" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic PyTables grouping structure.</p>
<p>Instances of this class are grouping structures containing
<em>child</em> instances of zero or more groups or leaves,
together with supporting metadata. Each group has exactly one
<em>parent</em> group.</p>
<p>Working with groups and leaves is similar in many ways to
working with directories and files, respectively, in a Unix
filesystem. As with Unix directories and files, objects in the object
tree are often described by giving their full (or absolute) path
names. This full path can be specified either as a string (like in
&#8216;/group1/group2&#8217;) or as a complete object path
written in <em>natural naming</em> schema (like in
file.root.group1.group2).</p>
<p>A collateral effect of the <em>natural naming</em>
schema is that the names of members in the Group
class and its instances must be carefully chosen to avoid colliding
with existing children node names.  For this reason and to avoid
polluting the children namespace all members in a
Group start with some reserved prefix, like
_f_ (for public methods), _g_
(for private ones), _v_ (for instance variables) or
_c_ (for class variables). Any attempt to create a
new child node whose name starts with one of these prefixes will raise
a ValueError exception.</p>
<p>Another effect of natural naming is that children named after
Python keywords or having names not valid as Python identifiers (e.g.
class, $a or 44) can not be accessed using the
node.child syntax. You will be forced to use
node._f_getChild(child) to access them (which is
recommended for programmatic accesses).</p>
<p>You will also need to use _f_getChild() to
access an existing child node if you set a Python attribute in the
Group with the same name as that node (you will get
a NaturalNameWarning when doing this).</p>
</dd></dl>

<div class="section" id="group-instance-variables">
<h3>Group instance variables<a class="headerlink" href="#group-instance-variables" title="Permalink to this headline">¶</a></h3>
<p>The following instance variables are provided in addition to
those in Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>):</p>
<dl class="attribute">
<dt id="tables.Group._v_children">
<tt class="descclassname">Group.</tt><tt class="descname">_v_children</tt><a class="headerlink" href="#tables.Group._v_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with all nodes hanging from this group.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_filters">
<tt class="descclassname">Group.</tt><tt class="descname">_v_filters</tt><a class="headerlink" href="#tables.Group._v_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Default filter properties for child nodes.</p>
<p>You can (and are encouraged to) use this property to
get, set and delete the FILTERS HDF5
attribute of the group, which stores a
Filters instance (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>). When
the group has no such attribute, a default
Filters instance is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_groups">
<tt class="descclassname">Group.</tt><tt class="descname">_v_groups</tt><a class="headerlink" href="#tables.Group._v_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with all groups hanging from this group.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_hidden">
<tt class="descclassname">Group.</tt><tt class="descname">_v_hidden</tt><a class="headerlink" href="#tables.Group._v_hidden" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with all hidden nodes hanging from this group.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_leaves">
<tt class="descclassname">Group.</tt><tt class="descname">_v_leaves</tt><a class="headerlink" href="#tables.Group._v_leaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with all leaves hanging from this group.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_links">
<tt class="descclassname">Group.</tt><tt class="descname">_v_links</tt><a class="headerlink" href="#tables.Group._v_links" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with all links hanging from this group.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_nchildren">
<tt class="descclassname">Group.</tt><tt class="descname">_v_nchildren</tt><a class="headerlink" href="#tables.Group._v_nchildren" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of children hanging from this group.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_unknown">
<tt class="descclassname">Group.</tt><tt class="descname">_v_unknown</tt><a class="headerlink" href="#tables.Group._v_unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with all unknown nodes hanging from this group.</p>
</dd></dl>

</div>
<div class="section" id="group-methods">
<h3>Group methods<a class="headerlink" href="#group-methods" title="Permalink to this headline">¶</a></h3>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last"><em>Caveat:</em> The following methods are
documented for completeness, and they can be used without any
problem. However, you should use the high-level counterpart methods
in the File class (see <a class="reference internal" href="#fileclassdescr"><em>The File Class</em></a>, because they
are most used in documentation and examples, and are a bit more
powerful than those exposed here.</p>
</div>
<p>The following methods are provided in addition to those in
Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>):</p>
<dl class="method">
<dt id="tables.Group._f_close">
<tt class="descclassname">Group.</tt><tt class="descname">_f_close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._f_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this group and all its descendents.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_close" title="tables.Node._f_close"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_close()</span></tt></a>.  It should be noted that this
operation closes all the nodes descending from this group.</p>
<p>You should not need to close nodes manually because they are
automatically opened/closed when they are loaded/evicted from the
integrated LRU cache.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_copy">
<tt class="descclassname">Group.</tt><tt class="descname">_f_copy</tt><big>(</big><em>newparent</em>, <em>newname</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Group._f_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node and return the new one.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a>. In addition, it recognizes the
following keyword arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>title</strong> :</p>
<blockquote>
<div><p>The new title for the destination. If omitted or
None, the original title is used. This
only applies to the topmost node in recursive copies.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>Specifying this parameter overrides the original
filter properties in the source node. If specified, it must
be an instance of the Filters class (see
<a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>). The default is to copy the
filter properties from the source node.</p>
</div></blockquote>
<p><strong>copyuserattrs</strong> :</p>
<blockquote>
<div><p>You can prevent the user attributes from being copied
by setting this parameter to False. The
default is to copy them.</p>
</div></blockquote>
<p><strong>stats</strong> :</p>
<blockquote class="last">
<div><p>This argument may be used to collect statistics on the
copy process. When used, it should be a dictionary with keys
&#8216;groups&#8217;, &#8216;leaves&#8217;,
&#8216;links&#8217; and
&#8216;bytes&#8217; having a numeric value. Their
values will be incremented to reflect the number of groups,
leaves and bytes, respectively, that have been copied during
the operation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_copyChildren">
<tt class="descclassname">Group.</tt><tt class="descname">_f_copyChildren</tt><big>(</big><em>dstgroup</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Group._f_copyChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the children of this group into another group.</p>
<p>Children hanging directly from this group are copied into
dstgroup, which can be a
Group (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) object or its pathname in string
form. If createparents is true, the needed
groups for the given destination group path to exist will be
created.</p>
<p>The operation will fail with a NodeError
if there is a child node in the destination group with the same
name as one of the copied children from this one, unless
overwrite is true; in this case, the former
child node is recursively removed before copying the later.</p>
<p>By default, nodes descending from children groups of this
node are not copied. If the recursive argument
is true, all descendant nodes of this node are recursively
copied.</p>
<p>Additional keyword arguments may be passed to customize the
copying process. For instance, title and filters may be changed,
user attributes may be or may not be copied, data may be
sub-sampled, stats may be collected, etc. Arguments unknown to
nodes are simply ignored. Check the documentation for copying
operations of nodes to see which options they support.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_getChild">
<tt class="descclassname">Group.</tt><tt class="descname">_f_getChild</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#tables.Group._f_getChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the child called childname of this group.</p>
<p>If the child exists (be it visible or not), it is returned.
Else, a NoSuchNodeError is raised.</p>
<p>Using this method is recommended over
getattr() when doing programmatic accesses to
children if childname is unknown beforehand or
when its name is not a valid Python identifier.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_iterNodes">
<tt class="descclassname">Group.</tt><tt class="descname">_f_iterNodes</tt><big>(</big><em>classname=None</em><big>)</big><a class="headerlink" href="#tables.Group._f_iterNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over children nodes.</p>
<p>Child nodes are yielded alphanumerically sorted by node
name.  If the name of a class derived from Node
(see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>)
is supplied in the classname parameter, only
instances of that class (or subclasses of it) will be
returned.</p>
<p>This is an iterator version of
<a class="reference internal" href="#tables.Group._f_listNodes" title="tables.Group._f_listNodes"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_listNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_listNodes">
<tt class="descclassname">Group.</tt><tt class="descname">_f_listNodes</tt><big>(</big><em>classname=None</em><big>)</big><a class="headerlink" href="#tables.Group._f_listNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <em>list</em> with children nodes.</p>
<p>This is a list-returning version of
<a class="reference internal" href="#tables.Group._f_iterNodes" title="tables.Group._f_iterNodes"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_iterNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_walkGroups">
<tt class="descclassname">Group.</tt><tt class="descname">_f_walkGroups</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._f_walkGroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over descendant groups (not leaves).</p>
<p>This method starts by yielding <em>self</em>,
and then it goes on to recursively iterate over all child groups
in alphanumerical order, top to bottom (preorder), following the
same procedure.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_walkNodes">
<tt class="descclassname">Group.</tt><tt class="descname">_f_walkNodes</tt><big>(</big><em>classname=None</em><big>)</big><a class="headerlink" href="#tables.Group._f_walkNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over descendant nodes.</p>
<p>This method recursively walks <em>self</em> top
to bottom (preorder), iterating over child groups in
alphanumerical order, and yielding nodes.  If
classname is supplied, only instances of the
named class are yielded.</p>
<p>If <em>classname</em> is Group, it behaves like
<a class="reference internal" href="#tables.Group._f_walkGroups" title="tables.Group._f_walkGroups"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_walkGroups()</span></tt></a>, yielding only groups.  If you
don&#8217;t want a recursive behavior, use
<a class="reference internal" href="#tables.Group._f_iterNodes" title="tables.Group._f_iterNodes"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_iterNodes()</span></tt></a> instead.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively print all the arrays hanging from &#39;/&#39;</span>
<span class="k">print</span> <span class="s">&quot;Arrays in the object tree &#39;/&#39;:&quot;</span>
<span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_f_walkNodes</span><span class="p">(</span><span class="s">&#39;Array&#39;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">array</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="group-special-methods">
<h3>Group special methods<a class="headerlink" href="#group-special-methods" title="Permalink to this headline">¶</a></h3>
<p>Following are described the methods that automatically trigger
actions when a Group instance is accessed in a
special way.</p>
<p>This class defines the __setattr__,
__getattr__ and __delattr__
methods, and they set, get and delete <em>ordinary Python
attributes</em> as normally intended. In addition to that,
__getattr__ allows getting <em>child
nodes</em> by their name for the sake of easy interaction on
the command line, as long as there is no Python attribute with the
same name. Groups also allow the interactive completion (when using
readline) of the names of child nodes. For
instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># get a Python attribute</span>
<span class="n">nchild</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">_v_nchildren</span>

<span class="c"># Add a Table child called &#39;table&#39; under &#39;group&#39;.</span>
<span class="n">h5file</span><span class="o">.</span><span class="n">createTable</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s">&#39;table&#39;</span><span class="p">,</span> <span class="n">myDescription</span><span class="p">)</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>          <span class="c"># get the table child instance</span>
<span class="n">group</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="s">&#39;foo&#39;</span>          <span class="c"># set a Python attribute</span>

<span class="c"># (PyTables warns you here about using the name of a child node.)</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>            <span class="c"># get a Python attribute</span>
<span class="k">del</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>              <span class="c"># delete a Python attribute</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>          <span class="c"># get the table child instance again</span>
</pre></div>
</div>
<dl class="method">
<dt id="tables.Group.__contains__">
<tt class="descclassname">Group.</tt><tt class="descname">__contains__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there a child with that name?</p>
<p>Returns a true value if the group has a child node (visible
or hidden) with the given <em>name</em> (a string),
false otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__delattr__">
<tt class="descclassname">Group.</tt><tt class="descname">__delattr__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a Python attribute called name.</p>
<p>This method deletes an <em>ordinary Python
attribute</em> from the object. It does
<em>not</em> remove children nodes from this group;
for that, use <a class="reference internal" href="#tables.File.removeNode" title="tables.File.removeNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.removeNode()</span></tt></a> or
<a class="reference internal" href="#tables.Node._f_remove" title="tables.Node._f_remove"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_remove()</span></tt></a>. It does <em>neither</em>
delete a PyTables node attribute; for that, use
<a class="reference internal" href="#tables.File.delNodeAttr" title="tables.File.delNodeAttr"><tt class="xref py py-meth docutils literal"><span class="pre">File.delNodeAttr()</span></tt></a>,
<a class="reference internal" href="#tables.Node._f_delAttr" title="tables.Node._f_delAttr"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_delAttr()</span></tt></a> or <tt class="xref py py-attr docutils literal"><span class="pre">:attr:`Node._v_attrs`</span></tt>.</p>
<p>If there is an attribute and a child node with the same
name, the child node will be made accessible
again via natural naming.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__getattr__">
<tt class="descclassname">Group.</tt><tt class="descname">__getattr__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Python attribute or child node called name.</p>
<p>If the object has a Python attribute called
name, its value is returned. Else, if the node
has a child node called name, it is returned.
Else, an AttributeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__iter__">
<tt class="descclassname">Group.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the child nodes hanging directly from the group.</p>
<p>This iterator is <em>not</em> recursive. Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Non-recursively list all the nodes hanging from &#39;/detector&#39;</span>
<span class="k">print</span> <span class="s">&quot;Nodes in &#39;/detector&#39; group:&quot;</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">detector</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">node</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__repr__">
<tt class="descclassname">Group.</tt><tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a detailed string representation of the group.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">group0</span>
<span class="go">/group0 (Group) &#39;First Group&#39;</span>
<span class="go">  children := [&#39;tuple1&#39; (Table), &#39;group1&#39; (Group)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__setattr__">
<tt class="descclassname">Group.</tt><tt class="descname">__setattr__</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Group.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a Python attribute called name with
the given value.</p>
<p>This method stores an <em>ordinary Python
attribute</em> in the object. It does
<em>not</em> store new children nodes under this
group; for that, use the File.create*() methods
(see the File class in <a class="reference internal" href="#fileclassdescr"><em>The File Class</em></a>). It does
<em>neither</em> store a PyTables node attribute; for
that, use <a class="reference internal" href="#tables.File.setNodeAttr" title="tables.File.setNodeAttr"><tt class="xref py py-meth docutils literal"><span class="pre">File.setNodeAttr()</span></tt></a>,
:meth`:Node._f_setAttr` or <a class="reference internal" href="#tables.Node._v_attrs" title="tables.Node._v_attrs"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_attrs</span></tt></a>.</p>
<p>If there is already a child node with the same
name, a NaturalNameWarning
will be issued and the child node will not be accessible via
natural naming nor getattr(). It will still be
available via <a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, <a class="reference internal" href="#tables.Group._f_getChild" title="tables.Group._f_getChild"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_getChild()</span></tt></a>
and children dictionaries in the group (if visible).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__str__">
<tt class="descclassname">Group.</tt><tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the group.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">group0</span>
<span class="go">/group0 (Group) &#39;First Group&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="the-leaf-class">
<span id="leafclassdescr"></span><h2>The Leaf class<a class="headerlink" href="#the-leaf-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Leaf">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Leaf</tt><a class="headerlink" href="#tables.Leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for all PyTables leaves.</p>
<p>A leaf is a node (see the Node class in <a class="reference internal" href="#tables.Node" title="tables.Node"><tt class="xref py py-class docutils literal"><span class="pre">Node</span></tt></a>) which hangs
from a group (see the Group class in <a class="reference internal" href="#tables.Group" title="tables.Group"><tt class="xref py py-class docutils literal"><span class="pre">Group</span></tt></a>) but, unlike a
group, it can not have any further children below it (i.e. it is an
end node).</p>
<p>This definition includes all nodes which contain actual data (datasets
handled by the Table - see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>, Array - see
<a class="reference internal" href="#arrayclassdescr"><em>The Array class</em></a>, CArray - see <a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>, EArray -
see <a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>, and VLArray - see <a class="reference internal" href="#vlarrayclassdescr"><em>The VLArray class</em></a>
classes) and unsupported nodes (the UnImplemented class -
<a class="reference internal" href="#unimplementedclassdescr"><em>The UnImplemented class</em></a>) these classes do in fact inherit from
Leaf.</p>
</dd></dl>

<div class="section" id="leaf-instance-variables">
<span id="leafinstancevariables"></span><h3>Leaf instance variables<a class="headerlink" href="#leaf-instance-variables" title="Permalink to this headline">¶</a></h3>
<p>These instance variables are provided in addition to those in
Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>):</p>
<dl class="attribute">
<dt id="tables.Leaf.byteorder">
<tt class="descclassname">Leaf.</tt><tt class="descname">byteorder</tt><a class="headerlink" href="#tables.Leaf.byteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>The byte ordering of the leaf data <em>on disk</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.chunkshape">
<tt class="descclassname">Leaf.</tt><tt class="descname">chunkshape</tt><a class="headerlink" href="#tables.Leaf.chunkshape" title="Permalink to this definition">¶</a></dt>
<dd><p>The HDF5 chunk size for chunked leaves (a tuple).</p>
<p>This is read-only because you cannot change the chunk
size of a leaf once it has been created.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.dtype">
<tt class="descclassname">Leaf.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#tables.Leaf.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy dtype that most closely matches this leaf type.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.extdim">
<tt class="descclassname">Leaf.</tt><tt class="descname">extdim</tt><a class="headerlink" href="#tables.Leaf.extdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the enlargeable dimension (-1 if none).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.filters">
<tt class="descclassname">Leaf.</tt><tt class="descname">filters</tt><a class="headerlink" href="#tables.Leaf.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter properties for this leaf - see
Filters in <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.flavor">
<tt class="descclassname">Leaf.</tt><tt class="descname">flavor</tt><a class="headerlink" href="#tables.Leaf.flavor" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of data object read from this leaf.</p>
<p>It can be any of &#8216;numpy&#8217;,
&#8216;numarray&#8217;, &#8216;numeric&#8217; or
&#8216;python&#8217; (the set of supported flavors
depends on which packages you have installed on your
system).</p>
<p>You can (and are encouraged to) use this property to
get, set and delete the FLAVOR HDF5
attribute of the leaf. When the leaf has no such attribute,
the default flavor is used.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The &#8216;numarray&#8217; and
&#8216;numeric&#8217; flavors are deprecated since
version 2.3. Support for these flavors will be removed in
future versions.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.maindim">
<tt class="descclassname">Leaf.</tt><tt class="descname">maindim</tt><a class="headerlink" href="#tables.Leaf.maindim" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension along which iterators work.</p>
<p>Its value is 0 (i.e. the first dimension) when the
dataset is not extendable, and self.extdim
(where available) for extendable ones.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.nrows">
<tt class="descclassname">Leaf.</tt><tt class="descname">nrows</tt><a class="headerlink" href="#tables.Leaf.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The length of the main dimension of the leaf data.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.nrowsinbuf">
<tt class="descclassname">Leaf.</tt><tt class="descname">nrowsinbuf</tt><a class="headerlink" href="#tables.Leaf.nrowsinbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of rows that fit in internal input buffers.</p>
<p>You can change this to fine-tune the speed or memory
requirements of your application.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.shape">
<tt class="descclassname">Leaf.</tt><tt class="descname">shape</tt><a class="headerlink" href="#tables.Leaf.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of data in the leaf.</p>
</dd></dl>

</div>
<div class="section" id="leaf-instance-variables-aliases">
<h3>Leaf instance variables - aliases<a class="headerlink" href="#leaf-instance-variables-aliases" title="Permalink to this headline">¶</a></h3>
<p>The following are just easier-to-write aliases to their
Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) counterparts (indicated between
parentheses):</p>
<dl class="attribute">
<dt id="tables.Leaf.attrs">
<tt class="descclassname">Leaf.</tt><tt class="descname">attrs</tt><a class="headerlink" href="#tables.Leaf.attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated AttributeSet instance - see <a class="reference internal" href="#attributesetclassdescr"><em>The AttributeSet class</em></a> - (<a class="reference internal" href="#tables.Node._v_attrs" title="tables.Node._v_attrs"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_attrs</span></tt></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.name">
<tt class="descclassname">Leaf.</tt><tt class="descname">name</tt><a class="headerlink" href="#tables.Leaf.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this node in its parent group (<a class="reference internal" href="#tables.Node._v_name" title="tables.Node._v_name"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_name</span></tt></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.objectID">
<tt class="descclassname">Leaf.</tt><tt class="descname">objectID</tt><a class="headerlink" href="#tables.Leaf.objectID" title="Permalink to this definition">¶</a></dt>
<dd><p>A node identifier (may change from run to run). (<a class="reference internal" href="#tables.Node._v_objectID" title="tables.Node._v_objectID"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_objectID</span></tt></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.title">
<tt class="descclassname">Leaf.</tt><tt class="descname">title</tt><a class="headerlink" href="#tables.Leaf.title" title="Permalink to this definition">¶</a></dt>
<dd><p>A description for this node (<a class="reference internal" href="#tables.Node._v_title" title="tables.Node._v_title"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_title</span></tt></a>).</p>
</dd></dl>

</div>
<div class="section" id="leaf-methods">
<h3>Leaf methods<a class="headerlink" href="#leaf-methods" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Leaf.close">
<tt class="descclassname">Leaf.</tt><tt class="descname">close</tt><big>(</big><em>flush=True</em><big>)</big><a class="headerlink" href="#tables.Leaf.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this node in the tree.</p>
<p>This method is completely equivalent to
<a class="reference internal" href="#tables.Leaf._f_close" title="tables.Leaf._f_close"><tt class="xref py py-meth docutils literal"><span class="pre">Leaf._f_close()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.copy">
<tt class="descclassname">Leaf.</tt><tt class="descname">copy</tt><big>(</big><em>newparent</em>, <em>newname</em>, <em>overwrite=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Leaf.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node and return the new one.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a>. Please note that there is no
recursive flag since leaves do not have child
nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>title</strong> :</p>
<blockquote>
<div><p>The new title for the destination. If omitted or
None, the original title is used.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>Specifying this parameter overrides the original
filter properties in the source node. If specified, it must
be an instance of the Filters class (see
<a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>). The default is to copy the
filter properties from the source node.</p>
</div></blockquote>
<p><strong>copyuserattrs</strong> :</p>
<blockquote>
<div><p>You can prevent the user attributes from being copied
by setting this parameter to False. The
default is to copy them.</p>
</div></blockquote>
<p><strong>start, stop, step</strong> : int</p>
<blockquote>
<div><p>Specify the range of rows to be copied; the default is
to copy all the rows.</p>
</div></blockquote>
<p><strong>stats</strong> :</p>
<blockquote>
<div><p>This argument may be used to collect statistics on the
copy process. When used, it should be a dictionary with keys
&#8216;groups&#8217;, &#8216;leaves&#8217; and
&#8216;bytes&#8217; having a numeric value. Their
values will be incremented to reflect the number of groups,
leaves and bytes, respectively, that have been copied during
the operation.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote class="last">
<div><p>The chunkshape of the new leaf.  It supports a couple
of special values.  A value of keep means
that the chunkshape will be the same than original leaf
(this is the default).  A value of auto
means that a new shape will be computed automatically in
order to ensure best performance when accessing the dataset
through the main dimension.  Any other value should be an
integer or a tuple matching the dimensions of the
leaf.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that unknown parameters passed to this method will be
ignored, so may want to double check the spell of these (i.e. if
you write them incorrectly, they will most probably be
ignored).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.delAttr">
<tt class="descclassname">Leaf.</tt><tt class="descname">delAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Leaf.delAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute from this node.</p>
<p>This method has the behavior described in
<tt class="xref py py-meth docutils literal"><span class="pre">Node_f_delAttr()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.flush">
<tt class="descclassname">Leaf.</tt><tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush pending data to disk.</p>
<p>Saves whatever remaining buffered data to disk. It also
releases I/O buffers, so if you are filling many datasets in the
same PyTables session, please call flush()
extensively so as to help PyTables to keep memory requirements low.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.getAttr">
<tt class="descclassname">Leaf.</tt><tt class="descname">getAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Leaf.getAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PyTables attribute from this node.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_getAttr" title="tables.Node._f_getAttr"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_getAttr()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.isVisible">
<tt class="descclassname">Leaf.</tt><tt class="descname">isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf.isVisible" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this node visible?</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_isVisible" title="tables.Node._f_isVisible"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_isVisible()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.move">
<tt class="descclassname">Leaf.</tt><tt class="descname">move</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.Leaf.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move or rename this node.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_move" title="tables.Node._f_move"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_move()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.rename">
<tt class="descclassname">Leaf.</tt><tt class="descname">rename</tt><big>(</big><em>newname</em><big>)</big><a class="headerlink" href="#tables.Leaf.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node in place.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_rename" title="tables.Node._f_rename"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_rename()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.remove">
<tt class="descclassname">Leaf.</tt><tt class="descname">remove</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this node from the hierarchy.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_remove" title="tables.Node._f_remove"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_remove()</span></tt></a>. Please note that there is no
recursive flag since leaves do not have child
nodes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.setAttr">
<tt class="descclassname">Leaf.</tt><tt class="descname">setAttr</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Leaf.setAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute for this node.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_setAttr" title="tables.Node._f_setAttr"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_setAttr()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.truncate">
<tt class="descclassname">Leaf.</tt><tt class="descname">truncate</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#tables.Leaf.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncate the main dimension to be size rows.</p>
<p>If the main dimension previously was larger than this
size, the extra data is lost.  If the main
dimension previously was shorter, it is extended, and the extended
part is filled with the default values.</p>
<p>The truncation operation can only be applied to
<em>enlargeable</em> datasets, else a
TypeError will be raised.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you are using the HDF5 1.6.x series, and due to
limitations of them, size must be greater
than zero (i.e. the dataset can not be completely emptied).  A
ValueError will be issued if you are using
HDF5 1.6.x and try to pass a zero size to this method.  Also,
HDF5 1.6.x has the problem that it cannot work against
CArray objects (again, a
ValueError will be issued).  HDF5 1.8.x
doesn&#8217;t undergo these problems.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.__len__">
<tt class="descclassname">Leaf.</tt><tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the main dimension of the leaf data.</p>
<p>Please note that this may raise an
OverflowError on 32-bit platforms for datasets
having more than 2**31-1 rows.  This is a limitation of Python
that you can work around by using the nrows or
shape attributes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf._f_close">
<tt class="descclassname">Leaf.</tt><tt class="descname">_f_close</tt><big>(</big><em>flush=True</em><big>)</big><a class="headerlink" href="#tables.Leaf._f_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this node in the tree.</p>
<p>This method has the behavior described in
<a class="reference internal" href="#tables.Node._f_close" title="tables.Node._f_close"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_close()</span></tt></a>.  Besides that, the optional argument
flush tells whether to flush pending data to
disk or not before closing.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-table-class">
<span id="tableclassdescr"></span><h2>The Table class<a class="headerlink" href="#the-table-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Table">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Table</tt><a class="headerlink" href="#tables.Table" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents heterogeneous datasets in an HDF5 file.</p>
<p>Tables are leaves (see the Leaf class in
<a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>) whose
data consists of a unidimensional sequence of
<em>rows</em>, where each row contains one or more
<em>fields</em>.  Fields have an associated unique
<em>name</em> and <em>position</em>, with the
first field having position 0.  All rows have the same fields, which
are arranged in <em>columns</em>.</p>
<p>Fields can have any type supported by the Col
class (see <a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>)
and its descendants, which support multidimensional data.  Moreover, a
field can be <em>nested</em> (to an arbitrary depth),
meaning that it includes further fields inside.  A field named
x inside a nested field a in a
table can be accessed as the field a/x (its
<em>path name</em>) from the table.</p>
<p>The structure of a table is declared by its description, which
is made available in the Table.description
attribute (see <a class="reference internal" href="#tableinstancevariablesdescr"><em>Table instance variables</em></a>).</p>
<p>This class provides new methods to read, write and search table
data efficiently.  It also provides special Python methods to allow
accessing the table as a normal sequence or array (with extended
slicing supported).</p>
<p>PyTables supports <em>in-kernel</em> searches
working simultaneously on several columns using complex conditions.
These are faster than selections using Python expressions.  See the
<tt class="xref py py-meth docutils literal"><span class="pre">Tables.where()</span></tt> method for more information on in-kernel searches.</p>
<p>Non-nested columns can be <em>indexed</em>.
Searching an indexed column can be several times faster than searching
a non-nested one.  Search methods automatically take advantage of
indexing where available.</p>
<p>When iterating a table, an object from the
Row (see <a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>) class is used.  This object allows to
read and write data one row at a time, as well as to perform queries
which are not supported by in-kernel syntax (at a much lower speed, of
course).</p>
<p>Objects of this class support access to individual columns via
<em>natural naming</em> through the
Table.cols accessor (see <a class="reference internal" href="#tableinstancevariablesdescr"><em>Table instance variables</em></a>).
Nested columns are mapped to Cols instances, and
non-nested ones to Column instances.  See the
Column class in <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a> for examples of this feature.</p>
</dd></dl>

<div class="section" id="table-instance-variables">
<span id="tableinstancevariablesdescr"></span><h3>Table instance variables<a class="headerlink" href="#table-instance-variables" title="Permalink to this headline">¶</a></h3>
<p>The following instance variables are provided in addition to
those in Leaf (see <a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>).  Please note that there are several
col* dictionaries to ease retrieving information
about a column directly by its path name, avoiding the need to walk
through Table.description or
Table.cols.</p>
<dl class="attribute">
<dt id="tables.Table.autoIndex">
<tt class="descclassname">Table.</tt><tt class="descname">autoIndex</tt><a class="headerlink" href="#tables.Table.autoIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically keep column indexes up to date?</p>
<p>Setting this value states whether existing indexes
should be automatically updated after an append operation or
recomputed after an index-invalidating operation (i.e. removal
and modification of rows). The default is true.</p>
<p>This value gets into effect whenever a column is
altered. If you don&#8217;t have automatic indexing activated and
you want to do an immediate update use
<a class="reference internal" href="#tables.Table.flushRowsToIndex" title="tables.Table.flushRowsToIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Table.flushRowsToIndex()</span></tt></a>; for immediate reindexing
of invalidated indexes, use
<a class="reference internal" href="#tables.Table.reIndexDirty" title="tables.Table.reIndexDirty"><tt class="xref py py-meth docutils literal"><span class="pre">Table.reIndexDirty()</span></tt></a>.</p>
<p>This value is persistent.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coldescrs">
<tt class="descclassname">Table.</tt><tt class="descname">coldescrs</tt><a class="headerlink" href="#tables.Table.coldescrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its Col
description (see <a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coldflts">
<tt class="descclassname">Table.</tt><tt class="descname">coldflts</tt><a class="headerlink" href="#tables.Table.coldflts" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its default value.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coldtypes">
<tt class="descclassname">Table.</tt><tt class="descname">coldtypes</tt><a class="headerlink" href="#tables.Table.coldtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its NumPy data type.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colindexed">
<tt class="descclassname">Table.</tt><tt class="descname">colindexed</tt><a class="headerlink" href="#tables.Table.colindexed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the column which name is used as a key indexed?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colindexes">
<tt class="descclassname">Table.</tt><tt class="descname">colindexes</tt><a class="headerlink" href="#tables.Table.colindexes" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary with the indexes of the indexed columns.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colinstances">
<tt class="descclassname">Table.</tt><tt class="descname">colinstances</tt><a class="headerlink" href="#tables.Table.colinstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its
Column (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) or
Cols (see <a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>) instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colnames">
<tt class="descclassname">Table.</tt><tt class="descname">colnames</tt><a class="headerlink" href="#tables.Table.colnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing the names of <em>top-level</em> columns in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colpathnames">
<tt class="descclassname">Table.</tt><tt class="descname">colpathnames</tt><a class="headerlink" href="#tables.Table.colpathnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing the pathnames of
<em>bottom-level</em> columns in the table.</p>
<p>These are the leaf columns obtained when walking the
table description left-to-right, bottom-first. Columns inside
a nested column have slashes (/) separating
name components in their pathname.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.cols">
<tt class="descclassname">Table.</tt><tt class="descname">cols</tt><a class="headerlink" href="#tables.Table.cols" title="Permalink to this definition">¶</a></dt>
<dd><p>A Cols instance that provides
<em>natural naming</em> access to non-nested
(Column, see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) and
nested (Cols, see <a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>)
columns.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coltypes">
<tt class="descclassname">Table.</tt><tt class="descname">coltypes</tt><a class="headerlink" href="#tables.Table.coltypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its PyTables
data type.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.description">
<tt class="descclassname">Table.</tt><tt class="descname">description</tt><a class="headerlink" href="#tables.Table.description" title="Permalink to this definition">¶</a></dt>
<dd><p>A Description instance (see <a class="reference internal" href="#descriptionclassdescr"><em>The Description class</em></a>)
reflecting the structure of the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.extdim">
<tt class="descclassname">Table.</tt><tt class="descname">extdim</tt><a class="headerlink" href="#tables.Table.extdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the enlargeable dimension (always 0 for tables).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.indexed">
<tt class="descclassname">Table.</tt><tt class="descname">indexed</tt><a class="headerlink" href="#tables.Table.indexed" title="Permalink to this definition">¶</a></dt>
<dd><p>Does this table have any indexed columns?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.indexedcolpathnames">
<tt class="descclassname">Table.</tt><tt class="descname">indexedcolpathnames</tt><a class="headerlink" href="#tables.Table.indexedcolpathnames" title="Permalink to this definition">¶</a></dt>
<dd><p>List of the pathnames of indexed columns in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.nrows">
<tt class="descclassname">Table.</tt><tt class="descname">nrows</tt><a class="headerlink" href="#tables.Table.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The current number of rows in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.row">
<tt class="descclassname">Table.</tt><tt class="descname">row</tt><a class="headerlink" href="#tables.Table.row" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated Row instance (see <a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.rowsize">
<tt class="descclassname">Table.</tt><tt class="descname">rowsize</tt><a class="headerlink" href="#tables.Table.rowsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size in bytes of each row in the table.</p>
</dd></dl>

</div>
<div class="section" id="table-methods-reading">
<h3>Table methods - reading<a class="headerlink" href="#table-methods-reading" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Table.col">
<tt class="descclassname">Table.</tt><tt class="descname">col</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Table.col" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a column from the table.</p>
<p>If a column called name exists in the
table, it is read and returned as a NumPy object, or as a
numarray object (depending on the flavor of the
table). If it does not exist, a KeyError is
raised.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">narray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s">&#39;var2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>That statement is equivalent to::</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">narray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="s">&#39;var2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here you can see how this method can be used as a shorthand
for the <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.iterrows">
<tt class="descclassname">Table.</tt><tt class="descname">iterrows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the table using a Row
instance (see <a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>).</p>
<p>If a range is not supplied, <em>all the
rows</em> in the table are iterated upon - you can also use
the <a class="reference internal" href="#tables.Table.__iter__" title="tables.Table.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">Table.__iter__()</span></tt></a> special method for that purpose. If you want to
iterate over a given <em>range of rows</em> in the
table, you may use the start,
stop and step parameters,
which have the same meaning as in <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This iterator can be nested (see <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> for an
example).</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When in the middle of a table row iterator, you should not
use methods that can change the number of rows in the table
(like <a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a> or <a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>)
or unexpected errors will happen.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Table.itersequence">
<tt class="descclassname">Table.</tt><tt class="descname">itersequence</tt><big>(</big><em>sequence</em><big>)</big><a class="headerlink" href="#tables.Table.itersequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over a sequence of row coordinates.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This iterator can be nested (see <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> for an
example).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Table.itersorted">
<tt class="descclassname">Table.</tt><tt class="descname">itersorted</tt><big>(</big><em>sortby</em>, <em>checkCSI=False</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.itersorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate table data following the order of the index of sortby column.</p>
<p>sortby column must have associated a
full index.  If you want to ensure a fully
sorted order, the index must be a CSI one.  You may want to use
the checkCSI argument in order to explicitly
check for the existence of a CSI index.</p>
<p>The meaning of the start,
stop and step arguments is
the same as in <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>.  However, in this case a negative value
of step is supported, meaning that the results
will be returned in reverse sorted order.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.read">
<tt class="descclassname">Table.</tt><tt class="descname">read</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em>, <em>field=None</em><big>)</big><a class="headerlink" href="#tables.Table.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data in the table as a (record) array.</p>
<p>The start, stop and
step parameters can be used to select only a
<em>range of rows</em> in the table. Their meanings
are the same as in the built-in range() Python
function, except that negative values of step
are not allowed yet. Moreover, if only start is
specified, then stop will be set to
start+1. If you do not specify neither
start nor stop, then
<em>all the rows</em> in the table are
selected.</p>
<p>If field is supplied only the named
column will be selected.  If the column is not nested, an
<em>array</em> of the current flavor will be returned;
if it is, a <em>record array</em> will be used
instead.  I no field is specified, all the
columns will be returned in a record array of the current flavor.</p>
<p>Columns under a nested column can be specified in the
field parameter by using a slash character
(/) as a separator (e.g. &#8216;position/x&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.readCoordinates">
<tt class="descclassname">Table.</tt><tt class="descname">readCoordinates</tt><big>(</big><em>coords</em>, <em>field=None</em><big>)</big><a class="headerlink" href="#tables.Table.readCoordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a set of rows given their indexes as a (record) array.</p>
<p>This method works much like the <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>
method, but it uses a sequence
(coords) of row indexes to select the wanted
columns, instead of a column range.</p>
<p>The selected rows are returned in an array or record array
of the current flavor.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.readSorted">
<tt class="descclassname">Table.</tt><tt class="descname">readSorted</tt><big>(</big><em>sortby</em>, <em>checkCSI=False</em>, <em>field=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.readSorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Read table data following the order of the index of sortby column.</p>
<p>sortby column must have associated a
full index.  If you want to ensure a fully
sorted order, the index must be a CSI one.  You may want to use
the checkCSI argument in order to explicitly
check for the existence of a CSI index.</p>
<p>If field is supplied only the named
column will be selected.  If the column is not nested, an
<em>array</em> of the current flavor will be returned;
if it is, a <em>record array</em> will be used
instead.  If no field is specified, all the
columns will be returned in a record array of the current
flavor.</p>
<p>The meaning of the start,
stop and step arguments is
the same as in <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>.  However, in this case a negative value
of step is supported, meaning that the results
will be returned in reverse sorted order.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.__getitem__">
<tt class="descclassname">Table.</tt><tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Table.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from the table.</p>
<p>If key argument is an integer, the
corresponding table row is returned as a record of the current
flavor. If key is a slice, the range of rows
determined by it is returned as a record array of the current
flavor.</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row
coordinates, the set of rows determined by it is returned.
Furthermore, if key is an array of boolean
values, only the coordinates where key
is True are returned.  Note that for the latter
to work it is necessary that key list would
contain exactly as many rows as the table has.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">record</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1000</span><span class="p">]]</span>   <span class="c"># only retrieves rows 4 and 1000</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="p">[[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="bp">True</span><span class="p">]]</span>
</pre></div>
</div>
<p>Those statements are equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">record</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">readCoordinates</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">1000</span><span class="p">])</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">readCoordinates</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
</pre></div>
</div>
<p>Here, you can see how indexing can be used as a shorthand
for the <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a> and <a class="reference internal" href="#tables.Table.readCoordinates" title="tables.Table.readCoordinates"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readCoordinates()</span></tt></a> methods.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.__iter__">
<tt class="descclassname">Table.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the table using a Row
instance (see <a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>).</p>
<p>This is equivalent to calling
<a class="reference internal" href="#tables.Table.iterrows" title="tables.Table.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.iterrows()</span></tt></a> with default arguments, i.e. it
iterates over <em>all the rows</em> in the table.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This iterator can be nested (see <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> for an
example).</p>
</div>
</dd></dl>

</div>
<div class="section" id="table-methods-writing">
<h3>Table methods - writing<a class="headerlink" href="#table-methods-writing" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Table.append">
<tt class="descclassname">Table.</tt><tt class="descname">append</tt><big>(</big><em>rows</em><big>)</big><a class="headerlink" href="#tables.Table.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a sequence of rows to the end of the table.</p>
<p>The rows argument may be any object which
can be converted to a record array compliant with the table
structure (otherwise, a ValueError is raised).
This includes NumPy record arrays, RecArray
(depracated) or NestedRecArray (deprecated)
objects if numarray is available, lists of
tuples or array records, and a string or Python buffer.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">tables</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Particle</span><span class="p">(</span><span class="n">IsDescription</span><span class="p">):</span>
    <span class="n">name</span>        <span class="o">=</span> <span class="n">StringCol</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c"># 16-character String</span>
    <span class="n">lati</span>        <span class="o">=</span> <span class="n">IntCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>        <span class="c"># integer</span>
    <span class="n">longi</span>       <span class="o">=</span> <span class="n">IntCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># integer</span>
    <span class="n">pressure</span>    <span class="o">=</span> <span class="n">Float32Col</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>    <span class="c"># float  (single-precision)</span>
    <span class="n">temperature</span> <span class="o">=</span> <span class="n">FloatCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>      <span class="c"># double (double-precision)</span>

<span class="n">fileh</span> <span class="o">=</span> <span class="n">openFile</span><span class="p">(</span><span class="s">&#39;test4.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createTable</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;table&#39;</span><span class="p">,</span> <span class="n">Particle</span><span class="p">,</span> <span class="s">&quot;A table&quot;</span><span class="p">)</span>

<span class="c"># Append several rows in only one call</span>
<span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="s">&quot;Particle:     10&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
              <span class="p">(</span><span class="s">&quot;Particle:     11&quot;</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="o">*</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
              <span class="p">(</span><span class="s">&quot;Particle:     12&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyColumn">
<tt class="descclassname">Table.</tt><tt class="descname">modifyColumn</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em>, <em>column=None</em>, <em>colname=None</em><big>)</big><a class="headerlink" href="#tables.Table.modifyColumn" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify one single column in the row slice [start:stop:step].</p>
<p>The colname argument specifies the name
of the column in the table to be modified with the data given in
column.  This method returns the number of rows
modified.  Should the modification exceed the length of the table,
an IndexError is raised before changing data.</p>
<p>The column argument may be any object
which can be converted to a (record) array compliant with the
structure of the column to be modified (otherwise, a
ValueError is raised).  This includes NumPy
(record) arrays, NumArray (deprecated),
RecArray (deprecated) or
NestedRecArray (deprecated) objects if
numarray is available, Numeric arrays
if available (deprecated), lists of scalars, tuples or array
records, and a string or Python buffer.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyColumns">
<tt class="descclassname">Table.</tt><tt class="descname">modifyColumns</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em>, <em>columns=None</em>, <em>names=None</em><big>)</big><a class="headerlink" href="#tables.Table.modifyColumns" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a series of columns in the row slice [start:stop:step].</p>
<p>The names argument specifies the names of
the columns in the table to be modified with the data given in
columns.  This method returns the number of
rows modified.  Should the modification exceed the length of the
table, an IndexError is raised before changing data.</p>
<p>The columns argument may be any object
which can be converted to a record array compliant with the
structure of the columns to be modified (otherwise, a
ValueError is raised).  This includes NumPy
record arrays, RecArray (deprecated) or
NestedRecArray (deprecated) objects if
numarray is available, lists of tuples or array
records, and a string or Python buffer.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyCoordinates">
<tt class="descclassname">Table.</tt><tt class="descname">modifyCoordinates</tt><big>(</big><em>coords</em>, <em>rows</em><big>)</big><a class="headerlink" href="#tables.Table.modifyCoordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a series of rows in positions specified in coords</p>
<p>The values in the selected rows will be modified with the
data given in rows.  This method returns the
number of rows modified.</p>
<p>The possible values for the rows argument
are the same as in <a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyRows">
<tt class="descclassname">Table.</tt><tt class="descname">modifyRows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em>, <em>rows=None</em><big>)</big><a class="headerlink" href="#tables.Table.modifyRows" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a series of rows in the slice [start:stop:step].</p>
<p>The values in the selected rows will be modified with the
data given in rows.  This method returns the
number of rows modified.  Should the modification exceed the
length of the table, an IndexError is raised
before changing data.</p>
<p>The possible values for the rows argument
are the same as in <a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.removeRows">
<tt class="descclassname">Table.</tt><tt class="descname">removeRows</tt><big>(</big><em>start</em>, <em>stop=None</em><big>)</big><a class="headerlink" href="#tables.Table.removeRows" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a range of rows in the table.</p>
<p>If only start is supplied, only this row
is to be deleted.  If a range is supplied, i.e. both the
start and stop parameters
are passed, all the rows in the range are removed. A
step parameter is not supported, and it is not
foreseen to be implemented anytime soon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>start</strong> : int</p>
<blockquote>
<div><p>Sets the starting row to be removed. It accepts
negative values meaning that the count starts from the end.
A value of 0 means the first row.</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote class="last">
<div><p>Sets the last row to be removed to
stop-1, i.e. the end point is omitted (in
the Python range() tradition). Negative
values are also accepted. A special value of
None (the default) means removing just
the row supplied in start.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Table.__setitem__">
<tt class="descclassname">Table.</tt><tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Table.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row or a range of rows in the table.</p>
<p>It takes different actions depending on the type of the
key parameter: if it is an integer, the
corresponding table row is set to value (a
record or sequence capable of being converted to the table
structure). If key is a slice, the row slice
determined by it is set to value (a record
array or sequence capable of being converted to the table
structure).</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row
coordinates, the set of rows determined by it is set
to value.  Furthermore,
if key is an array of boolean values, only the
coordinates where key
is True are set to values
from value.  Note that for the latter to work
it is necessary that key list would contain
exactly as many rows as the table has.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Modify just one existing row</span>
<span class="n">table</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">456</span><span class="p">,</span><span class="s">&#39;db2&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">]</span>

<span class="c"># Modify two existing rows</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">457</span><span class="p">,</span><span class="s">&#39;db1&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="s">&#39;de2&#39;</span><span class="p">,</span><span class="mf">1.3</span><span class="p">]],</span> <span class="n">formats</span><span class="o">=</span><span class="s">&#39;i4,a3,f8&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rows</span>             <span class="c"># modify a table slice</span>
<span class="n">table</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">rows</span>              <span class="c"># only modifies rows 1 and 3</span>
<span class="n">table</span><span class="p">[[</span><span class="bp">True</span><span class="p">,</span><span class="bp">False</span><span class="p">,</span><span class="bp">True</span><span class="p">]]</span> <span class="o">=</span> <span class="n">rows</span>  <span class="c"># only modifies rows 0 and 2</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">table</span><span class="o">.</span><span class="n">modifyRows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="p">[</span><span class="mi">456</span><span class="p">,</span><span class="s">&#39;db2&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">])</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">457</span><span class="p">,</span><span class="s">&#39;db1&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="s">&#39;de2&#39;</span><span class="p">,</span><span class="mf">1.3</span><span class="p">]],</span> <span class="n">formats</span><span class="o">=</span><span class="s">&#39;i4,a3,f8&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyRows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyCoordinates</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">rows</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyCoordinates</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">],</span> <span class="n">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, you can see how indexing can be used as a shorthand
for the <a class="reference internal" href="#tables.Table.modifyRows" title="tables.Table.modifyRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyRows()</span></tt></a>  and <a class="reference internal" href="#tables.Table.modifyCoordinates" title="tables.Table.modifyCoordinates"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyCoordinates()</span></tt></a> methods.</p>
</dd></dl>

</div>
<div class="section" id="table-methods-querying">
<span id="tablemethods-querying"></span><h3>Table methods - querying<a class="headerlink" href="#table-methods-querying" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Table.getWhereList">
<tt class="descclassname">Table.</tt><tt class="descname">getWhereList</tt><big>(</big><em>condition</em>, <em>condvars=None</em>, <em>sort=False</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.getWhereList" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the row coordinates fulfilling the given condition.</p>
<p>The coordinates are returned as a list of the current
flavor.  sort means that you want to retrieve
the coordinates ordered. The default is to not sort them.</p>
<p>The meaning of the other arguments is the same as in the
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.readWhere">
<tt class="descclassname">Table.</tt><tt class="descname">readWhere</tt><big>(</big><em>condition</em>, <em>condvars=None</em>, <em>field=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.readWhere" title="Permalink to this definition">¶</a></dt>
<dd><p>Read table data fulfilling the given <em>condition</em>.</p>
<p>This method is similar to <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>, having their common arguments
and return values the same meanings. However, only the rows
fulfilling the <em>condition</em> are included in the
result.</p>
<p>The meaning of the other arguments is the same as in the
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.where">
<tt class="descclassname">Table.</tt><tt class="descname">where</tt><big>(</big><em>condition</em>, <em>condvars=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over values fulfilling a condition.</p>
<p>This method returns a Row iterator (see
<a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>) which
only selects rows in the table that satisfy the given
condition (an expression-like string).</p>
<p>The condvars mapping may be used to
define the variable names appearing in the
condition. condvars should
consist of identifier-like strings pointing to
Column (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) instances <em>of this
table</em>, or to other values (which will be converted to
arrays). A default set of condition variables is provided where
each top-level, non-nested column with an identifier-like name
appears. Variables in condvars override the
default ones.</p>
<p>When condvars is not provided or
None, the current local and global namespace is
sought instead of condvars. The previous
mechanism is mostly intended for interactive usage. To disable it,
just specify a (maybe empty) mapping as condvars.</p>
<p>If a range is supplied (by setting some of the
start, stop or step parameters), only the rows in that range
and fulfilling the condition
are used. The meaning of the start,
stop and step parameters is
the same as in the range() Python function,
except that negative values of step are
not allowed. Moreover, if only
start is specified, then
stop will be set to start+1.</p>
<p>When possible, indexed columns participating in the
condition will be used to speed up the search. It is recommended
that you place the indexed columns as left and out in the
condition as possible. Anyway, this method has always better
performance than regular Python selections on the table.</p>
<p>You can mix this method with regular Python selections in
order to support even more complex queries. It is strongly
recommended that you pass the most restrictive condition as the
parameter to this method if you want to achieve maximum
performance.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">passvalues</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span>
<span class="gp">... </span>               <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;(col1 &gt; 0) &amp; (col2 &lt;= 20)&#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span>               <span class="k">if</span> <span class="n">your_function</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">])</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Values that pass the cuts:&quot;</span><span class="p">,</span> <span class="n">passvalues</span>
</pre></div>
</div>
<p>Note that, from PyTables 1.1 on, you can nest several
iterators over the same table. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;pressure &lt; 16&#39;</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">rout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;pressure &lt; 9&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">rout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;energy &lt; 10&#39;</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;pressure, energy:&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;pressure&#39;</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In this example, iterators returned by
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> have been used, but you may as
well use any of the other reading iterators that
Table objects offer. See the file
<tt class="file docutils literal"><span class="pre">examples/nested-iter.py</span></tt> for the full code.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When in the middle of a table row iterator, you should not
use methods that can change the number of rows in the table
(like <a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a> or <a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>) or unexpected
errors will happen.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Table.whereAppend">
<tt class="descclassname">Table.</tt><tt class="descname">whereAppend</tt><big>(</big><em>dstTable</em>, <em>condition</em>, <em>condvars=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.whereAppend" title="Permalink to this definition">¶</a></dt>
<dd><p>Append rows fulfilling the condition to the dstTable table.</p>
<p>dstTable must be capable of taking the
rows resulting from the query, i.e. it must have columns with the
expected names and compatible types. The meaning of the other
arguments is the same as in the <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a>
method.</p>
<p>The number of rows appended to dstTable
is returned as a result.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.willQueryUseIndexing">
<tt class="descclassname">Table.</tt><tt class="descname">willQueryUseIndexing</tt><big>(</big><em>condition</em>, <em>condvars=None</em><big>)</big><a class="headerlink" href="#tables.Table.willQueryUseIndexing" title="Permalink to this definition">¶</a></dt>
<dd><p>Will a query for the condition use indexing?</p>
<p>The meaning of the condition and
<em>condvars</em> arguments is the same as in the
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method. If condition can use
indexing, this method returns a frozenset with the path names of
the columns whose index is usable. Otherwise, it returns an empty
list.</p>
<p>This method is mainly intended for testing. Keep in mind
that changing the set of indexed columns or their dirtiness may
make this method return different values for the same arguments at
different times.</p>
</dd></dl>

</div>
<div class="section" id="table-methods-other">
<h3>Table methods - other<a class="headerlink" href="#table-methods-other" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Table.copy">
<tt class="descclassname">Table.</tt><tt class="descname">copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Table.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this table and return the new one.</p>
<p>This method has the behavior and keywords described in
<a class="reference internal" href="#tables.Leaf.copy" title="tables.Leaf.copy"><tt class="xref py py-meth docutils literal"><span class="pre">Leaf.copy()</span></tt></a>.
Moreover, it recognises the following additional keyword
arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>sortby</strong> :</p>
<blockquote>
<div><p>If specified, and sortby
corresponds to a column with an index, then the copy will be
sorted by this index.  If you want to ensure a fully sorted
order, the index must be a CSI one.  A reverse sorted copy
can be achieved by specifying a negative value for
the step keyword.
If sortby is omitted or None, the original table order is used.</p>
</div></blockquote>
<p><strong>checkCSI</strong> :</p>
<blockquote>
<div><p>If true and a CSI index does not exist for the
sortby column, an error will be raised.
If false (the default), it does nothing.  You can use this
flag in order to explicitly check for the existence of a
CSI index.</p>
</div></blockquote>
<p><strong>propindexes</strong> :</p>
<blockquote class="last">
<div><p>If true, the existing indexes in the source table are
propagated (created) to the new one.  If false (the
default), the indexes are not propagated.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Table.flushRowsToIndex">
<tt class="descclassname">Table.</tt><tt class="descname">flushRowsToIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.flushRowsToIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add remaining rows in buffers to non-dirty indexes.</p>
<p>This can be useful when you have chosen non-automatic
indexing for the table (see the <a class="reference internal" href="#tables.Table.autoIndex" title="tables.Table.autoIndex"><tt class="xref py py-attr docutils literal"><span class="pre">Table.autoIndex</span></tt></a>
property in <a class="reference internal" href="#tableinstancevariablesdescr"><em>Table instance variables</em></a>) and you want to update the indexes on it.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.getEnum">
<tt class="descclassname">Table.</tt><tt class="descname">getEnum</tt><big>(</big><em>colname</em><big>)</big><a class="headerlink" href="#tables.Table.getEnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the enumerated type associated with the named column.</p>
<p>If the column named colname (a string)
exists and is of an enumerated type, the corresponding
Enum instance (see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>) is
returned. If it is not of an enumerated type, a
TypeError is raised. If the column does not
exist, a KeyError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.reIndex">
<tt class="descclassname">Table.</tt><tt class="descname">reIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.reIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute all the existing indexes in the table.</p>
<p>This can be useful when you suspect that, for any reason,
the index information for columns is no longer valid and want to
rebuild the indexes on it.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.reIndexDirty">
<tt class="descclassname">Table.</tt><tt class="descname">reIndexDirty</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.reIndexDirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the existing indexes in table, <em>if</em> they are dirty.</p>
<p>This can be useful when you have set
<a class="reference internal" href="#tables.Table.autoIndex" title="tables.Table.autoIndex"><tt class="xref py py-attr docutils literal"><span class="pre">Table.autoIndex</span></tt></a> (see <a class="reference internal" href="#tableinstancevariablesdescr"><em>Table instance variables</em></a>) to false for the table
and you want to update the indexes
after a invalidating index operation
(<a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>, for example).</p>
</dd></dl>

</div>
<div class="section" id="the-description-class">
<span id="descriptionclassdescr"></span><h3>The Description class<a class="headerlink" href="#the-description-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Description">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Description</tt><a class="headerlink" href="#tables.Description" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents descriptions of the structure of tables.</p>
<p>An instance of this class is automatically bound to Table (see
<a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>) objects when they are created.  It provides a
browseable representation of the structure of the table, made of
non-nested (Col - see <a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>) and nested (Description)
columns. It also contains information that will allow you to build
NestedRecArray (see <tt class="xref py py-class docutils literal"><span class="pre">NestedRecArray</span></tt>) objects suited for the
different columns in a table (be they nested or not).</p>
<p>Column definitions under a description can be accessed as
attributes of it (<em>natural naming</em>). For
instance, if table.description is a
Description instance with a column named
col1 under it, the later can be accessed as
table.description.col1. If
col1 is nested and contains a
col2 column, this can be accessed as
table.description.col1.col2. Because of natural
naming, the names of members start with special prefixes, like in
the Group class (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</dd></dl>

<div class="section" id="description-instance-variables">
<h4>Description instance variables<a class="headerlink" href="#description-instance-variables" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="tables.Description._v_colObjects">
<tt class="descclassname">Description.</tt><tt class="descname">_v_colObjects</tt><a class="headerlink" href="#tables.Description._v_colObjects" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping the names of the columns hanging
directly from the associated table or nested column to their
respective descriptions (Col - see <a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a> or
Description - see <a class="reference internal" href="#descriptionclassdescr"><em>The Description class</em></a> instances).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_dflts">
<tt class="descclassname">Description.</tt><tt class="descname">_v_dflts</tt><a class="headerlink" href="#tables.Description._v_dflts" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping the names of non-nested columns
hanging directly from the associated table or nested column
to their respective default values.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_dtype">
<tt class="descclassname">Description.</tt><tt class="descname">_v_dtype</tt><a class="headerlink" href="#tables.Description._v_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy type which reflects the structure of this
table or nested column.  You can use this as the
dtype argument of NumPy array factories.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_dtypes">
<tt class="descclassname">Description.</tt><tt class="descname">_v_dtypes</tt><a class="headerlink" href="#tables.Description._v_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping the names of non-nested columns
hanging directly from the associated table or nested column
to their respective NumPy types.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_is_nested">
<tt class="descclassname">Description.</tt><tt class="descname">_v_is_nested</tt><a class="headerlink" href="#tables.Description._v_is_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the associated table or nested column contains
further nested columns or not.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_itemsize">
<tt class="descclassname">Description.</tt><tt class="descname">_v_itemsize</tt><a class="headerlink" href="#tables.Description._v_itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size in bytes of an item in this table or nested column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_name">
<tt class="descclassname">Description.</tt><tt class="descname">_v_name</tt><a class="headerlink" href="#tables.Description._v_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this description group. The name of the
root group is &#8216;/&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_names">
<tt class="descclassname">Description.</tt><tt class="descname">_v_names</tt><a class="headerlink" href="#tables.Description._v_names" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the names of the columns hanging directly
from the associated table or nested column. The order of the
names matches the order of their respective columns in the
containing table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_nestedDescr">
<tt class="descclassname">Description.</tt><tt class="descname">_v_nestedDescr</tt><a class="headerlink" href="#tables.Description._v_nestedDescr" title="Permalink to this definition">¶</a></dt>
<dd><p>A nested list of pairs of (name, format) tuples for all the columns under
this table or nested column. You can use this as the dtype and descr
arguments of NumPy array and NestedRecArray (see
<a class="reference internal" href="nested_rec_arrays.html#nestedrecarrayclassdescr"><em>Using nested record arrays (deprecated)</em></a>) factories, respectively.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_nestedFormats">
<tt class="descclassname">Description.</tt><tt class="descname">_v_nestedFormats</tt><a class="headerlink" href="#tables.Description._v_nestedFormats" title="Permalink to this definition">¶</a></dt>
<dd><p>A nested list of the NumPy string formats (and shapes)
of all the columns under this table or nested column. You
can use this as the formats argument of
NumPy array and NestedRecArray (see <tt class="xref py py-class docutils literal"><span class="pre">NestedRecArray</span></tt>) factories.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_nestedlvl">
<tt class="descclassname">Description.</tt><tt class="descname">_v_nestedlvl</tt><a class="headerlink" href="#tables.Description._v_nestedlvl" title="Permalink to this definition">¶</a></dt>
<dd><p>The level of the associated table or nested column in
the nested datatype.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_nestedNames">
<tt class="descclassname">Description.</tt><tt class="descname">_v_nestedNames</tt><a class="headerlink" href="#tables.Description._v_nestedNames" title="Permalink to this definition">¶</a></dt>
<dd><p>A nested list of the names of all the columns under this table or nested
column. You can use this as the names argument of NumPy array and
NestedRecArray (see <a class="reference internal" href="nested_rec_arrays.html#nestedrecarrayclassdescr"><em>Using nested record arrays (deprecated)</em></a>) factories.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_pathnames">
<tt class="descclassname">Description.</tt><tt class="descname">_v_pathnames</tt><a class="headerlink" href="#tables.Description._v_pathnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the pathnames of all the columns under this
table or nested column (in preorder).  If it does not
contain nested columns, this is exactly the same as the
<a class="reference internal" href="#tables.Description._v_names" title="tables.Description._v_names"><tt class="xref py py-attr docutils literal"><span class="pre">Description._v_names</span></tt></a> attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Description._v_types">
<tt class="descclassname">Description.</tt><tt class="descname">_v_types</tt><a class="headerlink" href="#tables.Description._v_types" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping the names of non-nested columns
hanging directly from the associated table or nested column
to their respective PyTables types.</p>
</dd></dl>

</div>
<div class="section" id="description-methods">
<h4>Description methods<a class="headerlink" href="#description-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Description._f_walk">
<tt class="descclassname">Description.</tt><tt class="descname">_f_walk</tt><big>(</big><em>type='All'</em><big>)</big><a class="headerlink" href="#tables.Description._f_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over nested columns.</p>
<p>If type is &#8216;All&#8217;
(the default), all column description objects
(Col and Description
instances) are yielded in top-to-bottom order (preorder).</p>
<p>If type is &#8216;Col&#8217; or
&#8216;Description&#8217;, only column descriptions of
that type are yielded.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-row-class">
<span id="rowclassdescr"></span><h3>The Row class<a class="headerlink" href="#the-row-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Row">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Row</tt><a class="headerlink" href="#tables.Row" title="Permalink to this definition">¶</a></dt>
<dd><p>Table row iterator and field accessor.</p>
<p>Instances of this class are used to fetch and set the values
of individual table fields.  It works very much like a dictionary,
where keys are the pathnames or positions (extended slicing is
supported) of the fields in the associated table in a specific row.</p>
<p>This class provides an <em>iterator interface</em>
so that you can use the same Row instance to
access successive table rows one after the other.  There are also
some important methods that are useful for accessing, adding and
modifying values in tables.</p>
</dd></dl>

<div class="section" id="row-instance-variables">
<h4>Row instance variables<a class="headerlink" href="#row-instance-variables" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="tables.Row.nrow">
<tt class="descclassname">Row.</tt><tt class="descname">nrow</tt><a class="headerlink" href="#tables.Row.nrow" title="Permalink to this definition">¶</a></dt>
<dd><p>The current row number.</p>
<p>This property is useful for knowing which row is being
dealt with in the middle of a loop or iterator.</p>
</dd></dl>

</div>
<div class="section" id="row-methods">
<h4>Row methods<a class="headerlink" href="#row-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Row.append">
<tt class="descclassname">Row.</tt><tt class="descname">append</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Row.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new row of data to the end of the dataset.</p>
<p>Once you have filled the proper fields for the current
row, calling this method actually appends the new data to the
<em>output buffer</em> (which will eventually be
dumped to disk).  If you have not set the value of a field, the
default value of the column will be used.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">row</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">row</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">After completion of the loop in which <a class="reference internal" href="#tables.Row.append" title="tables.Row.append"><tt class="xref py py-meth docutils literal"><span class="pre">Row.append()</span></tt></a> has
been called, it is always
convenient to make a call to <tt class="xref py py-meth docutils literal"><span class="pre">Table.flush()</span></tt>
in order to avoid losing the last rows that may still remain
in internal buffers.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Row.fetch_all_fields">
<tt class="descclassname">Row.</tt><tt class="descname">fetch_all_fields</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Row.fetch_all_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve all the fields in the current row.</p>
<p>Contrarily to row[:] (see <a class="reference internal" href="#rowspecialmethods"><em>Row special methods</em></a>), this returns row data as a
NumPy void scalar.  For instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">fetch_all_fields</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;col1 &lt; 3&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>will select all the rows that fulfill the given condition
as a list of NumPy records.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Row.update">
<tt class="descclassname">Row.</tt><tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Row.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the data of the current row in the dataset.</p>
<p>This method allows you to modify values in a table when
you are in the middle of a table iterator like
<a class="reference internal" href="#tables.Table.iterrows" title="tables.Table.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.iterrows()</span></tt></a> or <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a>.</p>
<p>Once you have filled the proper fields for the current
row, calling this method actually changes data in the
<em>output buffer</em> (which will eventually be
dumped to disk).  If you have not set the value of a field, its
original value will be used.</p>
<p>Examples of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">nrow</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>which modifies every tenth row in table.  Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;col1 &gt; 3&#39;</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">nrow</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>which just updates the rows with values bigger than 3 in
the first column.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">After completion of the loop in which <a class="reference internal" href="#tables.Row.update" title="tables.Row.update"><tt class="xref py py-meth docutils literal"><span class="pre">Row.update()</span></tt></a> has
been called, it is always
convenient to make a call to <tt class="xref py py-meth docutils literal"><span class="pre">Table.flush()</span></tt>
in order to avoid losing changed rows that may still remain in
internal buffers.</p>
</div>
</dd></dl>

</div>
<div class="section" id="row-special-methods">
<span id="rowspecialmethods"></span><h4>Row special methods<a class="headerlink" href="#row-special-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Row.__contains__">
<tt class="descclassname">Row.</tt><tt class="descname">__contains__</tt><big>(</big><em>item</em><big>)</big><a class="headerlink" href="#tables.Row.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is item in this row?</p>
<p>A true value is returned if item is
found in current row, false otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Row.__getitem__">
<tt class="descclassname">Row.</tt><tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Row.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the row field specified by the key.</p>
<p>The key can be a string (the name of
the field), an integer (the position of the field) or a slice
(the range of field positions). When key is a
slice, the returned value is a <em>tuple</em>
containing the values of the specified fields.</p>
<p>Examples of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s">&#39;var3&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;var2 &lt; 20&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>which selects the var3 field for all
the rows that fulfil the condition. Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>which selects the field in the <em>4th</em>
position for all the rows that fulfil the
condition. Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>which selects the all the fields (in the form of a
<em>tuple</em>) for all the rows that fulfil the
condition. Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>which selects all the fields in even positions (in the
form of a <em>tuple</em>) for all the rows in the
slice [2:3000:3].</p>
</dd></dl>

<dl class="method">
<dt id="tables.Row.__setitem__">
<tt class="descclassname">Row.</tt><tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Row.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the key row field to the specified value.</p>
<p>Differently from its __getitem__()
counterpart, in this case key can only be a
string (the name of the field). The changes done via
__setitem__() will not take effect on the
data on disk until any of the <a class="reference internal" href="#tables.Row.append" title="tables.Row.append"><tt class="xref py py-meth docutils literal"><span class="pre">Row.append()</span></tt></a> or
<a class="reference internal" href="#tables.Row.update" title="tables.Row.update"><tt class="xref py py-meth docutils literal"><span class="pre">Row.update()</span></tt></a> methods are called.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">nrow</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>which modifies every tenth row in the table.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-cols-class">
<span id="colsclassdescr"></span><h3>The Cols class<a class="headerlink" href="#the-cols-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Cols">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Cols</tt><a class="headerlink" href="#tables.Cols" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for columns in a table or nested column.</p>
<p>This class is used as an <em>accessor</em> to the
columns in a table or nested column.  It supports the
<em>natural naming</em> convention, so that you can
access the different columns as attributes which lead to
Column instances (for non-nested columns) or
other Cols instances (for nested columns).</p>
<p>For instance, if table.cols is a
Cols instance with a column named
col1 under it, the later can be accessed as
table.cols.col1. If col1 is
nested and contains a col2 column, this can be
accessed as table.cols.col1.col2 and so
on. Because of natural naming, the names of members start with
special prefixes, like in the Group class (see
<a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
<p>Like the Column class (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>),
Cols supports item access to read and write
ranges of values in the table or nested column.</p>
</dd></dl>

<div class="section" id="cols-instance-variables">
<h4>Cols instance variables<a class="headerlink" href="#cols-instance-variables" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="tables.Cols._v_colnames">
<tt class="descclassname">Cols.</tt><tt class="descname">_v_colnames</tt><a class="headerlink" href="#tables.Cols._v_colnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the names of the columns hanging directly
from the associated table or nested column.  The order of
the names matches the order of their respective columns in
the containing table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Cols._v_colpathnames">
<tt class="descclassname">Cols.</tt><tt class="descname">_v_colpathnames</tt><a class="headerlink" href="#tables.Cols._v_colpathnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the pathnames of all the columns under the
associated table or nested column (in preorder).  If it does
not contain nested columns, this is exactly the same as the
<a class="reference internal" href="#tables.Cols._v_colnames" title="tables.Cols._v_colnames"><tt class="xref py py-attr docutils literal"><span class="pre">Cols._v_colnames</span></tt></a> attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Cols._v_desc">
<tt class="descclassname">Cols.</tt><tt class="descname">_v_desc</tt><a class="headerlink" href="#tables.Cols._v_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated Description instance
(see <a class="reference internal" href="#descriptionclassdescr"><em>The Description class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Cols._v_table">
<tt class="descclassname">Cols.</tt><tt class="descname">_v_table</tt><a class="headerlink" href="#tables.Cols._v_table" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent Table instance (see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>).</p>
</dd></dl>

</div>
<div class="section" id="cols-methods">
<h4>Cols methods<a class="headerlink" href="#cols-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Cols._f_col">
<tt class="descclassname">Cols.</tt><tt class="descname">_f_col</tt><big>(</big><em>colname</em><big>)</big><a class="headerlink" href="#tables.Cols._f_col" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an accessor to the column colname.</p>
<p>This method returns a Column instance
(see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) if the requested column is not nested, and a
Cols instance (see <a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>) if it is.
You may use full column pathnames in colname.</p>
<p>Calling cols._f_col(&#8216;col1/col2&#8217;) is
equivalent to using cols.col1.col2.  However,
the first syntax is more intended for programmatic use.  It is
also better if you want to access columns with names that are
not valid Python identifiers.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols.__getitem__">
<tt class="descclassname">Cols.</tt><tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Cols.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from a table or nested column.</p>
<p>If key argument is an integer, the
corresponding nested type row is returned as a record of the
current flavor. If key is a slice, the range
of rows determined by it is returned as a record array of the
current flavor.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">record</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="c"># equivalent to table[4]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">Info</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Those statements are equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nrecord</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nrecarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;Info&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here you can see how a mix of natural naming, indexing and
slicing can be used as shorthands for the
<a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols.__len__">
<tt class="descclassname">Cols.</tt><tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Cols.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of top level columns in table.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols.__setitem__">
<tt class="descclassname">Cols.</tt><tt class="descname">__setitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Cols.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row or a range of rows in a table or nested column.</p>
<p>If key argument is an integer, the
corresponding row is set to value. If
key is a slice, the range of rows determined
by it is set to value.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>
<span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">Info</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">recarray</span>
</pre></div>
</div>
<p>Those statements are equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">table</span><span class="o">.</span><span class="n">modifyRows</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">record</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyColumn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">colname</span><span class="o">=</span><span class="s">&#39;Info&#39;</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">recarray</span><span class="p">)</span>
</pre></div>
</div>
<p>Here you can see how a mix of natural naming, indexing and
slicing can be used as shorthands for the
<a class="reference internal" href="#tables.Table.modifyRows" title="tables.Table.modifyRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyRows()</span></tt></a> and
<a class="reference internal" href="#tables.Table.modifyColumn" title="tables.Table.modifyColumn"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyColumn()</span></tt></a> methods.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-column-class">
<span id="columnclassdescr"></span><h3>The Column class<a class="headerlink" href="#the-column-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Column">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Column</tt><a class="headerlink" href="#tables.Column" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for a non-nested column in a table.</p>
<p>Each instance of this class is associated with one
<em>non-nested</em> column of a table. These instances
are mainly used to read and write data from the table columns using
item access (like the Cols class - see <a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>), but there
are a few other associated methods to deal with indexes.</p>
</dd></dl>

<div class="section" id="column-instance-variables">
<h4>Column instance variables<a class="headerlink" href="#column-instance-variables" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="tables.Column.descr">
<tt class="descclassname">Column.</tt><tt class="descname">descr</tt><a class="headerlink" href="#tables.Column.descr" title="Permalink to this definition">¶</a></dt>
<dd><p>The Description (see <a class="reference internal" href="#descriptionclassdescr"><em>The Description class</em></a>) instance of the parent table or nested column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.dtype">
<tt class="descclassname">Column.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#tables.Column.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy dtype that most closely matches this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.index">
<tt class="descclassname">Column.</tt><tt class="descname">index</tt><a class="headerlink" href="#tables.Column.index" title="Permalink to this definition">¶</a></dt>
<dd><p>The Index instance (see <a class="reference internal" href="#indexclassdescr"><em>The Index class</em></a>)
associated with this column (None if the
column is not indexed).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.is_indexed">
<tt class="descclassname">Column.</tt><tt class="descname">is_indexed</tt><a class="headerlink" href="#tables.Column.is_indexed" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the column is indexed, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.maindim">
<tt class="descclassname">Column.</tt><tt class="descname">maindim</tt><a class="headerlink" href="#tables.Column.maindim" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension along which iterators work.</p>
<p>Its value is 0 (i.e. the first dimension).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.name">
<tt class="descclassname">Column.</tt><tt class="descname">name</tt><a class="headerlink" href="#tables.Column.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the associated column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.pathname">
<tt class="descclassname">Column.</tt><tt class="descname">pathname</tt><a class="headerlink" href="#tables.Column.pathname" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete pathname of the associated column (the
same as Column.name if the column is not
inside a nested column).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.shape">
<tt class="descclassname">Column.</tt><tt class="descname">shape</tt><a class="headerlink" href="#tables.Column.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.table">
<tt class="descclassname">Column.</tt><tt class="descname">table</tt><a class="headerlink" href="#tables.Column.table" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent Table instance (see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.type">
<tt class="descclassname">Column.</tt><tt class="descname">type</tt><a class="headerlink" href="#tables.Column.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables type of the column (a string).</p>
</dd></dl>

</div>
<div class="section" id="column-methods">
<h4>Column methods<a class="headerlink" href="#column-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Column.createIndex">
<tt class="descclassname">Column.</tt><tt class="descname">createIndex</tt><big>(</big><em>optlevel=6</em>, <em>kind=&quot;medium&quot;</em>, <em>filters=None</em>, <em>tmp_dir=None</em><big>)</big><a class="headerlink" href="#tables.Column.createIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an index for this column.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>optlevel</strong> : int</p>
<blockquote>
<div><p>The optimization level for building the index.  The
levels ranges from 0 (no optimization) up to 9 (maximum
optimization).  Higher levels of optimization mean better
chances for reducing the entropy of the index at the price
of using more CPU, memory and I/O resources for creating
the index.</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>The kind of the index to be built.  It can take the
&#8216;ultralight&#8217;, &#8216;light&#8217;,
&#8216;medium&#8217; or &#8216;full&#8217;
values.  Lighter kinds (&#8216;ultralight&#8217;
and &#8216;light&#8217;) mean that the index takes
less space on disk, but will perform queries slower.
Heavier kinds (&#8216;medium&#8217;
and &#8216;full&#8217;) mean better chances for
reducing the entropy of the index (increasing the query
speed) at the price of using more disk space as well as
more CPU, memory and I/O resources for creating the index.</p>
<p>Note that selecting a full kind
with an optlevel of 9 (the maximum)
guarantees the creation of an index with zero entropy,
that is, a completely sorted index (CSI) - provided that
the number of rows in the table does not exceed the 2**48
figure (that is more than 100 trillions of rows).  See
<a class="reference internal" href="#tables.Column.createCSIndex" title="tables.Column.createCSIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createCSIndex()</span></tt></a> method for a
more direct way to create a CSI index.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>Specify the Filters instance used
to compress the index.  If None,
default index filters will be used (currently, zlib level
1 with shuffling).</p>
</div></blockquote>
<p><strong>tmp_dir</strong> :</p>
<blockquote class="last">
<div><p>When kind is other
than &#8216;ultralight&#8217;, a temporary file is
created during the index build process.  You can use the
tmp_dir argument to specify the
directory for this temporary file.  The default is to
create it in the same directory as the file containing the
original table.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In some situations it is useful to get a completely
sorted index (CSI).  For those cases, it is best to use
the <a class="reference internal" href="#tables.Column.createCSIndex" title="tables.Column.createCSIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createCSIndex()</span></tt></a> method instead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Column.createCSIndex">
<tt class="descclassname">Column.</tt><tt class="descname">createCSIndex</tt><big>(</big><em>filters=None</em>, <em>tmp_dir=None</em><big>)</big><a class="headerlink" href="#tables.Column.createCSIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a completely sorted index (CSI) for this column.</p>
<p>This method guarantees the creation of an index with zero
entropy, that is, a completely sorted index (CSI) &#8211; provided
that the number of rows in the table does not exceed the 2**48
figure (that is more than 100 trillions of rows).  A CSI index
is needed for some table methods (like
<a class="reference internal" href="#tables.Table.itersorted" title="tables.Table.itersorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.itersorted()</span></tt></a> or
<a class="reference internal" href="#tables.Table.readSorted" title="tables.Table.readSorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readSorted()</span></tt></a>) in order to ensure
completely sorted results.</p>
<p>For the meaning of filters and
tmp_dir arguments see
<a class="reference internal" href="#tables.Column.createIndex" title="tables.Column.createIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createIndex()</span></tt></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is equivalent to
Column.createIndex(optlevel=9, kind=&#8217;full&#8217;, ...).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Column.reIndex">
<tt class="descclassname">Column.</tt><tt class="descname">reIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.reIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the index associated with this column.</p>
<p>This can be useful when you suspect that, for any reason,
the index information is no longer valid and you want to rebuild it.</p>
<p>This method does nothing if the column is not indexed.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.reIndexDirty">
<tt class="descclassname">Column.</tt><tt class="descname">reIndexDirty</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.reIndexDirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the associated index only if it is dirty.</p>
<p>This can be useful when you have set
<a class="reference internal" href="#tables.Table.autoIndex" title="tables.Table.autoIndex"><tt class="xref py py-attr docutils literal"><span class="pre">Table.autoIndex</span></tt></a> to false for the table and you want to update the column&#8217;s
index after an invalidating index operation
(like <a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>).</p>
<p>This method does nothing if the column is not indexed.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.removeIndex">
<tt class="descclassname">Column.</tt><tt class="descname">removeIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.removeIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the index associated with this column.</p>
<p>This method does nothing if the column is not indexed. The
removed index can be created again by calling the
<a class="reference internal" href="#tables.Column.createIndex" title="tables.Column.createIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createIndex()</span></tt></a> method.</p>
</dd></dl>

</div>
<div class="section" id="column-special-methods">
<h4>Column special methods<a class="headerlink" href="#column-special-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Column.__getitem__">
<tt class="descclassname">Column.</tt><tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Column.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from a column.</p>
<p>If key argument is an integer, the
corresponding element in the column is returned as an object of
the current flavor.  If key is a slice, the
range of elements determined by it is returned as an array of
the current flavor.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;Column handlers:&quot;</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_f_col</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols.name[1]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols.name[1:2]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols.name[:]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">name</span><span class="p">[:]</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols._f_col(&#39;name&#39;)[:]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_f_col</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)[:]</span>
</pre></div>
</div>
<p>The output of this for a certain arbitrary table is:</p>
<div class="highlight-python"><pre>Column handlers:
/table.cols.name (Column(), string, idx=None)
/table.cols.lati (Column(), int32, idx=None)
/table.cols.longi (Column(), int32, idx=None)
/table.cols.vector (Column(2,), int32, idx=None)
/table.cols.matrix2D (Column(2, 2), float64, idx=None)
Select table.cols.name[1]--&gt; Particle:     11
Select table.cols.name[1:2]--&gt; ['Particle:     11']
Select table.cols.name[:]--&gt; ['Particle:     10'
 'Particle:     11' 'Particle:     12'
 'Particle:     13' 'Particle:     14']
Select table.cols._f_col('name')[:]--&gt; ['Particle:     10'
 'Particle:     11' 'Particle:     12'
 'Particle:     13' 'Particle:     14']</pre>
</div>
<p>See the <tt class="file docutils literal"><span class="pre">examples/table2.py</span></tt> file for a
more complete example.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.__len__">
<tt class="descclassname">Column.</tt><tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of elements in the column.</p>
<p>This matches the length in rows of the parent table.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.__setitem__">
<tt class="descclassname">Column.</tt><tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Column.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row or a range of rows in a column.</p>
<p>If key argument is an integer, the
corresponding element is set to value.  If
key is a slice, the range of elements
determined by it is set to value.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Modify row 1</span>
<span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">col1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="c"># Modify rows 1 and 3</span>
<span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">col1</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Modify row 1</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyColumns</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">])</span>

<span class="c"># Modify rows 1 and 3</span>
<span class="n">columns</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="n">formats</span><span class="o">=</span><span class="s">&#39;i4&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyColumns</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="the-array-class">
<span id="arrayclassdescr"></span><h2>The Array class<a class="headerlink" href="#the-array-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Array">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Array</tt><a class="headerlink" href="#tables.Array" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents homogeneous datasets in an HDF5 file.</p>
<p>This class provides methods to write or read data to or from array objects
in the file. This class does not allow you neither to enlarge nor compress
the datasets on disk; use the EArray class (see <a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>)
if you want enlargeable dataset support or compression features, or CArray
(see <a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>) if you just want compression.</p>
<p>An interesting property of the Array class is
that it remembers the <em>flavor</em> of the object that
has been saved so that if you saved, for example, a
list, you will get a list during
readings afterwards; if you saved a NumPy array, you will get a NumPy
object, and so forth.</p>
<p>Note that this class inherits all the public attributes and
methods that Leaf (see <a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>) already
provides. However, as Array instances have no
internal I/O buffers, it is not necessary to use the
flush() method they inherit from
Leaf in order to save their internal state to disk.
When a writing method call returns, all the data is already on disk.</p>
</dd></dl>

<div class="section" id="array-instance-variables">
<span id="arrayclassinstancevariables"></span><h3>Array instance variables<a class="headerlink" href="#array-instance-variables" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.Array.atom">
<tt class="descclassname">Array.</tt><tt class="descname">atom</tt><a class="headerlink" href="#tables.Array.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>)
instance representing the <em>type</em> and
<em>shape</em> of the atomic objects to be
saved.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.rowsize">
<tt class="descclassname">Array.</tt><tt class="descname">rowsize</tt><a class="headerlink" href="#tables.Array.rowsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the rows in dimensions orthogonal to
<em>maindim</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.nrow">
<tt class="descclassname">Array.</tt><tt class="descname">nrow</tt><a class="headerlink" href="#tables.Array.nrow" title="Permalink to this definition">¶</a></dt>
<dd><p>On iterators, this is the index of the current row.</p>
</dd></dl>

</div>
<div class="section" id="array-methods">
<h3>Array methods<a class="headerlink" href="#array-methods" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Array.getEnum">
<tt class="descclassname">Array.</tt><tt class="descname">getEnum</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Array.getEnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the enumerated type associated with this array.</p>
<p>If this array is of an enumerated type, the corresponding
Enum instance (see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>) is
returned. If it is not of an enumerated type, a
TypeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Array.iterrows">
<tt class="descclassname">Array.</tt><tt class="descname">iterrows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Array.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This method returns an iterator yielding an object of the
current flavor for each selected row in the array.  The returned
rows are taken from the <em>main dimension</em>.</p>
<p>If a range is not supplied, <em>all the
rows</em> in the array are iterated upon - you can also use
the <a class="reference internal" href="#tables.Array.__iter__" title="tables.Array.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">Array.__iter__()</span></tt></a> special method for that purpose.  If you only want
to iterate over a given <em>range of rows</em> in the
array, you may use the start,
stop and step parameters,
which have the same meaning as in <a class="reference internal" href="#tables.Array.read" title="tables.Array.read"><tt class="xref py py-meth docutils literal"><span class="pre">Array.read()</span></tt></a>.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">arrayInstance</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Array.next">
<tt class="descclassname">Array.</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Array.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next element of the array during an iteration.</p>
<p>The element is returned as an object of the current flavor.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Array.read">
<tt class="descclassname">Array.</tt><tt class="descname">read</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Array.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data in the array as an object of the current flavor.</p>
<p>The start, stop and
step parameters can be used to select only a
<em>range of rows</em> in the array.  Their meanings
are the same as in the built-in range() Python
function, except that negative values of step
are not allowed yet. Moreover, if only start is
specified, then stop will be set to
start+1. If you do not specify neither
start nor stop, then
<em>all the rows</em> in the array are
selected.</p>
</dd></dl>

</div>
<div class="section" id="array-special-methods">
<h3>Array special methods<a class="headerlink" href="#array-special-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods automatically trigger actions when an
Array instance is accessed in a special way
(e.g. array[2:3,...,::2] will be equivalent to a
call to array.__getitem__((slice(2, 3, None), Ellipsis,
slice(None, None, 2)))).</p>
<dl class="method">
<dt id="tables.Array.__getitem__">
<tt class="descclassname">Array.</tt><tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Array.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row, a range of rows or a slice from the array.</p>
<p>The set of tokens allowed for the key is
the same as that for extended slicing in Python (including the
Ellipsis or ... token).  The
result is an object of the current flavor; its shape depends on
the kind of slice used as key and the shape of
the array itself.</p>
<p>Furthermore, NumPy-style fancy indexing, where a list of
indices in a certain axis is specified, is also supported.  Note
that only one list per selection is supported right now.  Finally,
NumPy-style point and boolean selections are supported as well.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">array1</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>                       <span class="c"># simple selection</span>
<span class="n">array2</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                <span class="c"># slice selection</span>
<span class="n">array3</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">:]</span>    <span class="c"># general slice selection</span>
<span class="n">array4</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c"># fancy selection</span>
<span class="n">array5</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">array</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)]</span>  <span class="c"># point selection</span>
<span class="n">array6</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">array</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span>            <span class="c"># boolean selection</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Array.__iter__">
<tt class="descclassname">Array.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Array.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This is equivalent to calling
<a class="reference internal" href="#tables.Array.iterrows" title="tables.Array.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">Array.iterrows()</span></tt></a> with default arguments, i.e. it
iterates over <em>all the rows</em> in the array.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">array</span><span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Array.__setitem__">
<tt class="descclassname">Array.</tt><tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Array.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row, a range of rows or a slice in the array.</p>
<p>It takes different actions depending on the type of the
key parameter: if it is an integer, the
corresponding array row is set to value (the
value is broadcast when needed).  If key is a
slice, the row slice determined by it is set to
value (as usual, if the slice to be updated
exceeds the actual shape of the array, only the values in the
existing range are updated).</p>
<p>If value is a multidimensional object,
then its shape must be compatible with the shape determined by
key, otherwise, a ValueError
will be raised.</p>
<p>Furthermore, NumPy-style fancy indexing, where a list of
indices in a certain axis is specified, is also supported.  Note
that only one list per selection is supported right now.  Finally,
NumPy-style point and boolean selections are supported as well.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">333</span>        <span class="c"># assign an integer to a Integer Array row</span>
<span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>        <span class="c"># assign a string to a string Array row</span>
<span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>        <span class="c"># broadcast 5 to slice 1:4</span>
<span class="n">a4</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;xXx&#39;</span>  <span class="c"># broadcast &#39;xXx&#39; to slice 1:4:2</span>

<span class="c"># General slice update (a5.shape = (4,3,2,8,5,10).</span>
<span class="n">a5</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1728</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">a6</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>    <span class="c"># fancy selection</span>
<span class="n">a7</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a6</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">4</span>       <span class="c"># point selection + broadcast</span>
<span class="n">a8</span><span class="p">[</span><span class="n">arr</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr2</span>                <span class="c"># boolean selection</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="the-carray-class">
<span id="carrayclassdescr"></span><h2>The CArray class<a class="headerlink" href="#the-carray-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.CArray">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">CArray</tt><a class="headerlink" href="#tables.CArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents homogeneous datasets in an HDF5 file.</p>
<p>The difference between a CArray and a normal Array (see
<a class="reference internal" href="#arrayclassdescr"><em>The Array class</em></a>), from which it inherits, is that a CArray has a
chunked layout and, as a consequence, it supports compression.
You can use datasets of this class to easily save or load arrays to or
from disk, with compression support included.</p>
</dd></dl>

<div class="section" id="examples-of-use">
<h3>Examples of use<a class="headerlink" href="#examples-of-use" title="Permalink to this headline">¶</a></h3>
<p>See below a small example of the use of the
CArray class.  The code is available in
<tt class="file docutils literal"><span class="pre">examples/carray1.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">tables</span>

<span class="n">fileName</span> <span class="o">=</span> <span class="s">&#39;carray1.h5&#39;</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="n">atom</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">UInt8Atom</span><span class="p">()</span>
<span class="n">filters</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">Filters</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s">&#39;zlib&#39;</span><span class="p">)</span>

<span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">h5f</span><span class="o">.</span><span class="n">createCArray</span><span class="p">(</span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;carray&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>

<span class="c"># Fill a hyperslab in ``ca``.</span>
<span class="n">ca</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">20</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c"># Re-open and read another hyperslab</span>
<span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
<span class="k">print</span> <span class="n">h5f</span>
<span class="k">print</span> <span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">carray</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">:</span><span class="mi">22</span><span class="p">]</span>
<span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The output for the previous script is something like:</p>
<div class="highlight-python"><pre>carray1.h5 (File) ''
Last modif.: 'Thu Apr 12 10:15:38 2007'
Object Tree:
/ (RootGroup) ''
/carray (CArray(200, 300), shuffle, zlib(5)) ''
[[0 0 0 0]
[0 0 0 0]
[0 0 1 1]
[0 0 1 1]]</pre>
</div>
</div>
</div>
<div class="section" id="the-earray-class">
<span id="earrayclassdescr"></span><h2>The EArray class<a class="headerlink" href="#the-earray-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.EArray">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">EArray</tt><a class="headerlink" href="#tables.EArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents extendable, homogeneous datasets in an HDF5 file.</p>
<p>The main difference between an EArray and a CArray (see
<a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>), from which it inherits, is that the former can
be enlarged along one of its dimensions, the <em>enlargeable dimension</em>.
That means that the <a class="reference internal" href="#tables.Leaf.extdim" title="tables.Leaf.extdim"><tt class="xref py py-attr docutils literal"><span class="pre">Leaf.extdim</span></tt></a> attribute (see
<a class="reference internal" href="#leafinstancevariables"><em>Leaf instance variables</em></a>) of any EArray instance will always be
non-negative.
Multiple enlargeable dimensions might be supported in the future.</p>
<p>New rows can be added to the end of an enlargeable array by using the
<a class="reference internal" href="#tables.EArray.append" title="tables.EArray.append"><tt class="xref py py-meth docutils literal"><span class="pre">EArray.append()</span></tt></a> method.</p>
</dd></dl>

<div class="section" id="earray-methods">
<span id="earraymethodsdescr"></span><h3>EArray methods<a class="headerlink" href="#earray-methods" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.EArray.append">
<tt class="descclassname">EArray.</tt><tt class="descname">append</tt><big>(</big><em>sequence</em><big>)</big><a class="headerlink" href="#tables.EArray.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a sequence of data to the end of the dataset.</p>
<p>The sequence must have the same type as the array; otherwise
a TypeError is raised. In the same way, the
dimensions of the sequence must conform to the
shape of the array, that is, all dimensions must match, with the
exception of the enlargeable dimension, which can be of any length
(even 0!).  If the shape of the sequence is
invalid, a ValueError is raised.</p>
</dd></dl>

</div>
<div class="section" id="id2">
<h3>Examples of use<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>See below a small example of the use of the
EArray class.  The code is available in
<tt class="file docutils literal"><span class="pre">examples/earray1.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">tables</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">fileh</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;earray1.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">StringAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c"># Use &#39;&#39;a&#39;&#39; as the object type for the enlargeable array.</span>
<span class="n">array_c</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createEArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;array_c&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s">&quot;Chars&quot;</span><span class="p">)</span>
<span class="n">array_c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="o">*</span><span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;S8&#39;</span><span class="p">))</span>
<span class="n">array_c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="o">*</span><span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;S8&#39;</span><span class="p">))</span>

<span class="c"># Read the string &#39;&#39;EArray&#39;&#39; we have created on disk.</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">array_c</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;array_c[</span><span class="si">%s</span><span class="s">] =&gt; </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">array_c</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="c"># Close the file.</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The output for the previous script is something like:</p>
<div class="highlight-python"><pre>array_c[0] =&gt; 'aa'
array_c[1] =&gt; 'bbbb'
array_c[2] =&gt; 'aaaaaa'
array_c[3] =&gt; 'bbbbbbbb'
array_c[4] =&gt; 'cccccccc'</pre>
</div>
</div>
</div>
<div class="section" id="the-vlarray-class">
<span id="vlarrayclassdescr"></span><h2>The VLArray class<a class="headerlink" href="#the-vlarray-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.VLArray">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">VLArray</tt><a class="headerlink" href="#tables.VLArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents variable length (ragged) arrays in an HDF5 file.</p>
<p>Instances of this class represent array objects in the object
tree with the property that their rows can have a
<em>variable</em> number of homogeneous elements, called
<em>atoms</em>. Like Table datasets (see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>),
variable length arrays can have only one dimension, and the elements
(atoms) of their rows can be fully multidimensional.
VLArray objects do also support compression.</p>
<p>When reading a range of rows from a VLArray,
you will <em>always</em> get a Python list of objects of
the current flavor (each of them for a row), which may have different
lengths.</p>
<p>This class provides methods to write or read data to or from
variable length array objects in the file. Note that it also inherits
all the public attributes and methods that Leaf
(see <a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>)
already provides.</p>
</dd></dl>

<div class="section" id="vlarray-instance-variables">
<h3>VLArray instance variables<a class="headerlink" href="#vlarray-instance-variables" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.VLArray.atom">
<tt class="descclassname">VLArray.</tt><tt class="descname">atom</tt><a class="headerlink" href="#tables.VLArray.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>)
instance representing the <em>type</em> and
<em>shape</em> of the atomic objects to be
saved. You may use a <em>pseudo-atom</em> for
storing a serialized object or variable length string per row.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.flavor">
<tt class="descclassname">VLArray.</tt><tt class="descname">flavor</tt><a class="headerlink" href="#tables.VLArray.flavor" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of data object read from this leaf.</p>
<p>Please note that when reading several rows of
VLArray data, the flavor only applies to
the <em>components</em> of the returned Python
list, not to the list itself.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.nrow">
<tt class="descclassname">VLArray.</tt><tt class="descname">nrow</tt><a class="headerlink" href="#tables.VLArray.nrow" title="Permalink to this definition">¶</a></dt>
<dd><p>On iterators, this is the index of the current row.</p>
</dd></dl>

</div>
<div class="section" id="vlarray-methods">
<h3>VLArray methods<a class="headerlink" href="#vlarray-methods" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.VLArray.append">
<tt class="descclassname">VLArray.</tt><tt class="descname">append</tt><big>(</big><em>sequence</em><big>)</big><a class="headerlink" href="#tables.VLArray.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a sequence of data to the end of the dataset.</p>
<p>This method appends the objects in the
sequence to a <em>single row</em>
in this array. The type and shape of individual objects must be
compliant with the atoms in the array. In the case of serialized
objects and variable length strings, the object or string to
append is itself the sequence.</p>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.getEnum">
<tt class="descclassname">VLArray.</tt><tt class="descname">getEnum</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.VLArray.getEnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the enumerated type associated with this array.</p>
<p>If this array is of an enumerated type, the corresponding
Enum instance (see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>) is
returned. If it is not of an enumerated type, a
TypeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.iterrows">
<tt class="descclassname">VLArray.</tt><tt class="descname">iterrows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.VLArray.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This method returns an iterator yielding an object of the
current flavor for each selected row in the array.</p>
<p>If a range is not supplied, <em>all the
rows</em> in the array are iterated upon —you can also use
the <a class="reference internal" href="#tables.VLArray.__iter__" title="tables.VLArray.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.__iter__()</span></tt></a> special method for that purpose.
If you only want to iterate over a given <em>range of
rows</em> in the array, you may use the
start, stop and
step parameters, which have the same meaning as
in <a class="reference internal" href="#tables.VLArray.read" title="tables.VLArray.read"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.read()</span></tt></a>.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%d</span><span class="s">]--&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vlarray</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.next">
<tt class="descclassname">VLArray.</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.VLArray.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next element of the array during an iteration.</p>
<p>The element is returned as a list of objects of the current flavor.</p>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.read">
<tt class="descclassname">VLArray.</tt><tt class="descname">read</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em><big>)</big><a class="headerlink" href="#tables.VLArray.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data in the array as a list of objects of the current flavor.</p>
<p>Please note that, as the lengths of the different rows are
variable, the returned value is a <em>Python list</em>
(not an array of the current flavor), with as many entries as
specified rows in the range parameters.</p>
<p>The start, stop and
step parameters can be used to select only a
<em>range of rows</em> in the array.  Their meanings
are the same as in the built-in range() Python
function, except that negative values of step
are not allowed yet. Moreover, if only start is
specified, then stop will be set to
start+1. If you do not specify neither
start nor stop, then
<em>all the rows</em> in the array are
selected.</p>
</dd></dl>

</div>
<div class="section" id="vlarray-special-methods">
<h3>VLArray special methods<a class="headerlink" href="#vlarray-special-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods automatically trigger actions when a
VLArray instance is accessed in a special way
(e.g., vlarray[2:5] will be equivalent to a call
to vlarray.__getitem__(slice(2, 5, None)).</p>
<dl class="method">
<dt id="tables.VLArray.__getitem__">
<tt class="descclassname">VLArray.</tt><tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.VLArray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from the array.</p>
<p>If key argument is an integer, the
corresponding array row is returned as an object of the current
flavor.  If key is a slice, the range of rows
determined by it is returned as a list of objects of the current
flavor.</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row
coordinates, the set of rows determined by it is returned.
Furthermore, if key is an array of boolean
values, only the coordinates where key
is True are returned.  Note that for the latter
to work it is necessary that key list would
contain exactly as many rows as the array has.</p>
<p>Example of use::</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a_row</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">a_list</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">a_list2</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>   <span class="c"># get list of coords</span>
<span class="n">a_list3</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>  <span class="c"># negative values accepted</span>
<span class="n">a_list4</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="bp">False</span><span class="p">])]</span>  <span class="c"># array of bools</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.__iter__">
<tt class="descclassname">VLArray.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.VLArray.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This is equivalent to calling
<a class="reference internal" href="#tables.VLArray.iterrows" title="tables.VLArray.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.iterrows()</span></tt></a> with default arguments, i.e. it
iterates over <em>all the rows</em> in the array.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.__setitem__">
<tt class="descclassname">VLArray.</tt><tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.VLArray.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row, or set of rows, in the array.</p>
<p>It takes different actions depending on the type of the
key parameter: if it is an integer, the
corresponding table row is set to value (a
record or sequence capable of being converted to the table
structure). If key is a slice, the row slice
determined by it is set to value (a record
array or sequence capable of being converted to the table
structure).</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row
coordinates, the set of rows determined by it is set
to value.  Furthermore,
if key is an array of boolean values, only the
coordinates where key
is True are set to values
from value.  Note that for the latter to work
it is necessary that key list would contain
exactly as many rows as the table has.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When updating the rows of a VLArray
object which uses a pseudo-atom, there is a problem: you can
only update values with <em>exactly</em> the same
size in bytes than the original row.  This is very difficult to
meet with object pseudo-atoms, because
cPickle applied on a Python object does not
guarantee to return the same number of bytes than over another
object, even if they are of the same class.  This effectively
limits the kinds of objects than can be updated in
variable-length arrays.</p>
</div>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vlarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">vlarray</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">96</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>

<span class="c"># Negative values for the index are supported.</span>
<span class="n">vlarray</span><span class="p">[</span><span class="o">-</span><span class="mi">99</span><span class="p">]</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">vlarray</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_of_rows</span>
<span class="n">vlarray</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_1_and_3_rows</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id3">
<h3>Examples of use<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>See below a small example of the use of the
VLArray class.  The code is available in
<tt class="file docutils literal"><span class="pre">examples/vlarray1.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">tables</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Create a VLArray:</span>
<span class="n">fileh</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;vlarray1.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">vlarray</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createVLArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;vlarray1&#39;</span><span class="p">,</span>
<span class="n">tables</span><span class="o">.</span><span class="n">Int32Atom</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">()),</span>
                <span class="s">&quot;ragged array of ints&quot;</span><span class="p">,</span>
                <span class="n">filters</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">Filters</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c"># Append some (variable length) rows:</span>
<span class="n">vlarray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="n">vlarray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="n">vlarray</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>

<span class="c"># Now, read it through an iterator:</span>
<span class="k">print</span> <span class="s">&#39;--&gt;&#39;</span><span class="p">,</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">title</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%d</span><span class="s">]--&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vlarray</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c"># Now, do the same with native Python strings.</span>
<span class="n">vlarray2</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createVLArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;vlarray2&#39;</span><span class="p">,</span>
<span class="n">tables</span><span class="o">.</span><span class="n">StringAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                    <span class="s">&quot;ragged array of strings&quot;</span><span class="p">,</span>
                    <span class="n">filters</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">Filters</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">flavor</span> <span class="o">=</span> <span class="s">&#39;python&#39;</span>

<span class="c"># Append some (variable length) rows:</span>
<span class="k">print</span> <span class="s">&#39;--&gt;&#39;</span><span class="p">,</span> <span class="n">vlarray2</span><span class="o">.</span><span class="n">title</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s">&#39;5&#39;</span><span class="p">,</span> <span class="s">&#39;66&#39;</span><span class="p">])</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s">&#39;5&#39;</span><span class="p">,</span> <span class="s">&#39;6&#39;</span><span class="p">,</span> <span class="s">&#39;77&#39;</span><span class="p">])</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s">&#39;5&#39;</span><span class="p">,</span> <span class="s">&#39;6&#39;</span><span class="p">,</span> <span class="s">&#39;9&#39;</span><span class="p">,</span> <span class="s">&#39;88&#39;</span><span class="p">])</span>

<span class="c"># Now, read it through an iterator:</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vlarray2</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%d</span><span class="s">]--&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vlarray2</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vlarray2</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c"># Close the file.</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The output for the previous script is something like:</p>
<div class="highlight-python"><pre>--&gt; ragged array of ints
vlarray1[0]--&gt; [5 6]
vlarray1[1]--&gt; [5 6 7]
vlarray1[2]--&gt; [5 6 9 8]
--&gt; ragged array of strings
vlarray2[0]--&gt; ['5', '66']
vlarray2[1]--&gt; ['5', '6', '77']
vlarray2[2]--&gt; ['5', '6', '9', '88']</pre>
</div>
</div>
</div>
<div class="section" id="the-link-class">
<h2>The Link class<a class="headerlink" href="#the-link-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Link">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Link</tt><a class="headerlink" href="#tables.Link" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for all PyTables links.</p>
<p>A link is a node that refers to another node.
The Link class inherits
from Node class and the links that inherits
from Link are SoftLink
and ExternalLink.  There is not
a HardLink subclass because hard links behave
like a regular Group or Leaf.
Contrarily to other nodes, links cannot have HDF5 attributes.  This
is an HDF5 library limitation that might be solved in future
releases.</p>
<p>See <a class="reference internal" href="tutorials.html#linkstutorial"><em>Using links for more convenient access to nodes</em></a> for a small tutorial on how
to work with links.</p>
</dd></dl>

<div class="section" id="link-instance-variables">
<h3>Link instance variables<a class="headerlink" href="#link-instance-variables" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.Link._v_attrs">
<tt class="descclassname">Link.</tt><tt class="descname">_v_attrs</tt><a class="headerlink" href="#tables.Link._v_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>A NoAttrs instance replacing the
typical <em>AttributeSet</em> instance of other
node objects.  The purpose of NoAttrs is
to make clear that HDF5 attributes are not supported in link
nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Link.target">
<tt class="descclassname">Link.</tt><tt class="descname">target</tt><a class="headerlink" href="#tables.Link.target" title="Permalink to this definition">¶</a></dt>
<dd><p>The path string to the pointed node.</p>
</dd></dl>

</div>
<div class="section" id="link-methods">
<h3>Link methods<a class="headerlink" href="#link-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods are useful for copying, moving, renaming
and removing links.</p>
<dl class="method">
<dt id="tables.Link.copy">
<tt class="descclassname">Link.</tt><tt class="descname">copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.Link.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this link and return the new one.</p>
<p>See <a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a> for a complete explanation of
the arguments.  Please note that there is no
recursive flag since links do not have child nodes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Link.move">
<tt class="descclassname">Link.</tt><tt class="descname">move</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#tables.Link.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move or rename this link.</p>
<p>See <a class="reference internal" href="#tables.Node._f_move" title="tables.Node._f_move"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_move()</span></tt></a> for a complete explanation of the arguments.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Link.remove">
<tt class="descclassname">Link.</tt><tt class="descname">remove</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Link.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this link from the hierarchy.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Link.rename">
<tt class="descclassname">Link.</tt><tt class="descname">rename</tt><big>(</big><em>newname=None</em><big>)</big><a class="headerlink" href="#tables.Link.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this link in place.</p>
<p>See <a class="reference internal" href="#tables.Node._f_rename" title="tables.Node._f_rename"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_rename()</span></tt></a> for a complete explanation of the arguments.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-softlink-class">
<span id="softlinkclassdescr"></span><h2>The SoftLink class<a class="headerlink" href="#the-softlink-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.SoftLink">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">SoftLink</tt><a class="headerlink" href="#tables.SoftLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a soft link (aka symbolic link).</p>
<p>A soft link is a reference to another node in
the <em>same</em> file hierarchy.  Getting access to the
pointed node (this action is
called <em>dereferrencing</em>) is done via
the __call__ special method (see below).</p>
</dd></dl>

<div class="section" id="softlink-special-methods">
<h3>SoftLink special methods<a class="headerlink" href="#softlink-special-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods are specific for dereferrencing and
representing soft links.</p>
<dl class="method">
<dt id="tables.SoftLink.__call__">
<tt class="descclassname">SoftLink.</tt><tt class="descname">__call__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.SoftLink.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dereference self.target and return the
pointed object.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link0</span>
<span class="go">/link0 (SoftLink) -&gt; /another/path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link0</span><span class="p">()</span>
<span class="go">/another/path (Group) &#39;&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.SoftLink.__str__">
<tt class="descclassname">SoftLink.</tt><tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.SoftLink.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the link.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link0</span>
<span class="go">/link0 (SoftLink) -&gt; /path/to/node</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="the-externallink-class">
<span id="externallinkclassdescr"></span><h2>The ExternalLink class<a class="headerlink" href="#the-externallink-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.ExternalLink">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">ExternalLink</tt><a class="headerlink" href="#tables.ExternalLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an external link.</p>
<p>An external link is a reference to a node
in <em>another</em> file.  Getting access to the pointed
node (this action is called <em>dereferrencing</em>) is
done via the __call__ special method (see
below).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">External links are only supported when PyTables is compiled
against HDF5 1.8.x series.  When using PyTables with HDF5 1.6.x,
the <em>parent</em> group containing external link
objects will be mapped to an Unknown instance
(see <a class="reference internal" href="#unknownclassdescr"><em>The Unknown class</em></a>) and you won&#8217;t be able to access <em>any</em> node
hanging of this parent group.  It follows that if the parent group
containing the external link is the root group, you won&#8217;t be able
to read <em>any</em> information contained in the file
when using HDF5 1.6.x.</p>
</div>
</dd></dl>

<div class="section" id="externallink-instance-variables">
<h3>ExternalLink instance variables<a class="headerlink" href="#externallink-instance-variables" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.ExternalLink.extfile">
<tt class="descclassname">ExternalLink.</tt><tt class="descname">extfile</tt><a class="headerlink" href="#tables.ExternalLink.extfile" title="Permalink to this definition">¶</a></dt>
<dd><p>The external file handler, if the link has been
dereferenced.  In case the link has not been dereferenced
yet, its value is None.</p>
</dd></dl>

</div>
<div class="section" id="externallink-methods">
<h3>ExternalLink methods<a class="headerlink" href="#externallink-methods" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.ExternalLink.umount">
<tt class="descclassname">ExternalLink.</tt><tt class="descname">umount</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.ExternalLink.umount" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely unmount self.extfile, if opened.</p>
</dd></dl>

</div>
<div class="section" id="externallink-special-methods">
<h3>ExternalLink special methods<a class="headerlink" href="#externallink-special-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods are specific for dereferrencing and
representing external links.</p>
<dl class="method">
<dt id="tables.ExternalLink.__call__">
<tt class="descclassname">ExternalLink.</tt><tt class="descname">__call__</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.ExternalLink.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dereference self.target and return the
pointed object.</p>
<p>You can pass all the arguments supported by the
<a class="reference internal" href="#tables.openFile" title="tables.openFile"><tt class="xref py py-func docutils literal"><span class="pre">openFile()</span></tt></a> function
(except filename, of course) so as to open
the referenced external file.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data1/test1.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link2</span>
<span class="go">/link2 (ExternalLink) -&gt; data2/test2.h5:/path/to/node</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plink2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link2</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>  <span class="c"># open in &#39;a&#39;ppend mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">plink2</span>
<span class="go">/path/to/node (Group) &#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">plink2</span><span class="o">.</span><span class="n">_v_filename</span>
<span class="go">&#39;data2/test2.h5&#39;        # belongs to referenced file</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.ExternalLink.__str__">
<tt class="descclassname">ExternalLink.</tt><tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.ExternalLink.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the link.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data1/test1.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link2</span>
<span class="go">/link2 (ExternalLink) -&gt; data2/test2.h5:/path/to/node</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="the-unimplemented-class">
<span id="unimplementedclassdescr"></span><h2>The UnImplemented class<a class="headerlink" href="#the-unimplemented-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.UnImplemented">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UnImplemented</tt><a class="headerlink" href="#tables.UnImplemented" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents datasets not supported by PyTables in an
HDF5 file.</p>
<p>When reading a generic HDF5 file (i.e. one that has not been
created with PyTables, but with some other HDF5 library based tool),
chances are that the specific combination of datatypes or dataspaces
in some dataset might not be supported by PyTables yet. In such a
case, this dataset will be mapped into an
UnImplemented instance and the user will still be
able to access the complete object tree of the generic HDF5 file. The
user will also be able to <em>read and write the
attributes</em> of the dataset, <em>access some of its
metadata</em>, and perform <em>certain hierarchy
manipulation operations</em> like deleting or moving (but not
copying) the node. Of course, the user will not be able to read the
actual data on it.</p>
<p>This is an elegant way to allow users to work with generic HDF5
files despite the fact that some of its datasets are not supported by
PyTables. However, if you are really interested in having full access
to an unimplemented dataset, please get in contact with the developer
team.</p>
<p>This class does not have any public instance variables or
methods, except those inherited from the Leaf class
(see <a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>).</p>
</dd></dl>

</div>
<div class="section" id="the-unknown-class">
<span id="unknownclassdescr"></span><h2>The Unknown class<a class="headerlink" href="#the-unknown-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Unknown">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Unknown</tt><a class="headerlink" href="#tables.Unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents nodes reported
as <em>unknown</em> by the underlying HDF5 library.</p>
<p>This class does not have any public instance variables or
methods, except those inherited from the Node class.</p>
</dd></dl>

</div>
<div class="section" id="the-attributeset-class">
<span id="attributesetclassdescr"></span><h2>The AttributeSet class<a class="headerlink" href="#the-attributeset-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.AttributeSet">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">AttributeSet</tt><a class="headerlink" href="#tables.AttributeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for the HDF5 attributes of a Node
(see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>).</p>
<p>This class provides methods to create new HDF5 node attributes,
and to get, rename or delete existing ones.</p>
<p>Like in Group instances (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>),
AttributeSet instances make use of the
<em>natural naming</em> convention, i.e. you can access
the attributes on disk as if they were normal Python attributes of the
AttributeSet instance.</p>
<p>This offers the user a very convenient way to access HDF5 node
attributes. However, for this reason and in order not to pollute the
object namespace, one can not assign <em>normal</em>
attributes to AttributeSet instances, and their
members use names which start by special prefixes as happens with
Group objects.</p>
</dd></dl>

<div class="section" id="notes-on-native-and-pickled-attributes">
<h3>Notes on native and pickled attributes<a class="headerlink" href="#notes-on-native-and-pickled-attributes" title="Permalink to this headline">¶</a></h3>
<p>The values of most basic types are saved as HDF5 native data
in the HDF5 file.  This includes Python bool,
int, float,
complex and str (but not
long nor unicode) values, as
well as their NumPy scalar versions and homogeneous or
<em>structured</em> NumPy arrays of them.  When read,
these values are always loaded as NumPy scalar or array objects, as
needed.</p>
<p>For that reason, attributes in native HDF5 files will be
always mapped into NumPy objects.  Specifically, a multidimensional
attribute will be mapped into a multidimensional
ndarray and a scalar will be mapped into a NumPy
scalar object (for example, a scalar
H5T_NATIVE_LLONG will be read and returned as a
numpy.int64 scalar).</p>
<p>However, other kinds of values are serialized using
cPickle, so you only will be able to correctly
retrieve them using a Python-aware HDF5 library.  Thus, if you want
to save Python scalar values and make sure you are able to read them
with generic HDF5 tools, you should make use of <em>scalar or
homogeneous/structured array NumPy objects</em> (for example,
numpy.int64(1) or numpy.array([1, 2, 3],
dtype=&#8217;int16&#8217;)).</p>
<p>One more advice: because of the various potential difficulties
in restoring a Python object stored in an attribute, you may end up
getting a cPickle string where a Python object is
expected. If this is the case, you may wish to run
cPickle.loads() on that string to get an idea of
where things went wrong, as shown in this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tables</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>  <span class="n">foo</span> <span class="o">=</span> <span class="s">&#39;bar&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myObject</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>  <span class="c"># save object of custom class in HDF5 attr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5fname</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s">&#39;.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">h5fname</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">myObject</span>  <span class="c"># store the object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>  <span class="c"># retrieve it</span>
<span class="go">bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">MyClass</span><span class="p">,</span> <span class="n">myObject</span>  <span class="c"># delete class of object and reopen file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">h5fname</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="go">&#39;ccopy_reg\\n_reconstructor...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cPickle</span>  <span class="c"># let&#39;s unpickle that to see what went wrong</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cPickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;module&#39; object has no attribute &#39;MyClass&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># So the problem was not in the stored object,</span>
<span class="gp">... </span><span class="c"># but in the *environment* where it was restored.</span>
<span class="gp">... </span><span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">h5fname</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="attributeset-instance-variables">
<h3>AttributeSet instance variables<a class="headerlink" href="#attributeset-instance-variables" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.AttributeSet._v_attrnames">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_v_attrnames</tt><a class="headerlink" href="#tables.AttributeSet._v_attrnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list with all attribute names.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.AttributeSet._v_attrnamessys">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_v_attrnamessys</tt><a class="headerlink" href="#tables.AttributeSet._v_attrnamessys" title="Permalink to this definition">¶</a></dt>
<dd><p>A list with system attribute names.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.AttributeSet._v_attrnamesuser">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_v_attrnamesuser</tt><a class="headerlink" href="#tables.AttributeSet._v_attrnamesuser" title="Permalink to this definition">¶</a></dt>
<dd><p>A list with user attribute names.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.AttributeSet._v_node">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_v_node</tt><a class="headerlink" href="#tables.AttributeSet._v_node" title="Permalink to this definition">¶</a></dt>
<dd><p>The Node instance (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) this
attribute set is associated with.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.AttributeSet._v_unimplemented">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_v_unimplemented</tt><a class="headerlink" href="#tables.AttributeSet._v_unimplemented" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of attribute names with unimplemented native HDF5 types.</p>
</dd></dl>

</div>
<div class="section" id="attributeset-methods">
<h3>AttributeSet methods<a class="headerlink" href="#attributeset-methods" title="Permalink to this headline">¶</a></h3>
<p>Note that this class overrides the
__getattr__(), __setattr__()
and __delattr__() special methods.  This allows
you to read, assign or delete attributes on disk by just using the
next constructs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr</span> <span class="o">=</span> <span class="s">&#39;str attr&#39;</span>    <span class="c"># set a string (native support)</span>
<span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr2</span> <span class="o">=</span> <span class="mi">3</span>            <span class="c"># set an integer (native support)</span>
<span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>  <span class="c"># a generic object (Pickled)</span>
<span class="n">attrib</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr</span>        <span class="c"># get the attribute ``myattr``</span>
<span class="k">del</span> <span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr</span>             <span class="c"># delete the attribute ``myattr``</span>
</pre></div>
</div>
<p>In addition, the dictionary-like
__getitem__(), __setitem__()
and __delitem__() methods are available, so you
may write things like this:</p>
<div class="highlight-python"><pre>for name in :attr:`Node._v_attrs`._f_list():
    print "name: %s, value: %s" % (name, :attr:`Node._v_attrs`[name])</pre>
</div>
<p>Use whatever idiom you prefer to access the attributes.</p>
<p>If an attribute is set on a target node that already has a
large number of attributes, a PerformanceWarning
will be issued.</p>
<dl class="method">
<dt id="tables.AttributeSet._f_copy">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_f_copy</tt><big>(</big><em>where</em><big>)</big><a class="headerlink" href="#tables.AttributeSet._f_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy attributes to the where node.</p>
<p>Copies all user and certain system attributes to the given
where node (a Node instance - see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>),
replacing the existing ones.</p>
</dd></dl>

<dl class="method">
<dt id="tables.AttributeSet._f_list">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_f_list</tt><big>(</big><em>attrset='user'</em><big>)</big><a class="headerlink" href="#tables.AttributeSet._f_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of attribute names.</p>
<p>The attrset string selects the attribute
set to be used.  A &#8216;user&#8217; value returns only
user attributes (this is the default).  A &#8216;sys&#8217;
value returns only system attributes.  Finally,
&#8216;all&#8217; returns both system and user
attributes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.AttributeSet._f_rename">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">_f_rename</tt><big>(</big><em>oldattrname</em>, <em>newattrname</em><big>)</big><a class="headerlink" href="#tables.AttributeSet._f_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename an attribute from oldattrname to newattrname.</p>
</dd></dl>

<dl class="method">
<dt id="tables.AttributeSet.__contains__">
<tt class="descclassname">AttributeSet.</tt><tt class="descname">__contains__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.AttributeSet.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there an attribute with that name?</p>
<p>A true value is returned if the attribute set has an
attribute with the given name, false otherwise.</p>
</dd></dl>

</div>
</div>
<div class="section" id="declarative-classes">
<h2>Declarative classes<a class="headerlink" href="#declarative-classes" title="Permalink to this headline">¶</a></h2>
<p>In this section a series of classes that are meant to
<em>declare</em> datatypes that are required for creating
primary PyTables datasets are described.</p>
<div class="section" id="the-atom-class-and-its-descendants">
<span id="atomclassdescr"></span><h3>The Atom class and its descendants<a class="headerlink" href="#the-atom-class-and-its-descendants" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Atom</tt><a class="headerlink" href="#tables.Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the type of atomic cells stored in a dataset.</p>
<p>The meaning of <em>atomic</em> is that individual
elements of a cell can not be extracted directly by indexing (i.e.
__getitem__()) the dataset; e.g. if a dataset has
shape (2, 2) and its atoms have shape (3,), to get the third element
of the cell at (1, 0) one should use
dataset[1,0][2] instead of dataset[1,0,2].</p>
<p>The Atom class is meant to declare the
different properties of the <em>base element</em> (also
known as <em>atom</em>) of CArray,
EArray and VLArray datasets,
although they are also used to describe the base elements of
Array datasets. Atoms have the property that
their length is always the same.  However, you can grow datasets
along the extensible dimension in the case of
EArray or put a variable number of them on a
VLArray row. Moreover, they are not
restricted to scalar values, and they can be <em>fully
multidimensional objects</em>.</p>
<p>A series of descendant classes are offered in order to make
the use of these element descriptions easier. You should use a
particular Atom descendant class whenever you
know the exact type you will need when writing your code. Otherwise,
you may use one of the Atom.from_*() factory Methods.</p>
</dd></dl>

<div class="section" id="atom-instance-variables">
<h4>Atom instance variables<a class="headerlink" href="#atom-instance-variables" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="tables.Atom.dflt">
<tt class="descclassname">Atom.</tt><tt class="descname">dflt</tt><a class="headerlink" href="#tables.Atom.dflt" title="Permalink to this definition">¶</a></dt>
<dd><p>The default value of the atom.</p>
<p>If the user does not supply a value for an element
while filling a dataset, this default value will be written
to disk. If the user supplies a scalar value for a
multidimensional atom, this value is automatically
<em>broadcast</em> to all the items in the atom
cell. If dflt is not supplied, an
appropriate zero value (or <em>null</em> string)
will be chosen by default.  Please note that default values
are kept internally as NumPy objects.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.dtype">
<tt class="descclassname">Atom.</tt><tt class="descname">dtype</tt><a class="headerlink" href="#tables.Atom.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy dtype that most closely matches this atom.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.itemsize">
<tt class="descclassname">Atom.</tt><tt class="descname">itemsize</tt><a class="headerlink" href="#tables.Atom.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size in bytes of a single item in the atom.</p>
<p>Specially useful for atoms of the string kind.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.kind">
<tt class="descclassname">Atom.</tt><tt class="descname">kind</tt><a class="headerlink" href="#tables.Atom.kind" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables kind of the atom (a string).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.recarrtype">
<tt class="descclassname">Atom.</tt><tt class="descname">recarrtype</tt><a class="headerlink" href="#tables.Atom.recarrtype" title="Permalink to this definition">¶</a></dt>
<dd><p>String type to be used in numpy.rec.array().</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.shape">
<tt class="descclassname">Atom.</tt><tt class="descname">shape</tt><a class="headerlink" href="#tables.Atom.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the atom (a tuple for scalar atoms).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.size">
<tt class="descclassname">Atom.</tt><tt class="descname">size</tt><a class="headerlink" href="#tables.Atom.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total size in bytes of the atom.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.type">
<tt class="descclassname">Atom.</tt><tt class="descname">type</tt><a class="headerlink" href="#tables.Atom.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables type of the atom (a string).</p>
<p>Atoms can be compared with atoms and other objects for
strict (in)equality without having to compare individual
attributes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">=</span> <span class="n">StringAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># same as ``atom2``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># same as ``atom1``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom3</span> <span class="o">=</span> <span class="n">IntAtom</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="s">&#39;foo&#39;</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">!=</span> <span class="n">atom1</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom3</span> <span class="o">!=</span> <span class="n">atom2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="atom-methods">
<h4>Atom methods<a class="headerlink" href="#atom-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Atom.copy">
<tt class="descclassname">Atom.</tt><tt class="descname">copy</tt><big>(</big><em>**override</em><big>)</big><a class="headerlink" href="#tables.Atom.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the atom, possibly overriding some arguments.</p>
<p>Constructor arguments to be overridden must be passed as
keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">=</span> <span class="n">StringAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom1</span>
<span class="go">StringAtom(itemsize=12, shape=(), dflt=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom2</span>
<span class="go">StringAtom(itemsize=12, shape=(), dflt=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="ow">is</span> <span class="n">atom2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom3</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom3</span>
<span class="go">StringAtom(itemsize=100, shape=(2, 2), dflt=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">foobar</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">__init__() got an unexpected keyword argument &#39;foobar&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="atom-factory-methods">
<h4>Atom factory methods<a class="headerlink" href="#atom-factory-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Atom.from_dtype">
<tt class="descclassname">Atom.</tt><tt class="descname">from_dtype</tt><big>(</big><em>dtype</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a NumPy dtype.</p>
<p>An optional default value may be specified as the
dflt argument. Information in the
dtype not represented in an Atom is ignored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;S5&#39;</span><span class="p">),</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">StringAtom(itemsize=5, shape=(), dflt=&#39;hello&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;Float64&#39;</span><span class="p">))</span>
<span class="go">Float64Atom(shape=(), dflt=0.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Atom.from_kind">
<tt class="descclassname">Atom.</tt><tt class="descname">from_kind</tt><big>(</big><em>kind</em>, <em>itemsize=None</em>, <em>shape=()</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a PyTables kind.</p>
<p>Optional item size, shape and default value may be
specified as the itemsize, shape and dflt
arguments, respectively. Bear in mind that not all atoms support
a default item size:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int32Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Int32Atom(shape=(1,), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">StringAtom(itemsize=5, shape=(), dflt=&#39;hello&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">no default item size for kind ``string``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;Float&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown kind</span>: <span class="n">&#39;Float&#39;</span>
</pre></div>
</div>
<p>Moreover, some kinds with atypical constructor signatures
are not supported; you need to use the proper
constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;enum&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the ``enum`` kind is not supported...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Atom.from_sctype">
<tt class="descclassname">Atom.</tt><tt class="descname">from_sctype</tt><big>(</big><em>sctype</em>, <em>shape=()</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_sctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a NumPy scalar type sctype.</p>
<p>Optional shape and default value may be specified as the
shape and dflt
arguments, respectively. Information in the
sctype not represented in an Atom is ignored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_sctype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_sctype</span><span class="p">(</span><span class="s">&#39;S5&#39;</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown NumPy scalar type</span>: <span class="n">&#39;S5&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_sctype</span><span class="p">(</span><span class="s">&#39;Float64&#39;</span><span class="p">)</span>
<span class="go">Float64Atom(shape=(), dflt=0.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Atom.from_type">
<tt class="descclassname">Atom.</tt><tt class="descname">from_type</tt><big>(</big><em>type</em>, <em>shape=()</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a PyTables type.</p>
<p>Optional shape and default value may be specified as the
shape and dflt arguments, respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
<span class="go">BoolAtom(shape=(), dflt=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;int16&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;string40&#39;</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown type</span>: <span class="n">&#39;string40&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;Float64&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown type</span>: <span class="n">&#39;Float64&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="atom-constructors">
<span id="atomconstructors"></span><h4>Atom constructors<a class="headerlink" href="#atom-constructors" title="Permalink to this headline">¶</a></h4>
<p>There are some common arguments for most
Atom-derived constructors:</p>
<dl class="method">
<dt id="tables.Atom.__init__">
<tt class="descclassname">Atom.</tt><tt class="descname">__init__</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#tables.Atom.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>itemsize</strong> : int</p>
<blockquote>
<div><p>For types with a non-fixed size, this sets the size in
bytes of individual items in the atom.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>Sets the shape of the atom. An integer shape of
N is equivalent to the tuple (N,).</p>
</div></blockquote>
<p><strong>dflt</strong> :</p>
<blockquote class="last">
<div><p>Sets the default value for the atom.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>A relation of the different constructors with their
parameters follows.</p>
<dl class="class">
<dt id="tables.StringAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">StringAtom</tt><big>(</big><em>itemsize</em>, <em>shape=()</em>, <em>dflt=''</em><big>)</big><a class="headerlink" href="#tables.StringAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type string.</p>
<p>The item size is the <em>maximum</em> length
in characters of strings.</p>
</dd></dl>

<dl class="class">
<dt id="tables.BoolAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">BoolAtom</tt><big>(</big><em>shape=()</em>, <em>dflt=False</em><big>)</big><a class="headerlink" href="#tables.BoolAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type bool.</p>
</dd></dl>

<dl class="class">
<dt id="tables.IntAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">IntAtom</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.IntAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of a signed integral type (int kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int8Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int8Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int8Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type int8.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int16Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int16Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int16Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type int16.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type int32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type int64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UIntAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UIntAtom</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UIntAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of an unsigned integral type (uint kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt8Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt8Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt8Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type uint8.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt16Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt16Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt16Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type uint16.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type uint32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type uint64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em><big>)</big><a class="headerlink" href="#tables.Float32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type float32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em><big>)</big><a class="headerlink" href="#tables.Float64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type float64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.ComplexAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">ComplexAtom</tt><big>(</big><em>itemsize</em>, <em>shape=()</em>, <em>dflt=0j</em><big>)</big><a class="headerlink" href="#tables.ComplexAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of kind complex.</p>
<p>Allowed item sizes are 8 (single precision) and 16 (double
precision). This class must be used instead of more concrete
ones to avoid confusions with numarray-like
precision specifications used in PyTables 1.X.</p>
</dd></dl>

<dl class="class">
<dt id="tables.TimeAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">TimeAtom</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.TimeAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of time type (time kind).</p>
<p>There are two distinct supported types of time: a 32 bit
integer value and a 64 bit floating point value. Both of them
reflect the number of seconds since the Unix epoch. This atom
has the property of being stored using the HDF5 time datatypes.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Time32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Time32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type time32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Time64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em><big>)</big><a class="headerlink" href="#tables.Time64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type time64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.EnumAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">EnumAtom</tt><big>(</big><em>enum</em>, <em>dflt</em>, <em>base</em>, <em>shape=()</em><big>)</big><a class="headerlink" href="#tables.EnumAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of an atom of an enumerated type.</p>
<p>Instances of this class describe the atom type used to
store enumerated values. Those values belong to an enumerated
type, defined by the first argument (enum) in
the constructor of the atom, which accepts the same kinds of
arguments as the Enum class (see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>).  The
enumerated type is stored in the enum
attribute of the atom.</p>
<p>A default value must be specified as the second argument
(dflt) in the constructor; it must be the
<em>name</em> (a string) of one of the enumerated
values in the enumerated type. When the atom is created, the
corresponding concrete value is broadcast and stored in the
dflt attribute (setting different default
values for items in a multidimensional atom is not supported
yet). If the name does not match any value in the enumerated
type, a KeyError is raised.</p>
<p>Another atom must be specified as the
base argument in order to determine the base
type used for storing the values of enumerated values in memory
and disk. This <em>storage atom</em> is kept in the
base attribute of the created atom. As a
shorthand, you may specify a PyTables type instead of the
storage atom, implying that this has a scalar shape.</p>
<p>The storage atom should be able to represent each and
every concrete value in the enumeration. If it is not, a
TypeError is raised. The default value of the
storage atom is ignored.</p>
<p>The type attribute of enumerated atoms
is always enum.</p>
<p>Enumerated atoms also support comparisons with other objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;int8&#39;</span><span class="p">)</span>  <span class="c"># same as ``atom2``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="n">Int8Atom</span><span class="p">())</span>  <span class="c"># same as ``atom1``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom3</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;int16&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom4</span> <span class="o">=</span> <span class="n">Int8Atom</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">enum</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">!=</span> <span class="n">atom1</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom4</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom4</span> <span class="o">!=</span> <span class="n">atom1</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<p>The next C enum construction:</p>
<div class="highlight-python"><pre>enum myEnum {
            T0,
            T1,
            T2
            };</pre>
</div>
<p>would correspond to the following PyTables
declaration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myEnumAtom</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">([</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">],</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;int32&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please note the dflt argument with a
value of &#8216;T0&#8217;. Since the concrete value
matching T0 is unknown right now (we have
not used explicit concrete values), using the name is the only
option left for defining a default value for the atom.</p>
<p>The chosen representation of values for this enumerated
atom uses unsigned 32-bit integers, which surely wastes quite
a lot of memory. Another size could be selected by using the
base argument (this time with a full-blown
storage atom):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myEnumAtom</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">([</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">],</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="n">UInt8Atom</span><span class="p">())</span>
</pre></div>
</div>
<p>You can also define multidimensional arrays for data
elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myEnumAtom</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span>
<span class="gp">... </span>   <span class="p">[</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">],</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="s">&#39;uint32&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>for 3x2 arrays of uint32.</p>
</dd></dl>

</div>
<div class="section" id="pseudo-atoms">
<h4>Pseudo atoms<a class="headerlink" href="#pseudo-atoms" title="Permalink to this headline">¶</a></h4>
<p>Now, there come three special classes,
ObjectAtom, VLStringAtom and
VLUnicodeAtom, that actually do not descend
from Atom, but which goal is so similar that
they should be described here. Pseudo-atoms can only be used with
VLArray datasets (see <a class="reference internal" href="#vlarrayclassdescr"><em>The VLArray class</em></a>), and
they do not support multidimensional values, nor multiple values
per row.</p>
<p>They can be recognised because they also have
kind, type and
shape attributes, but no
size, itemsize or
dflt ones. Instead, they have a
base atom which defines the elements used for
storage.</p>
<p>See <tt class="file docutils literal"><span class="pre">examples/vlarray1.py</span></tt> and
<tt class="file docutils literal"><span class="pre">examples/vlarray2.py</span></tt> for further examples on
VLArray datasets, including object
serialization and string management.</p>
<div class="section" id="objectatom">
<h5>ObjectAtom<a class="headerlink" href="#objectatom" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="tables.ObjectAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">ObjectAtom</tt><a class="headerlink" href="#tables.ObjectAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type object.</p>
<p>This class is meant to fit <em>any</em> kind
of Python object in a row of a VLArray
dataset by using cPickle behind the
scenes. Due to the fact that you can not foresee how long will
be the output of the cPickle serialization
(i.e. the atom already has a <em>variable</em>
length), you can only fit <em>one object per
row</em>. However, you can still group several objects in
a single tuple or list and pass it to the
<a class="reference internal" href="#tables.VLArray.append" title="tables.VLArray.append"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.append()</span></tt></a> method.</p>
<p>Object atoms do not accept parameters and they cause the
reads of rows to always return Python objects. You can regard
object atoms as an easy way to save an
arbitrary number of generic Python objects in a
VLArray dataset.</p>
</dd></dl>

</div>
<div class="section" id="vlstringatom">
<span id="id4"></span><h5>VLStringAtom<a class="headerlink" href="#vlstringatom" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="tables.VLStringAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">VLStringAtom</tt><a class="headerlink" href="#tables.VLStringAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type vlstring.</p>
<p>This class describes a <em>row</em> of the
VLArray class, rather than an atom. It
differs from the StringAtom class in that you
can only add <em>one instance of it to one specific
row</em>, i.e. the <a class="reference internal" href="#tables.VLArray.append" title="tables.VLArray.append"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.append()</span></tt></a>
method only accepts one
object when the base atom is of this type.</p>
<p>Like StringAtom, this class does not
make assumptions on the encoding of the string, and raw bytes
are stored as is.  Unicode strings are supported as long as no
character is out of the ASCII set; otherwise, you will need to
<em>explicitly</em> convert them to strings before
you can save them.  For full Unicode support, using
VLUnicodeAtom (see <a class="reference internal" href="#vlunicodeatom"><em>VLUnicodeAtom</em></a>) is recommended.</p>
<p>Variable-length string atoms do not accept parameters and
they cause the reads of rows to always return Python strings.
You can regard vlstring atoms as an easy way
to save generic variable length strings.</p>
</dd></dl>

</div>
<div class="section" id="vlunicodeatom">
<span id="id5"></span><h5>VLUnicodeAtom<a class="headerlink" href="#vlunicodeatom" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="tables.VLUnicodeAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">VLUnicodeAtom</tt><a class="headerlink" href="#tables.VLUnicodeAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type vlunicode.</p>
<p>This class describes a <em>row</em> of the
VLArray class, rather than an atom.  It is
very similar to VLStringAtom (see <a class="reference internal" href="#vlstringatom"><em>VLStringAtom</em></a>), but it stores Unicode strings (using
32-bit characters a la UCS-4, so all strings of the same length
also take up the same space).</p>
<p>This class does not make assumptions on the encoding of
plain input strings.  Plain strings are supported as long as no
character is out of the ASCII set; otherwise, you will need to
<em>explicitly</em> convert them to Unicode before
you can save them.</p>
<p>Variable-length Unicode atoms do not accept parameters and
they cause the reads of rows to always return Python Unicode
strings.  You can regard vlunicode atoms as
an easy way to save variable length Unicode strings.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="the-col-class-and-its-descendants">
<span id="colclassdescr"></span><h3>The Col class and its descendants<a class="headerlink" href="#the-col-class-and-its-descendants" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Col</tt><a class="headerlink" href="#tables.Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column.</p>
<p>Col instances are used as a means to
declare the different properties of a non-nested column in a table
or nested column.  Col classes are descendants of
their equivalent Atom classes (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>), but their
instances have an additional _v_pos attribute
that is used to decide the position of the column inside its parent
table or nested column (see the IsDescription
class in <a class="reference internal" href="#isdescriptionclassdescr"><em>The IsDescription class</em></a> for more information on column positions).</p>
<p>In the same fashion as Atom, you should use
a particular Col descendant class whenever you
know the exact type you will need when writing your code. Otherwise,
you may use one of the Col.from_*() factory methods.</p>
</dd></dl>

<div class="section" id="col-instance-variables">
<h4>Col instance variables<a class="headerlink" href="#col-instance-variables" title="Permalink to this headline">¶</a></h4>
<p>In addition to the variables that they inherit from the
Atom class, Col instances
have the following attributes.</p>
<dl class="attribute">
<dt id="tables.Col._v_pos">
<tt class="descclassname">Col.</tt><tt class="descname">_v_pos</tt><a class="headerlink" href="#tables.Col._v_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>relative</em> position of this
column with regard to its column siblings.</p>
</dd></dl>

</div>
<div class="section" id="col-factory-methods">
<h4>Col factory methods<a class="headerlink" href="#col-factory-methods" title="Permalink to this headline">¶</a></h4>
<p>Each factory method inherited from
the Atom class is available with the same
signature, plus an additional pos parameter
(placed in last position) which defaults
to None and that may take an integer value.
This parameter might be used to specify the position of the column
in the table.</p>
<p>Besides, there are the next additional factory methods,
available only for Col objects.</p>
<dl class="method">
<dt id="tables.Col.from_atom">
<tt class="descclassname">Col.</tt><tt class="descname">from_atom</tt><big>(</big><em>atom</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Col.from_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Col definition from a PyTables atom.</p>
<p>An optional position may be specified as the pos argument.</p>
</dd></dl>

</div>
<div class="section" id="col-constructors">
<h4>Col constructors<a class="headerlink" href="#col-constructors" title="Permalink to this headline">¶</a></h4>
<p>There are some common arguments for most
Col-derived constructors.</p>
<dl class="method">
<dt id="tables.Col.__init__">
<tt class="descclassname">Col.</tt><tt class="descname">__init__</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#tables.Col.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>itemsize</strong> : int</p>
<blockquote>
<div><p>For types with a non-fixed size, this sets the size in
bytes of individual items in the column.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>Sets the shape of the column. An integer shape of
N is equivalent to the tuple (N,).</p>
</div></blockquote>
<p><strong>dflt</strong> :</p>
<blockquote>
<div><p>Sets the default value for the column.</p>
</div></blockquote>
<p><strong>pos</strong> : int</p>
<blockquote class="last">
<div><p>Sets the position of column in table.  If unspecified,
the position will be randomly selected.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="tables.StringCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">StringCol</tt><big>(</big><em>itemsize</em>, <em>shape=()</em>, <em>dflt=''</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.StringCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type string.</p>
</dd></dl>

<dl class="class">
<dt id="tables.BoolCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">BoolCol</tt><big>(</big><em>shape=()</em>, <em>dflt=False</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.BoolCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type bool.</p>
</dd></dl>

<dl class="class">
<dt id="tables.IntCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">IntCol</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.IntCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of a signed integral type (int kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int8Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int8Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Int8Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type int8.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int16Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int16Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Int16Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type int16.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int32Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Int32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type int32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int64Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Int64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type int64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UIntCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UIntCol</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.UIntCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of an unsigned integral type (uint kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt8Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt8Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.UInt8Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type uint8.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt16Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt16Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.UInt16Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type uint16.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt32Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.UInt32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type uint32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt64Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.UInt64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type uint64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float32Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Float32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type float32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float64Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Float64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type float64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.ComplexCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">ComplexCol</tt><big>(</big><em>itemsize</em>, <em>shape=()</em>, <em>dflt=0j</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.ComplexCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of kind complex.</p>
</dd></dl>

<dl class="class">
<dt id="tables.TimeCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">TimeCol</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.TimeCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of time type (time kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.Time32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time32Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Time32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type time32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Time64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time64Col</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Time64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an column of type time64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.EnumCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">EnumCol</tt><big>(</big><em>enum</em>, <em>dflt</em>, <em>base</em>, <em>shape=()</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.EnumCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of an column of an enumerated type.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-isdescription-class">
<span id="isdescriptionclassdescr"></span><h3>The IsDescription class<a class="headerlink" href="#the-isdescription-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.IsDescription">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">IsDescription</tt><a class="headerlink" href="#tables.IsDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of the structure of a table or nested column.</p>
<p>This class is designed to be used as an easy, yet meaningful
way to describe the structure of new Table (see
<a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>)
datasets or nested columns through the definition of
<em>derived classes</em>. In order to define such a
class, you must declare it as descendant of
IsDescription, with as many attributes as columns
you want in your table. The name of each attribute will become the
name of a column, and its value will hold a description of it.</p>
<p>Ordinary columns can be described using instances of the
Col class (see <a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>). Nested columns can be described by
using classes derived from IsDescription,
instances of it, or name-description dictionaries. Derived classes
can be declared in place (in which case the column takes the name of
the class) or referenced by name.</p>
<p>Nested columns can have a _v_pos special
attribute which sets the <em>relative</em> position of
the column among sibling columns <em>also having explicit
positions</em>.  The pos constructor
argument of Col instances is used for the same
purpose.  Columns with no explicit position will be placed
afterwards in alphanumeric order.</p>
<p>Once you have created a description object, you can pass it to
the Table constructor, where all the information
it contains will be used to define the table structure.</p>
</dd></dl>

<div class="section" id="isdescription-special-attributes">
<h4>IsDescription special attributes<a class="headerlink" href="#isdescription-special-attributes" title="Permalink to this headline">¶</a></h4>
<p>These are the special attributes that the user can specify
<em>when declaring</em> an
IsDescription subclass to complement its
<em>metadata</em>.</p>
<dl class="attribute">
<dt id="tables.IsDescription._v_pos">
<tt class="descclassname">IsDescription.</tt><tt class="descname">_v_pos</tt><a class="headerlink" href="#tables.IsDescription._v_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position of a possible nested column
description among its sibling columns.</p>
</dd></dl>

</div>
<div class="section" id="isdescription-class-variables">
<h4>IsDescription class variables<a class="headerlink" href="#isdescription-class-variables" title="Permalink to this headline">¶</a></h4>
<p>The following attributes are <em>automatically
created</em> when an IsDescription
subclass is declared.  Please note that declared columns can no
longer be accessed as normal class variables after its
creation.</p>
<dl class="attribute">
<dt id="tables.IsDescription.columns">
<tt class="descclassname">IsDescription.</tt><tt class="descname">columns</tt><a class="headerlink" href="#tables.IsDescription.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of each column in the description to its
own descriptive object.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="helper-classes">
<h2>Helper classes<a class="headerlink" href="#helper-classes" title="Permalink to this headline">¶</a></h2>
<p>This section describes some classes that do not fit in any other
section and that mainly serve for ancillary purposes.</p>
<div class="section" id="the-filters-class">
<span id="filtersclassdescr"></span><h3>The Filters class<a class="headerlink" href="#the-filters-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Filters">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Filters</tt><a class="headerlink" href="#tables.Filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for filter properties.</p>
<p>This class is meant to serve as a container that keeps
information about the filter properties associated with the chunked
leaves, that is Table, CArray, EArray and VLArray.</p>
<p>Instances of this class can be directly compared for equality.</p>
</dd></dl>

<div class="section" id="filters-instance-variables">
<h4>Filters instance variables<a class="headerlink" href="#filters-instance-variables" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="tables.Filters.fletcher32">
<tt class="descclassname">Filters.</tt><tt class="descname">fletcher32</tt><a class="headerlink" href="#tables.Filters.fletcher32" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the <em>Fletcher32</em> filter is active or not.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Filters.complevel">
<tt class="descclassname">Filters.</tt><tt class="descname">complevel</tt><a class="headerlink" href="#tables.Filters.complevel" title="Permalink to this definition">¶</a></dt>
<dd><p>The compression level (0 disables compression).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Filters.complib">
<tt class="descclassname">Filters.</tt><tt class="descname">complib</tt><a class="headerlink" href="#tables.Filters.complib" title="Permalink to this definition">¶</a></dt>
<dd><p>The compression filter used (irrelevant when
compression is not enabled).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Filters.shuffle">
<tt class="descclassname">Filters.</tt><tt class="descname">shuffle</tt><a class="headerlink" href="#tables.Filters.shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the <em>Shuffle</em> filter is active or not.</p>
</dd></dl>

</div>
<div class="section" id="example-of-use">
<h4>Example of use<a class="headerlink" href="#example-of-use" title="Permalink to this headline">¶</a></h4>
<p>This is a small example on using the
Filters class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">tables</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">fileh</span> <span class="o">=</span> <span class="n">openFile</span><span class="p">(</span><span class="s">&#39;test5.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">atom</span> <span class="o">=</span> <span class="n">Float32Atom</span><span class="p">()</span>
<span class="n">filters</span> <span class="o">=</span> <span class="n">Filters</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s">&#39;blosc&#39;</span><span class="p">,</span> <span class="n">fletcher32</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createEArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;earray&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="s">&quot;A growable array&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>

<span class="c"># Append several rows in only one call</span>
<span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

<span class="c"># Print information on that enlargeable array</span>
<span class="k">print</span> <span class="s">&quot;Result Array:&quot;</span>
<span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This enforces the use of the Blosc library, a compression
level of 1 and a Fletcher32 checksum filter as well. See the
output of this example:</p>
<div class="highlight-python"><pre>Result Array:
/earray (EArray(3, 2), fletcher32, shuffle, blosc(1)) 'A growable array'
type = float32
shape = (3, 2)
itemsize = 4
nrows = 3
extdim = 0
flavor = 'numpy'
byteorder = 'little'</pre>
</div>
<dl class="method">
<dt id="tables.Filters.__init__">
<tt class="descclassname">Filters.</tt><tt class="descname">__init__</tt><big>(</big><em>complevel=0</em>, <em>complib='zlib'</em>, <em>shuffle=True</em>, <em>fletcher32=False</em><big>)</big><a class="headerlink" href="#tables.Filters.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new Filters instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>complevel</strong> : int</p>
<blockquote>
<div><p>Specifies a compression level for data. The allowed
range is 0-9. A value of 0 (the default) disables
compression.</p>
</div></blockquote>
<p><strong>complib</strong> : str</p>
<blockquote>
<div><p>Specifies the compression library to be used. Right
now, &#8216;zlib&#8217; (the default), &#8216;lzo&#8217;, &#8216;bzip2&#8217;
and &#8216;blosc&#8217; are supported.  Specifying a
compression library which is not available in the system
issues a FiltersWarning and sets the library to the default one.</p>
</div></blockquote>
<p><strong>shuffle</strong> : bool</p>
<blockquote>
<div><p>Whether or not to use the <em>Shuffle</em>
filter in the HDF5 library. This is normally used to improve
the compression ratio. A false value disables shuffling and
a true one enables it. The default value depends on whether
compression is enabled or not; if compression is enabled,
shuffling defaults to be enabled, else shuffling is
disabled. Shuffling can only be used when compression is enabled.</p>
</div></blockquote>
<p><strong>fletcher32</strong> : bool</p>
<blockquote class="last">
<div><p>Whether or not to use the
<em>Fletcher32</em> filter in the HDF5 library.
This is used to add a checksum on each data chunk. A false
value (the default) disables the checksum.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Filters.copy">
<tt class="descclassname">Filters.</tt><tt class="descname">copy</tt><big>(</big><em>override</em><big>)</big><a class="headerlink" href="#tables.Filters.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the filters, possibly overriding some arguments.</p>
<p>Constructor arguments to be overridden must be passed as keyword arguments.</p>
<p>Using this method is recommended over replacing the
attributes of an instance, since instances of this class may
become immutable in the future:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span> <span class="o">=</span> <span class="n">Filters</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters2</span> <span class="o">=</span> <span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span> <span class="o">==</span> <span class="n">filters2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span> <span class="ow">is</span> <span class="n">filters2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters3</span> <span class="o">=</span> <span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">compression library ``None`` is not supported...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters3</span> <span class="o">=</span> <span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s">&#39;zlib&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">filters1</span>
<span class="go">Filters(complevel=0, shuffle=False, fletcher32=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">filters3</span>
<span class="go">Filters(complevel=1, complib=&#39;zlib&#39;, shuffle=False, fletcher32=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">foobar</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">__init__() got an unexpected keyword argument &#39;foobar&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="the-index-class">
<span id="indexclassdescr"></span><h3>The Index class<a class="headerlink" href="#the-index-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Index">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Index</tt><a class="headerlink" href="#tables.Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the index of a column in a table.</p>
<p>This class is used to keep the indexing information for
columns in a Table dataset (see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>). It is
actually a descendant of the Group class (see
<a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>), with
some added functionality. An Index is always
associated with one and only one column in the table.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is mainly intended for internal use, but some of
its documented attributes and methods may be interesting for the
programmer.</p>
</div>
</dd></dl>

<div class="section" id="index-instance-variables">
<h4>Index instance variables<a class="headerlink" href="#index-instance-variables" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="tables.Index.column">
<tt class="descclassname">Index.</tt><tt class="descname">column</tt><a class="headerlink" href="#tables.Index.column" title="Permalink to this definition">¶</a></dt>
<dd><p>The Column (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>)
instance for the indexed column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Index.dirty">
<tt class="descclassname">Index.</tt><tt class="descname">dirty</tt><a class="headerlink" href="#tables.Index.dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the index is dirty or not.</p>
<p>Dirty indexes are out of sync with column data, so
they exist but they are not usable.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Index.filters">
<tt class="descclassname">Index.</tt><tt class="descname">filters</tt><a class="headerlink" href="#tables.Index.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter properties for this index - see
Filters in <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Index.nelements">
<tt class="descclassname">Index.</tt><tt class="descname">nelements</tt><a class="headerlink" href="#tables.Index.nelements" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of currently indexed row for this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Index.is_CSI">
<tt class="descclassname">Index.</tt><tt class="descname">is_CSI</tt><a class="headerlink" href="#tables.Index.is_CSI" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the index is completely sorted or not.</p>
</dd></dl>

</div>
<div class="section" id="index-methods">
<h4>Index methods<a class="headerlink" href="#index-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Index.readSorted">
<tt class="descclassname">Index.</tt><tt class="descname">readSorted</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Index.readSorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sorted values of index in the specified range.</p>
<p>The meaning of the start, stop and step arguments is
the same as in <a class="reference internal" href="#tables.Table.readSorted" title="tables.Table.readSorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readSorted()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Index.readIndices">
<tt class="descclassname">Index.</tt><tt class="descname">readIndices</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Index.readIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices values of index in the specified range.</p>
<p>The meaning of the start, stop and step arguments is
the same as in <a class="reference internal" href="#tables.Table.readSorted" title="tables.Table.readSorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readSorted()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="index-special-methods">
<h4>Index special methods<a class="headerlink" href="#index-special-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Index.__getitem__">
<tt class="descclassname">Index.</tt><tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Index.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices values of index in the specified range.</p>
<p>If key argument is an integer, the
corresponding index is returned.  If key is a
slice, the range of indices determined by it is returned.  A
negative value of step in slice is supported,
meaning that the results will be returned in reverse
order.</p>
<p>This method is equivalent to <a class="reference internal" href="#tables.Index.readIndices" title="tables.Index.readIndices"><tt class="xref py py-meth docutils literal"><span class="pre">Index.readIndices()</span></tt></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-enum-class">
<span id="enumclassdescr"></span><h3>The Enum class<a class="headerlink" href="#the-enum-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Enum">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Enum</tt><a class="headerlink" href="#tables.Enum" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerated type.</p>
<p>Each instance of this class represents an enumerated type. The
values of the type must be declared
<em>exhaustively</em> and named with
<em>strings</em>, and they might be given explicit
concrete values, though this is not compulsory. Once the type is
defined, it can not be modified.</p>
<p>There are three ways of defining an enumerated type. Each one
of them corresponds to the type of the only argument in the
constructor of Enum:</p>
<ul>
<li><p class="first"><em>Sequence of names</em>: each enumerated
value is named using a string, and its order is determined by
its position in the sequence; the concrete value is assigned
automatically:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">boolEnum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span><span class="s">&#39;True&#39;</span><span class="p">,</span> <span class="s">&#39;False&#39;</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>Mapping of names</em>: each enumerated
value is named by a string and given an explicit concrete value.
All of the concrete values must be different, or a
ValueError will be raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;red&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;green&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">colors</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;red&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;blue&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: enumerated values contain duplicate concrete values</span>: <span class="n">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>Enumerated type</em>: in that case, a copy
of the original enumerated type is created. Both enumerated
types are considered equal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prio2</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="n">priority</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span> <span class="o">==</span> <span class="n">prio2</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
</ul>
<p>Please note that names starting with _ are
not allowed, since they are reserved for internal usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prio2</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span><span class="s">&#39;_xx&#39;</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: name of enumerated value can not start with ``_``</span>: <span class="n">&#39;_xx&#39;</span>
</pre></div>
</div>
<p>The concrete value of an enumerated value is obtained by
getting its name as an attribute of the Enum
instance (see __getattr__()) or as an item (see
__getitem__()). This allows comparisons between
enumerated values and assigning them to ordinary Python
variables:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">redv</span> <span class="o">=</span> <span class="n">priority</span><span class="o">.</span><span class="n">red</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">redv</span> <span class="o">==</span> <span class="n">priority</span><span class="p">[</span><span class="s">&#39;red&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">redv</span> <span class="o">&gt;</span> <span class="n">priority</span><span class="o">.</span><span class="n">green</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span><span class="o">.</span><span class="n">red</span> <span class="o">==</span> <span class="n">priority</span><span class="o">.</span><span class="n">orange</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The name of the enumerated value corresponding to a concrete
value can also be obtained by using the
__call__() method of the enumerated type. In this
way you get the symbolic name to use it later with
__getitem__():</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span><span class="p">(</span><span class="n">redv</span><span class="p">)</span>
<span class="go">&#39;red&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span><span class="o">.</span><span class="n">red</span> <span class="o">==</span> <span class="n">priority</span><span class="p">[</span><span class="n">priority</span><span class="p">(</span><span class="n">priority</span><span class="o">.</span><span class="n">red</span><span class="p">)]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>(If you ask, the __getitem__() method is
not used for this purpose to avoid ambiguity in the case of using
strings as concrete values.)</p>
</dd></dl>

<div class="section" id="enum-special-methods">
<h4>Enum special methods<a class="headerlink" href="#enum-special-methods" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="tables.Enum.__call__">
<tt class="descclassname">Enum.</tt><tt class="descname">__call__</tt><big>(</big><em>value</em>, <em>*default</em><big>)</big><a class="headerlink" href="#tables.Enum.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the enumerated value with that concrete value.</p>
<p>If there is no value with that concrete value in the
enumeration and a second argument is given as a
default, this is returned. Else, a ValueError is raised.</p>
<p>This method can be used for checking that a concrete value
belongs to the set of concrete values in an enumerated type.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Enum.__contains__">
<tt class="descclassname">Enum.</tt><tt class="descname">__contains__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Enum.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there an enumerated value with that
name in the type?</p>
<p>If the enumerated type has an enumerated value with that
name, True is returned.
Otherwise, False is returned. The
name must be a string.</p>
<p>This method does <em>not</em> check for
concrete values matching a value in an enumerated type. For
that, please use the <a class="reference internal" href="#tables.Enum.__call__" title="tables.Enum.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">Enum.__call__()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Enum.__eq__">
<tt class="descclassname">Enum.</tt><tt class="descname">__eq__</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#tables.Enum.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the other enumerated type equivalent to this one?</p>
<p>Two enumerated types are equivalent if they have exactly
the same enumerated values (i.e. with the same names and
concrete values).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Enum.__getattr__">
<tt class="descclassname">Enum.</tt><tt class="descname">__getattr__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Enum.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the concrete value of the enumerated value with that
name.</p>
<p>The name of the enumerated value must
be a string. If there is no value with that
name in the enumeration, an
AttributeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Enum.__getitem__">
<tt class="descclassname">Enum.</tt><tt class="descname">__getitem__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Enum.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the concrete value of the enumerated value with that name.</p>
<p>The name of the enumerated value must
be a string. If there is no value with that
name in the enumeration, a KeyError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Enum.__iter__">
<tt class="descclassname">Enum.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Enum.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the enumerated values.</p>
<p>Enumerated values are returned as (name,
value) pairs <em>in no particular order</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Enum.__len__">
<tt class="descclassname">Enum.</tt><tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Enum.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of enumerated values in the enumerated type.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Enum.__repr__">
<tt class="descclassname">Enum.</tt><tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Enum.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the canonical string representation of the
enumeration. The output of this method can be evaluated to give
a new enumeration object that will compare equal to this one.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="the-expr-class-a-general-purpose-expression-evaluator">
<h2>The Expr class - a general-purpose expression evaluator<a class="headerlink" href="#the-expr-class-a-general-purpose-expression-evaluator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Expr">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Expr</tt><a class="headerlink" href="#tables.Expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Expr is a class for evaluating expressions
containing array-like objects.  With it, you can evaluate expressions
(like &#8220;3*a+4*b&#8221;) that operate on arbitrary large
arrays while optimizing the resources required to perform them
(basically main memory and CPU cache memory).  It is similar to the
Numexpr package (see ), but in addition
to NumPy objects, it also accepts disk-based homogeneous arrays, like
the Array, CArray, EArray and Column PyTables objects.</p>
<p>All the internal computations are performed via the Numexpr
package, so all the broadcast and upcasting rules of Numexpr applies
here too.  These rules are very similar to the NumPy ones, but with
some exceptions due to the particularities of having to deal with
potentially very large disk-based arrays.  Be sure to read the
documentation of the
Expr constructor and methods as well as that of
Numexpr, if you want to fully grasp these particularities.</p>
</dd></dl>

<div class="section" id="expr-instance-variables">
<h3>Expr instance variables<a class="headerlink" href="#expr-instance-variables" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.Expr.append_mode">
<tt class="descclassname">Expr.</tt><tt class="descname">append_mode</tt><a class="headerlink" href="#tables.Expr.append_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The appending mode for user-provided output containers.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.maindim">
<tt class="descclassname">Expr.</tt><tt class="descname">maindim</tt><a class="headerlink" href="#tables.Expr.maindim" title="Permalink to this definition">¶</a></dt>
<dd><p>Common main dimension for inputs in expression.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.names">
<tt class="descclassname">Expr.</tt><tt class="descname">names</tt><a class="headerlink" href="#tables.Expr.names" title="Permalink to this definition">¶</a></dt>
<dd><p>The names of variables in expression (list).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.out">
<tt class="descclassname">Expr.</tt><tt class="descname">out</tt><a class="headerlink" href="#tables.Expr.out" title="Permalink to this definition">¶</a></dt>
<dd><p>The user-provided container (if any) for the
expression outcome.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.o_start">
<tt class="descclassname">Expr.</tt><tt class="descname">o_start</tt><a class="headerlink" href="#tables.Expr.o_start" title="Permalink to this definition">¶</a></dt>
<dd><p>The start range selection for the user-provided output.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.o_stop">
<tt class="descclassname">Expr.</tt><tt class="descname">o_stop</tt><a class="headerlink" href="#tables.Expr.o_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>The stop range selection for the user-provided output.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.o_step">
<tt class="descclassname">Expr.</tt><tt class="descname">o_step</tt><a class="headerlink" href="#tables.Expr.o_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The step range selection for the user-provided output.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.shape">
<tt class="descclassname">Expr.</tt><tt class="descname">shape</tt><a class="headerlink" href="#tables.Expr.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Common shape for the arrays in expression.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.values">
<tt class="descclassname">Expr.</tt><tt class="descname">values</tt><a class="headerlink" href="#tables.Expr.values" title="Permalink to this definition">¶</a></dt>
<dd><p>The values of variables in expression (list).</p>
</dd></dl>

</div>
<div class="section" id="expr-special-tuning-variables-for-input-output">
<h3>Expr special tuning variables for input/output<a class="headerlink" href="#expr-special-tuning-variables-for-input-output" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The next parameters are meant only for advanced
users.  Please do not touch them if you don&#8217;t know what you are
doing.</p>
</div>
<dl class="attribute">
<dt id="tables.Expr.BUFFERTIMES">
<tt class="descclassname">Expr.</tt><tt class="descname">BUFFERTIMES</tt><a class="headerlink" href="#tables.Expr.BUFFERTIMES" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum buffersize/rowsize ratio before issuing a
<em>PerformanceWarning</em>.  The default is 1000.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.CHUNKTIMES">
<tt class="descclassname">Expr.</tt><tt class="descname">CHUNKTIMES</tt><a class="headerlink" href="#tables.Expr.CHUNKTIMES" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of chunks in the input buffer per each
variable in expression.  The default is 16.</p>
</dd></dl>

</div>
<div class="section" id="expr-methods">
<h3>Expr methods<a class="headerlink" href="#expr-methods" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Expr.__init__">
<tt class="descclassname">Expr.</tt><tt class="descname">__init__</tt><big>(</big><em>expr</em>, <em>uservars=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Expr.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile the expression and initialize internal structures.</p>
<p>expr must be specified as a string like &#8220;2*a+3*b&#8221;.</p>
<p>The uservars mapping may be used to
define the variable names appearing in expr.
This mapping should consist of identifier-like strings pointing
to any Array, CArray, EArray,
Column or NumPy ndarray instances (or even
others which will be tried to be converted to ndarrays).</p>
<p>When uservars is not provided
or None, the current local and global
namespace is sought instead of uservars.  It
is also possible to pass just some of the variables in
expression via the uservars mapping, and the
rest will be retrieved from the current local and global
namespaces.</p>
<p><em>kwargs</em> is meant to pass additional
parameters to the Numexpr kernel.  This is basically the same as
the <em>kwargs</em> argument
in Numexpr.evaluate(), and is mainly meant
for advanced use.</p>
<p>After initialized, an Expr instance can
be evaluated via its eval() method.  This
class also provides an __iter__() method that
iterates over all the resulting rows in expression.</p>
<p>Example of use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Expr</span><span class="p">(</span><span class="s">&quot;2*a+b*c&quot;</span><span class="p">)</span>   <span class="c"># initialize the expression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>                 <span class="c"># evaluate it</span>
<span class="go">array([14, 24, 36])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>                   <span class="c"># use as an iterator</span>
<span class="go">74</span>
</pre></div>
</div>
<p>where you can see that you can mix different containers in
the expression (whenever shapes are consistent).</p>
<p>You can also work with multidimensional arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;a2&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;b2&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>           <span class="c"># This will be broadcasted</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Expr</span><span class="p">(</span><span class="s">&quot;2*a2+b2-c2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">array([ 8, 12])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.eval">
<tt class="descclassname">Expr.</tt><tt class="descname">eval</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Expr.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the expression and return the outcome.</p>
<p>Because of performance reasons, the computation order tries
to go along the common main dimension of all inputs.  If not
such a common main dimension is found, the iteration will go
along the leading dimension instead.</p>
<p>For non-consistent shapes in inputs (i.e. shapes having a
different number of dimensions), the regular NumPy broadcast
rules applies.  There is one exception to this rule though: when
the dimensions orthogonal to the main dimension of the
expression are consistent, but the main dimension itself differs
among the inputs, then the shortest one is chosen for doing the
computations.  This is so because trying to expand very large
on-disk arrays could be too expensive or simply not
possible.</p>
<p>Also, the regular Numexpr casting rules (which are similar
to those of NumPy, although you should check the Numexpr manual
for the exceptions) are applied to determine the output type.</p>
<p>Finally, if the setOuput() method
specifying a user container has already been called, the output
is sent to this user-provided container.  If not, a fresh NumPy
container is returned instead.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When dealing with large on-disk inputs, failing to
specify an on-disk container may consume all your available
memory.</p>
</div>
<p>For some examples of use see the <a class="reference internal" href="#tables.Expr.__init__" title="tables.Expr.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">Expr.__init__()</span></tt></a> docs.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.setInputsRange">
<tt class="descclassname">Expr.</tt><tt class="descname">setInputsRange</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Expr.setInputsRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a range for all inputs in expression.</p>
<p>The computation will only take place for the range defined
by the start, stop and step parameters in the main dimension of
inputs (or the leading one, if the object lacks the concept of
main dimension, like a NumPy container).  If not a common main
dimension exists for all inputs, the leading dimension will be
used instead.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.setOutput">
<tt class="descclassname">Expr.</tt><tt class="descname">setOutput</tt><big>(</big><em>out</em>, <em>append_mode=False</em><big>)</big><a class="headerlink" href="#tables.Expr.setOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Set out as container for output as well as the append_mode.</p>
<p>The out must be a container that is meant
to keep the outcome of the expression.  It should be an
homogeneous type container and can typically be
an Array, CArray, EArray, Column or a NumPy ndarray.</p>
<p>The append_mode specifies the way of
which the output is filled.  If true, the rows of the outcome
are <em>appended</em> to the out
container.  Of course, for doing this it is necessary
that out would have
an append() method (like
an EArray, for example).</p>
<p>If append_mode is false, the output is
set via the __setitem__() method (see
the Expr.setOutputRange() for info on how to
select the rows to be updated).  If out is
smaller than what is required by the expression, only the
computations that are needed to fill up the container are
carried out.  If it is larger, the excess elements are
unaffected.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.setOutputRange">
<tt class="descclassname">Expr.</tt><tt class="descname">setOutputRange</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Expr.setOutputRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a range for user-provided output object.</p>
<p>The output object will only be modified in the range
specified by the start,
stop and step parameters
in the main dimension of output (or the leading one, if the
object does not have the concept of main dimension, like a NumPy
container).</p>
</dd></dl>

</div>
<div class="section" id="expr-special-methods">
<h3>Expr special methods<a class="headerlink" href="#expr-special-methods" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.Expr.__iter__">
<tt class="descclassname">Expr.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Expr.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the outcome of the expression.</p>
<p>This iterator always returns rows as NumPy objects, so a
possible out container specified
in <a class="reference internal" href="#tables.Expr.setOutput" title="tables.Expr.setOutput"><tt class="xref py py-meth docutils literal"><span class="pre">Expr.setOutput()</span></tt></a> method is ignored
here.</p>
<p>The <a class="reference internal" href="#tables.Expr.eval" title="tables.Expr.eval"><tt class="xref py py-meth docutils literal"><span class="pre">Expr.eval()</span></tt></a> documentation for
details on how the computation is carried out.  Also, for some
examples of use see the <a class="reference internal" href="#tables.Expr.__init__" title="tables.Expr.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">Expr.__init__()</span></tt></a> docs.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo-pytables-small.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Library Reference</a><ul>
<li><a class="reference internal" href="#tables-variables-and-functions">tables variables and functions</a><ul>
<li><a class="reference internal" href="#global-variables">Global variables</a></li>
<li><a class="reference internal" href="#global-functions">Global functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-file-class">The File Class</a><ul>
<li><a class="reference internal" href="#file-methods-file-handling">File methods - file handling</a></li>
<li><a class="reference internal" href="#file-methods-hierarchy-manipulation">File methods - hierarchy manipulation</a></li>
<li><a class="reference internal" href="#file-methods-tree-traversal">File methods - tree traversal</a></li>
<li><a class="reference internal" href="#file-methods-undo-redo-support">File methods - Undo/Redo support</a></li>
<li><a class="reference internal" href="#file-methods-attribute-handling">File methods - attribute handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-node-class">The Node class</a><ul>
<li><a class="reference internal" href="#node-instance-variables-location-dependent">Node instance variables - location dependent</a></li>
<li><a class="reference internal" href="#node-instance-variables-location-independent">Node instance variables - location independent</a></li>
<li><a class="reference internal" href="#node-instance-variables-attribute-shorthands">Node instance variables - attribute shorthands</a></li>
<li><a class="reference internal" href="#node-methods-hierarchy-manipulation">Node methods - hierarchy manipulation</a></li>
<li><a class="reference internal" href="#node-methods-attribute-handling">Node methods - attribute handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-group-class">The Group class</a><ul>
<li><a class="reference internal" href="#group-instance-variables">Group instance variables</a></li>
<li><a class="reference internal" href="#group-methods">Group methods</a></li>
<li><a class="reference internal" href="#group-special-methods">Group special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-leaf-class">The Leaf class</a><ul>
<li><a class="reference internal" href="#leaf-instance-variables">Leaf instance variables</a></li>
<li><a class="reference internal" href="#leaf-instance-variables-aliases">Leaf instance variables - aliases</a></li>
<li><a class="reference internal" href="#leaf-methods">Leaf methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-table-class">The Table class</a><ul>
<li><a class="reference internal" href="#table-instance-variables">Table instance variables</a></li>
<li><a class="reference internal" href="#table-methods-reading">Table methods - reading</a></li>
<li><a class="reference internal" href="#table-methods-writing">Table methods - writing</a></li>
<li><a class="reference internal" href="#table-methods-querying">Table methods - querying</a></li>
<li><a class="reference internal" href="#table-methods-other">Table methods - other</a></li>
<li><a class="reference internal" href="#the-description-class">The Description class</a><ul>
<li><a class="reference internal" href="#description-instance-variables">Description instance variables</a></li>
<li><a class="reference internal" href="#description-methods">Description methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-row-class">The Row class</a><ul>
<li><a class="reference internal" href="#row-instance-variables">Row instance variables</a></li>
<li><a class="reference internal" href="#row-methods">Row methods</a></li>
<li><a class="reference internal" href="#row-special-methods">Row special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-cols-class">The Cols class</a><ul>
<li><a class="reference internal" href="#cols-instance-variables">Cols instance variables</a></li>
<li><a class="reference internal" href="#cols-methods">Cols methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-column-class">The Column class</a><ul>
<li><a class="reference internal" href="#column-instance-variables">Column instance variables</a></li>
<li><a class="reference internal" href="#column-methods">Column methods</a></li>
<li><a class="reference internal" href="#column-special-methods">Column special methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-array-class">The Array class</a><ul>
<li><a class="reference internal" href="#array-instance-variables">Array instance variables</a></li>
<li><a class="reference internal" href="#array-methods">Array methods</a></li>
<li><a class="reference internal" href="#array-special-methods">Array special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-carray-class">The CArray class</a><ul>
<li><a class="reference internal" href="#examples-of-use">Examples of use</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-earray-class">The EArray class</a><ul>
<li><a class="reference internal" href="#earray-methods">EArray methods</a></li>
<li><a class="reference internal" href="#id2">Examples of use</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-vlarray-class">The VLArray class</a><ul>
<li><a class="reference internal" href="#vlarray-instance-variables">VLArray instance variables</a></li>
<li><a class="reference internal" href="#vlarray-methods">VLArray methods</a></li>
<li><a class="reference internal" href="#vlarray-special-methods">VLArray special methods</a></li>
<li><a class="reference internal" href="#id3">Examples of use</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-link-class">The Link class</a><ul>
<li><a class="reference internal" href="#link-instance-variables">Link instance variables</a></li>
<li><a class="reference internal" href="#link-methods">Link methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-softlink-class">The SoftLink class</a><ul>
<li><a class="reference internal" href="#softlink-special-methods">SoftLink special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-externallink-class">The ExternalLink class</a><ul>
<li><a class="reference internal" href="#externallink-instance-variables">ExternalLink instance variables</a></li>
<li><a class="reference internal" href="#externallink-methods">ExternalLink methods</a></li>
<li><a class="reference internal" href="#externallink-special-methods">ExternalLink special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-unimplemented-class">The UnImplemented class</a></li>
<li><a class="reference internal" href="#the-unknown-class">The Unknown class</a></li>
<li><a class="reference internal" href="#the-attributeset-class">The AttributeSet class</a><ul>
<li><a class="reference internal" href="#notes-on-native-and-pickled-attributes">Notes on native and pickled attributes</a></li>
<li><a class="reference internal" href="#attributeset-instance-variables">AttributeSet instance variables</a></li>
<li><a class="reference internal" href="#attributeset-methods">AttributeSet methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarative-classes">Declarative classes</a><ul>
<li><a class="reference internal" href="#the-atom-class-and-its-descendants">The Atom class and its descendants</a><ul>
<li><a class="reference internal" href="#atom-instance-variables">Atom instance variables</a></li>
<li><a class="reference internal" href="#atom-methods">Atom methods</a></li>
<li><a class="reference internal" href="#atom-factory-methods">Atom factory methods</a></li>
<li><a class="reference internal" href="#atom-constructors">Atom constructors</a></li>
<li><a class="reference internal" href="#pseudo-atoms">Pseudo atoms</a><ul>
<li><a class="reference internal" href="#objectatom">ObjectAtom</a></li>
<li><a class="reference internal" href="#vlstringatom">VLStringAtom</a></li>
<li><a class="reference internal" href="#vlunicodeatom">VLUnicodeAtom</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-col-class-and-its-descendants">The Col class and its descendants</a><ul>
<li><a class="reference internal" href="#col-instance-variables">Col instance variables</a></li>
<li><a class="reference internal" href="#col-factory-methods">Col factory methods</a></li>
<li><a class="reference internal" href="#col-constructors">Col constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-isdescription-class">The IsDescription class</a><ul>
<li><a class="reference internal" href="#isdescription-special-attributes">IsDescription special attributes</a></li>
<li><a class="reference internal" href="#isdescription-class-variables">IsDescription class variables</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#helper-classes">Helper classes</a><ul>
<li><a class="reference internal" href="#the-filters-class">The Filters class</a><ul>
<li><a class="reference internal" href="#filters-instance-variables">Filters instance variables</a></li>
<li><a class="reference internal" href="#example-of-use">Example of use</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-index-class">The Index class</a><ul>
<li><a class="reference internal" href="#index-instance-variables">Index instance variables</a></li>
<li><a class="reference internal" href="#index-methods">Index methods</a></li>
<li><a class="reference internal" href="#index-special-methods">Index special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-enum-class">The Enum class</a><ul>
<li><a class="reference internal" href="#enum-special-methods">Enum special methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-expr-class-a-general-purpose-expression-evaluator">The Expr class - a general-purpose expression evaluator</a><ul>
<li><a class="reference internal" href="#expr-instance-variables">Expr instance variables</a></li>
<li><a class="reference internal" href="#expr-special-tuning-variables-for-input-output">Expr special tuning variables for input/output</a></li>
<li><a class="reference internal" href="#expr-methods">Expr methods</a></li>
<li><a class="reference internal" href="#expr-special-methods">Expr special methods</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorials.html"
                        title="previous chapter">Tutorials</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="optimization.html"
                        title="next chapter">Optimization tips</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/usersguide/libref.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="optimization.html" title="Optimization tips"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             >previous</a> |</li>
        <li><a href="../index.html">PyTables v2.3rc1 documentation</a> &raquo;</li>
          <li><a href="index.html" >PyTables User&#8217;s Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, The PyTables Governance Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>