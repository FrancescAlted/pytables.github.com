


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Library Reference &mdash; PyTables 2.4.0b1 documentation</title>
    
    <link rel="stylesheet" href="../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.0b1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../_static/toggle_sections.js"></script>
    <script type="text/javascript" src="../_static/toggle_sidebar.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="PyTables 2.4.0b1 documentation" href="../index.html" />
    <link rel="up" title="PyTables User’s Guide" href="index.html" />
    <link rel="next" title="Optimization tips" href="optimization.html" />
    <link rel="prev" title="Tutorials" href="tutorials.html" /> 
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="optimization.html" title="Optimization tips"
             accesskey="N">next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             accesskey="P">previous</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">PyTables 2.4.0b1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">PyTables User&#8217;s Guide</a> &raquo;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="library-reference">
<span id="id1"></span><h1>Library Reference<a class="headerlink" href="#library-reference" title="Permalink to this headline">¶</a></h1>
<p>PyTables implements several classes to represent the different nodes in the
object tree. They are named File, Group, Leaf, Table, Array, CArray, EArray,
VLArray and UnImplemented. Another one allows the user to complement the
information on these different objects; its name is AttributeSet. Finally,
another important class called IsDescription allows to build a Table record
description by declaring a subclass of it. Many other classes are defined in
PyTables, but they can be regarded as helpers whose goal is mainly to declare
the <em>data type properties</em> of the different first class objects and will be
described at the end of this chapter as well.</p>
<p>An important function, called openFile is responsible to create, open or append
to files. In addition, a few utility functions are defined to guess if the user
supplied file is a <em>PyTables</em> or <em>HDF5</em> file. These are called isPyTablesFile()
and isHDF5File(), respectively. There exists also a function called
whichLibVersion() that informs about the versions of the underlying C libraries
(for example, HDF5 or Zlib) and another called print_versions() that prints all
the versions of the software that PyTables relies on. Finally, test() lets you
run the complete test suite from a Python console interactively.</p>
<p>Let&#8217;s start discussing the first-level variables and functions available to the
user, then the different classes defined in PyTables.</p>
<div class="section" id="tables-variables-and-functions">
<h2>tables variables and functions<a class="headerlink" href="#tables-variables-and-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="global-variables">
<h3>Global variables<a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h3>
<dl class="data">
<dt id="tables.__version__">
<tt class="descclassname">tables.</tt><tt class="descname">__version__</tt><em class="property"> = '2.4.0b1'</em><a class="headerlink" href="#tables.__version__" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables version number.</p>
</dd></dl>

<dl class="data">
<dt id="tables.hdf5Version">
<tt class="descclassname">tables.</tt><tt class="descname">hdf5Version</tt><em class="property"> = '1.8.4-patch1'</em><a class="headerlink" href="#tables.hdf5Version" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying HDF5 library version number.</p>
</dd></dl>

<dl class="data">
<dt id="tables.is_pro">
<tt class="descclassname">tables.</tt><tt class="descname">is_pro</tt><em class="property"> = True</em><a class="headerlink" href="#tables.is_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>True for PyTables Professional edition, false otherwise.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">PyTables Professional edition has been released under an open
source license. Starting with version 2.3, PyTables includes all
features of PyTables Pro.  In order to reflect the presence of
advanced features <a class="reference internal" href="#tables.is_pro" title="tables.is_pro"><tt class="xref py py-data docutils literal"><span class="pre">is_pro</span></tt></a> is always set to True.
<a class="reference internal" href="#tables.is_pro" title="tables.is_pro"><tt class="xref py py-data docutils literal"><span class="pre">is_pro</span></tt></a> should be considered <em>deprecated</em>.
It will be removed in the next major release.</p>
</div>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 2.3.</span></p>
</dd></dl>

</div>
<div class="section" id="global-functions">
<h3>Global functions<a class="headerlink" href="#global-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="tables.copyFile">
<tt class="descclassname">tables.</tt><tt class="descname">copyFile</tt><big>(</big><em>srcfilename</em>, <em>dstfilename</em>, <em>overwrite=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.copyFile" title="Permalink to this definition">¶</a></dt>
<dd><p>An easy way of copying one PyTables file to another.</p>
<p>This function allows you to copy an existing PyTables file named srcfilename
to another file called dstfilename. The source file must exist and be
readable. The destination file can be overwritten in place if existing by
asserting the overwrite argument.</p>
<p>This function is a shorthand for the <a class="reference internal" href="#tables.File.copyFile" title="tables.File.copyFile"><tt class="xref py py-meth docutils literal"><span class="pre">File.copyFile()</span></tt></a> method, which
acts on an already opened file. kwargs takes keyword arguments used to
customize the copying process. See the documentation
of <a class="reference internal" href="#tables.File.copyFile" title="tables.File.copyFile"><tt class="xref py py-meth docutils literal"><span class="pre">File.copyFile()</span></tt></a> for a description of those arguments.</p>
</dd></dl>

<dl class="function">
<dt id="tables.isHDF5File">
<tt class="descclassname">tables.</tt><tt class="descname">isHDF5File</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#tables.isHDF5File" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a file is in the HDF5 format.</p>
<p>When successful, it returns a true value if the file is an HDF5
file, false otherwise.  If there were problems identifying the file,
an HDF5ExtError is raised.</p>
</dd></dl>

<dl class="function">
<dt id="tables.isPyTablesFile">
<tt class="descclassname">tables.</tt><tt class="descname">isPyTablesFile</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#tables.isPyTablesFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a file is in the PyTables format.</p>
<p>When successful, it returns the format version string if the file is a
PyTables file, None otherwise.  If there were problems identifying the
file, an HDF5ExtError is raised.</p>
</dd></dl>

<dl class="class">
<dt id="tables.lrange">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">lrange</tt><a class="headerlink" href="#tables.lrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over long ranges.</p>
<p>This is similar to xrange(), but it allows 64-bit arguments on all platforms.
The results of the iteration are sequentially yielded in the form of
numpy.int64 values, but getting random individual items is not supported.</p>
<p>Because of the Python 32-bit limitation on object lengths, the length
attribute (which is also a numpy.int64 value) should be used instead of the
len() syntax.</p>
<p>Default start and step arguments are supported in the same way as in
xrange().  When the standard [x]range() Python objects support 64-bit
arguments, this iterator will be deprecated.</p>
</dd></dl>

<dl class="function">
<dt id="tables.openFile">
<tt class="descclassname">tables.</tt><tt class="descname">openFile</tt><big>(</big><em>filename</em>, <em>mode='r'</em>, <em>title=''</em>, <em>rootUEP='/'</em>, <em>filters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.openFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a PyTables (or generic HDF5) file and return a File object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>The name of the file (supports environment variable expansion). It is
suggested that file names have any of the .h5, .hdf or .hdf5
extensions, although this is not mandatory.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>The mode to open the file. It can be one of the
following:</p>
<blockquote>
<div><ul class="simple">
<li><em>&#8216;r&#8217;</em>: Read-only; no data can be modified.</li>
<li><em>&#8216;w&#8217;</em>: Write; a new file is created (an existing file with the
same name would be deleted).</li>
<li><em>&#8216;a&#8217;</em>: Append; an existing file is opened for reading and writing,
and if the file does not exist it is created.</li>
<li><em>&#8216;r+&#8217;</em>: It is similar to &#8216;a&#8217;, but the file must already exist.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>If the file is to be created, a TITLE string attribute will be set on
the root group with the given value. Otherwise, the title will be read
from disk, and this will not have any effect.</p>
</div></blockquote>
<p><strong>rootUEP</strong> : str</p>
<blockquote>
<div><p>The root User Entry Point. This is a group in the HDF5 hierarchy which
will be taken as the starting point to create the object tree. It can
be whatever existing group in the file, named by its HDF5 path. If it
does not exist, an HDF5ExtError is issued. Use this if you do not want
to build the <em>entire</em> object tree, but rather only a <em>subtree</em> of it.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote class="last">
<div><p>An instance of the Filters (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) class that
provides information about the desired I/O filters applicable to the
leaves that hang directly from the <em>root group</em>, unless other filter
properties are specified for these leaves. Besides, if you do not
specify filter properties for child groups, they will inherit these
ones, which will in turn propagate to child nodes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In addition, it recognizes the names of parameters present
in <tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt> as additional keyword
arguments.  See <a class="reference internal" href="parameter_files.html#parameter-files"><em>PyTables parameter files</em></a> for a
detailed info on the supported parameters.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need to deal with a large number of nodes in an
efficient way, please see <a class="reference internal" href="optimization.html#lruoptim"><em>Getting the most from the node LRU cache</em></a> for more info and
advices about the integrated node cache engine.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="tables.setBloscMaxThreads">
<tt class="descclassname">tables.</tt><tt class="descname">setBloscMaxThreads</tt><big>(</big><em>nthreads</em><big>)</big><a class="headerlink" href="#tables.setBloscMaxThreads" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the maximum number of threads that Blosc can use.</p>
<p>This actually overrides the <a class="reference internal" href="parameter_files.html#tables.parameters.MAX_BLOSC_THREADS" title="tables.parameters.MAX_BLOSC_THREADS"><tt class="xref py py-data docutils literal"><span class="pre">tables.parameters.MAX_BLOSC_THREADS</span></tt></a>
setting in <tt class="xref py py-mod docutils literal"><span class="pre">tables.parameters</span></tt>, so the new value will be effective until
this function is called again or a new file with a different
<a class="reference internal" href="parameter_files.html#tables.parameters.MAX_BLOSC_THREADS" title="tables.parameters.MAX_BLOSC_THREADS"><tt class="xref py py-data docutils literal"><span class="pre">tables.parameters.MAX_BLOSC_THREADS</span></tt></a> value is specified.</p>
<p>Returns the previous setting for maximum threads.</p>
</dd></dl>

<dl class="function">
<dt id="tables.print_versions">
<tt class="descclassname">tables.</tt><tt class="descname">print_versions</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.print_versions" title="Permalink to this definition">¶</a></dt>
<dd><p>Print all the versions of software that PyTables relies on.</p>
</dd></dl>

<dl class="function">
<dt id="tables.restrict_flavors">
<tt class="descclassname">tables.</tt><tt class="descname">restrict_flavors</tt><big>(</big><em>keep=['python']</em><big>)</big><a class="headerlink" href="#tables.restrict_flavors" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable all flavors except those in keep.</p>
<p>Providing an empty keep sequence implies disabling all flavors (but the
internal one).  If the sequence is not specified, only optional flavors are
disabled.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Once you disable a flavor, it can not be enabled again.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="tables.split_type">
<tt class="descclassname">tables.</tt><tt class="descname">split_type</tt><big>(</big><em>type</em><big>)</big><a class="headerlink" href="#tables.split_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a PyTables type into a PyTables kind and an item size.</p>
<p>Returns a tuple of (kind, itemsize). If no item size is present in the type
(in the form of a precision), the returned item size is None:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
<span class="go">(&#39;int&#39;, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">)</span>
<span class="go">(&#39;string&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;int20&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: precision must be a multiple of 8</span>: <span class="n">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_type</span><span class="p">(</span><span class="s">&#39;foo bar&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: malformed type</span>: <span class="n">&#39;foo bar&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tables.test">
<tt class="descclassname">tables.</tt><tt class="descname">test</tt><big>(</big><em>verbose=False</em>, <em>heavy=False</em><big>)</big><a class="headerlink" href="#tables.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Run all the tests in the test suite.</p>
<p>If <em>verbose</em> is set, the test suite will emit messages with full
verbosity (not recommended unless you are looking into a certain
problem).</p>
<p>If <em>heavy</em> is set, the test suite will be run in <em>heavy</em> mode (you
should be careful with this because it can take a lot of time and
resources from your computer).</p>
<p>Return 0 (os.EX_OK) if all tests pass, 1 in case of failure</p>
</dd></dl>

<dl class="function">
<dt id="tables.whichLibVersion">
<tt class="descclassname">tables.</tt><tt class="descname">whichLibVersion</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.whichLibVersion" title="Permalink to this definition">¶</a></dt>
<dd><p>Get version information about a C library.</p>
<p>If the library indicated by name is available, this function returns a
3-tuple containing the major library version as an integer, its full version
as a string, and the version date as a string. If the library is not
available, None is returned.</p>
<p>The currently supported library names are hdf5, zlib, lzo and bzip2. If
another name is given, a ValueError is raised.</p>
</dd></dl>

<dl class="function">
<dt id="tables.silenceHDF5Messages">
<tt class="descclassname">tables.</tt><tt class="descname">silenceHDF5Messages</tt><big>(</big><em>silence=True</em><big>)</big><a class="headerlink" href="#tables.silenceHDF5Messages" title="Permalink to this definition">¶</a></dt>
<dd><p>Silence (or re-enable) messages from the HDF5 C library.</p>
<p>The <em>silence</em> parameter can be used control the behaviour and reset
the standard HDF5 logging.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.4.</span></p>
</dd></dl>

</div>
</div>
<div class="section" id="the-file-class">
<span id="fileclassdescr"></span><h2>The File Class<a class="headerlink" href="#the-file-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.File">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">File</tt><big>(</big><em>filename</em>, <em>mode='r'</em>, <em>title=''</em>, <em>rootUEP='/'</em>, <em>filters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File" title="Permalink to this definition">¶</a></dt>
<dd><p>The in-memory representation of a PyTables file.</p>
<p>An instance of this class is returned when a PyTables file is
opened with the :func`tables.openFile` function. It offers methods to
manipulate (create, rename, delete...) nodes and handle their attributes,
as well as methods to traverse the object tree. The <em>user entry
point</em> to the object tree attached to the HDF5 file is
represented in the rootUEP attribute. Other
attributes are available.</p>
<p>File objects support an <em>Undo/Redo mechanism</em> which can be enabled with the
<a class="reference internal" href="#tables.File.enableUndo" title="tables.File.enableUndo"><tt class="xref py py-meth docutils literal"><span class="pre">File.enableUndo()</span></tt></a> method. Once the Undo/Redo mechanism is
enabled, explicit <em>marks</em> (with an optional unique
name) can be set on the state of the database using the
<a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>
method. There are two implicit marks which are always available: the
initial mark (0) and the final mark (-1).  Both the identifier of a
mark and its name can be used in <em>undo</em> and
<em>redo</em> operations.</p>
<p>Hierarchy manipulation operations (node creation, movement and
removal) and attribute handling operations (setting and deleting) made
after a mark can be undone by using the <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a> method, which
returns the database to the
state of a past mark. If undo() is not followed by
operations that modify the hierarchy or attributes, the
<a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> method can
be used to return the database to the state of a future mark. Else,
future states of the database are forgotten.</p>
<p>Note that data handling operations can not be undone nor redone
by now. Also, hierarchy manipulation operations on nodes that do not
support the Undo/Redo mechanism issue an
UndoRedoWarning <em>before</em>
changing the database.</p>
<p>The Undo/Redo mechanism is persistent between sessions and can
only be disabled by calling the <a class="reference internal" href="#tables.File.disableUndo" title="tables.File.disableUndo"><tt class="xref py py-meth docutils literal"><span class="pre">File.disableUndo()</span></tt></a> method.</p>
<p>File objects can also act as context managers when using the
with statement introduced in Python 2.5.  When
exiting a context, the file is automatically closed.</p>
<dl class="method">
<dt id="tables.File.__contains__">
<tt class="descname">__contains__</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#tables.File.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there a node with that path?</p>
<p>Returns True if the file has a node with the given path (a
string), False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__enter__">
<tt class="descname">__enter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a context and return the same file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__exit__">
<tt class="descname">__exit__</tt><big>(</big><em>*exc_info</em><big>)</big><a class="headerlink" href="#tables.File.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a context and close the file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over the nodes in the tree.</p>
<p>This is equivalent to calling <a class="reference internal" href="#tables.File.walkNodes" title="tables.File.walkNodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.walkNodes()</span></tt></a> with no arguments.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively list all the nodes in the object tree.</span>
<span class="n">h5file</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;vlarray1.h5&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;All nodes in the object tree:&quot;</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">node</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a detailed string representation of the object tree.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the object tree.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span>
<span class="go">data/test.h5 (File) &#39;Table Benchmark&#39;</span>
<span class="go">Last modif.: &#39;Mon Sep 20 12:40:47 2004&#39;</span>
<span class="go">Object Tree:</span>
<span class="go">/ (Group) &#39;Table Benchmark&#39;</span>
<span class="go">/tuple0 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0 (Group) &#39;&#39;</span>
<span class="go">/group0/tuple1 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0/group1 (Group) &#39;&#39;</span>
<span class="go">/group0/group1/tuple2 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0/group1/group2 (Group) &#39;&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all the alive leaves in object tree and close the file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.copyChildren">
<tt class="descname">copyChildren</tt><big>(</big><em>srcgroup</em>, <em>dstgroup</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copyChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the children of a group into another group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>srcgroup</strong> : str</p>
<blockquote>
<div><p>The group to copy from.</p>
</div></blockquote>
<p><strong>dstgroup</strong> : str</p>
<blockquote>
<div><p>The destination group.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the destination group will be overwritten if it already
exists.  Defaults to False.</p>
</div></blockquote>
<p><strong>recursive</strong> : bool, optional</p>
<blockquote>
<div><p>If True, all descendant nodes of srcgroup are recursively copied.
Defaults to False.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>If True, any necessary parents of dstgroup will be created.
Defaults to False.</p>
</div></blockquote>
<p><strong>kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Additional keyword arguments can be used to customize the copying
process.  See the documentation of <a class="reference internal" href="#tables.Group._f_copyChildren" title="tables.Group._f_copyChildren"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_copyChildren()</span></tt></a>
for a description of those arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.copyFile">
<tt class="descname">copyFile</tt><big>(</big><em>dstfilename</em>, <em>overwrite=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copyFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the contents of this file to dstfilename.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>dstfilename</strong> : str</p>
<blockquote>
<div><p>A path string indicating the name of the destination file. If
it already exists, the copy will fail with an IOError, unless
the overwrite argument is true.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool, optional</p>
<blockquote>
<div><p>If true, the destination file will be overwritten if it already
exists.  In this case, the destination file must be closed, or
errors will occur.  Defaults to False.</p>
</div></blockquote>
<p><strong>kwargs</strong> :</p>
<blockquote class="last">
<div><p>Additional keyword arguments discussed below.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Additional keyword arguments may be passed to customize the
copying process. For instance, title and filters may be changed,
user attributes may be or may not be copied, data may be
sub-sampled, stats may be collected, etc. Arguments unknown to
nodes are simply ignored. Check the documentation for copying
operations of nodes to see which options they support.</p>
<p>In addition, it recognizes the names of parameters present
in <tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt> as additional keyword
arguments.  See <a class="reference internal" href="parameter_files.html#parameter-files"><em>PyTables parameter files</em></a> for a
detailed info on the supported parameters.</p>
<p>Copying a file usually has the beneficial side effect of
creating a more compact and cleaner version of the original
file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.copyNode">
<tt class="descname">copyNode</tt><big>(</big><em>where</em>, <em>newparent=None</em>, <em>newname=None</em>, <em>name=None</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copyNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the node specified by where and name to newparent/newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted
upon.</p>
</div></blockquote>
<p><strong>newparent</strong> : str or Group</p>
<blockquote>
<div><p>The destination group that the node will be copied
into (a path name or a Group
instance). If not specified or None, the
current parent group is chosen as the new parent.</p>
</div></blockquote>
<p><strong>newname</strong> : str</p>
<blockquote>
<div><p>The name to be assigned to the new copy in its
destination (a string).  If it is not specified or
None, the current name is chosen as the
new name.</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted
upon.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the destination group will be overwritten if it already
exists.  Defaults to False.</p>
</div></blockquote>
<p><strong>recursive</strong> : bool, optional</p>
<blockquote>
<div><p>If True, all descendant nodes of srcgroup are recursively copied.
Defaults to False.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>If True, any necessary parents of dstgroup will be created.
Defaults to False.</p>
</div></blockquote>
<p><strong>kwargs</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments can be used to customize the copying
process.  See the documentation of <a class="reference internal" href="#tables.Group._f_copy" title="tables.Group._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_copy()</span></tt></a>
for a description of those arguments.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>node</strong> : Node</p>
<blockquote class="last">
<div><p>The newly created copy of the source node (i.e. the destination
node).  See <a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a> for further details on the
semantics of copying nodes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.copyNodeAttrs">
<tt class="descname">copyNodeAttrs</tt><big>(</big><em>where</em>, <em>dstnode</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.copyNodeAttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy PyTables attributes from one node to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in <a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>dstnode</strong> :</p>
<blockquote class="last">
<div><p>The destination node where the attributes will be copied to. It can
be a path string or a Node instance (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.createArray">
<tt class="descname">createArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>object</em>, <em>title=''</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>object</strong> : python object</p>
<blockquote>
<div><p>The array or scalar to be saved.  Accepted types are NumPy arrays
and scalars, numarray arrays and string arrays (deprecated),
Numeric arrays and scalars (deprecated), as well as native Python
sequences and scalars, provided that values are regular (i.e. they
are not like [[1,2],2]) and homogeneous (i.e. all the elements are
of the same type).  Also, objects that have some of their
dimensions equal to 0 are not supported (use an EArray node (see
<a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>) if you want to store an array with one of
its dimensions equal to 0).</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;.  If this is not specified, the byteorder is that of the
given object.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>..seealso::</strong> :</p>
<blockquote>
<div><p>see <a class="reference internal" href="#tables.File.createTable" title="tables.File.createTable"><tt class="xref py py-meth docutils literal"><span class="pre">File.createTable()</span></tt></a> for more information on the rest
of parameters.</p>
</div></blockquote>
<p><strong>.. seealso::</strong> :</p>
<blockquote class="last">
<div><p>see the Array class (in <a class="reference internal" href="#arrayclassdescr"><em>The Array class</em></a>) for more
information on arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.createCArray">
<tt class="descname">createCArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom</em>, <em>shape</em>, <em>title=''</em>, <em>filters=None</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createCArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new chunked array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing the
<em>type</em> and <em>shape</em> of the atomic objects to be saved.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>The shape of the new array.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters, optional</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) that
provides information about the desired I/O filters to be applied
during the life of this object.</p>
</div></blockquote>
<p><strong>chunkshape</strong> : tuple or number or None, optional</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a single HDF5
I/O operation.  Filters are applied to those chunks of data.  The
dimensionality of chunkshape must be the same as that of shape.  If
None, a sensible value is calculated (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str, optional</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;.  If this is not specified, the byteorder is that of the
given object.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>.. seealso::</strong> :</p>
<blockquote class="last">
<div><p>see the CArray class (in <a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>) for more
information on chunked arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.createEArray">
<tt class="descname">createEArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom</em>, <em>shape</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=1000</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createEArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new enlargeable array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing the
<em>type</em> and <em>shape</em> of the atomic objects to be saved.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>The shape of the new array.  One (and only one) of the shape
dimensions <em>must</em> be 0.  The dimension being 0 means that the
resulting EArray object can be extended along it.  Multiple
enlargeable dimensions are not supported right now.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>expectedrows</strong> : int, optional</p>
<blockquote>
<div><p>A user estimate about the number of row elements that will be added
to the growable dimension in the EArray node.  If not provided, the
default value is EXPECTED_ROWS_EARRAY (see tables/parameters.py).
If you plan to create either a much smaller or a much bigger array
try providing a guess; this will optimize the HDF5 B-Tree creation
and management process time and the amount of memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> : tuple, numeric, or None, optional</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a single HDF5
I/O operation.  Filters are applied to those chunks of data.  The
dimensionality of chunkshape must be the same as that of shape
(beware: no dimension should be 0 this time!).  If None, a sensible
value is calculated based on the expectedrows parameter (which is
recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str, optional</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;. If this is not specified, the byteorder is that of the
platform.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>..seealso::</strong> :</p>
<blockquote class="last">
<div><p>See the EArray (in <a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>) class for more
information on enlargeable arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.createExternalLink">
<tt class="descname">createExternalLink</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em>, <em>warn16incompat=True</em><big>)</big><a class="headerlink" href="#tables.File.createExternalLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an external link.</p>
<p>Create an external link to a <em>target</em> node with the given <em>name</em>
in <em>where</em> location.  <em>target</em> can be a node object in another
file or a path string in the form &#8216;<a class="reference external" href="file:/path/to/node">file:/path/to/node</a>&#8216;.  If
<em>createparents</em> is true, the intermediate groups required for
reaching <em>where</em> are created (the default is not doing so).</p>
<p>The returned node is an <tt class="xref py py-class docutils literal"><span class="pre">ExternalLink</span></tt> instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <em>warn16incompat</em> argument is deprecated since version 2.4.
It will be ignored.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.createGroup">
<tt class="descname">createGroup</tt><big>(</big><em>where</em>, <em>name</em>, <em>title=''</em>, <em>filters=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new group will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new group.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>)
that provides information about the desired I/O filters applicable
to the leaves that hang directly from this new group (unless other
filter properties are specified for these leaves). Besides, if you
do not specify filter properties for its child groups, they will
inherit these ones.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent
path to exist (not done by default).</p>
</div></blockquote>
<p><strong>.. seealso::</strong> :</p>
<blockquote class="last">
<div><p>the Group Class(in <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) for more information
on groups.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.createHardLink">
<tt class="descname">createHardLink</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createHardLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hard link to a <cite>target</cite> node with the given <cite>name</cite> in
<cite>where</cite> location.  <cite>target</cite> can be a node object or a path
string.  If <cite>createparents</cite> is true, the intermediate groups
required for reaching <cite>where</cite> are created (the default is not
doing so).</p>
<p>The returned node is a regular <cite>Group</cite> or <cite>Leaf</cite> instance.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createSoftLink">
<tt class="descname">createSoftLink</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createSoftLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a soft link (aka symbolic link) to a <cite>target</cite> node with
the given <cite>name</cite> in <cite>where</cite> location.  <cite>target</cite> can be a node
object or a path string.  If <cite>createparents</cite> is true, the
intermediate groups required for reaching <cite>where</cite> are created
(the default is not doing so).</p>
<p>The returned node is a SoftLink instance.  See the SoftLink class
(in <a class="reference internal" href="#softlinkclassdescr"><em>The SoftLink class</em></a>) for more information on soft links.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.createTable">
<tt class="descname">createTable</tt><big>(</big><em>where</em>, <em>name</em>, <em>description</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=10000</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new table with the given name in where location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new table will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new table.</p>
</div></blockquote>
<p><strong>description</strong> : Description</p>
<blockquote>
<div><p>This is an object that describes the table, i.e. how
many columns it has, their names, types, shapes, etc.  It
can be any of the following:</p>
<blockquote>
<div><ul class="simple">
<li><em>A user-defined class</em>: This should inherit from the
IsDescription class (see <a class="reference internal" href="#isdescriptionclassdescr"><em>The IsDescription class</em></a>) where
table fields are specified.</li>
<li><em>A dictionary</em>: For example, when you do not know beforehand
which structure your table will have).</li>
<li><em>A Description instance</em>: You can use the description
attribute of another table to create a new one with the same
structure.</li>
<li><em>A NumPy dtype</em>: A completely general structured NumPy dtype.</li>
<li><em>A NumPy (structured) array instance</em>: The dtype of this
structured array will be used as the description.  Also, in
case the array has actual data, it will be injected into the
newly created table.</li>
<li><em>A RecArray instance (deprecated)</em>: Object from the numarray
package.  This does not give you the possibility to create a
nested table.  Array data is injected into the new table.</li>
<li><em>A NestedRecArray instance (deprecated)</em>: If you want to have
nested columns in your table and you are using numarray, you
can use this object. Array data is injected into the new
table.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute
on disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) that
provides information about the desired I/O filters to be applied
during the life of this object.</p>
</div></blockquote>
<p><strong>expectedrows</strong> : int</p>
<blockquote>
<div><p>A user estimate of the number of records that will be in the table.
If not provided, the default value is EXPECTED_ROWS_TABLE (see
<tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt>). If you plan to create a bigger table
try providing a guess; this will optimize the HDF5 B-Tree creation
and management process time and memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a single HDF5
I/O operation. Filters are applied to those chunks of data. The rank
of the chunkshape for tables must be 1. If None, a sensible value
is calculated based on the expectedrows parameter (which is
recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str</p>
<blockquote>
<div><p>The byteorder of data <em>on disk</em>, specified as &#8216;little&#8217; or &#8216;big&#8217;.
If this is not specified, the byteorder is that of the platform,
unless you passed an array as the description, in which case
its byteorder will be used.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>.. seealso::</strong> :</p>
<blockquote class="last">
<div><p>see the Table (in <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>) class for more
information on tables.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.createVLArray">
<tt class="descname">createVLArray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedsizeinMB=1.0</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.createVLArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable-length array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing the
<em>type</em> and <em>shape</em> of the atomic objects to be saved.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) that
provides information about the desired I/O filters to be applied
during the life of this object.</p>
</div></blockquote>
<p><strong>expectedsizeinMB</strong> : int, optional</p>
<blockquote>
<div><p>An user estimate about the size (in MB) in the final VLArray
node. If not provided, the default value is 1 MB. If you plan to
create either a much smaller or a much bigger array try providing a
guess; this will optimize the HDF5 B-Tree creation and management
process time and the amount of memory used. If you want to specify
your own chunk size for I/O purposes, see also the chunkshape
parameter below.</p>
</div></blockquote>
<p><strong>chunkshape</strong> : int or tuple of int, optional</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a single HDF5
I/O operation. Filters are applied to those chunks of data. The
dimensionality of chunkshape must be 1. If None, a sensible value
is calculated (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str, optional</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;. If this is not specified, the byteorder is that of the
platform.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>.. seealso::</strong> :</p>
<blockquote class="last">
<div><p>see the VLArray (in <a class="reference internal" href="#vlarrayclassdescr"><em>The VLArray class</em></a>) class for more
informationon variable-length arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.delNodeAttr">
<tt class="descname">delNodeAttr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.delNodeAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute from the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in <a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote class="last">
<div><p>The name of the attribute to delete.  If the named
attribute does not exist, an AttributeError is raised.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.disableUndo">
<tt class="descname">disableUndo</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.disableUndo" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the Undo/Redo mechanism.</p>
<p>Disabling the Undo/Redo mechanism leaves the database in the
current state and forgets past and future database states. This
makes <a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>, <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>, <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> and other
methods fail with an UndoRedoError.</p>
<p>Calling this method when the Undo/Redo mechanism is already
disabled raises an UndoRedoError.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.enableUndo">
<tt class="descname">enableUndo</tt><big>(</big><em>filters=Filters(complevel=1</em>, <em>complib='zlib'</em>, <em>shuffle=True</em>, <em>fletcher32=False)</em><big>)</big><a class="headerlink" href="#tables.File.enableUndo" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the Undo/Redo mechanism.</p>
<p>This operation prepares the database for undoing and redoing
modifications in the node hierarchy. This
allows <a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>, <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>, <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> and
other methods to be called.</p>
<p>The filters argument, when specified,
must be an instance of class Filters (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>) and
is meant for setting the compression values for the action log. The
default is having compression enabled, as the gains in terms of
space can be considerable. You may want to disable compression if
you want maximum speed for Undo/Redo operations.</p>
<p>Calling this method when the Undo/Redo mechanism is already
enabled raises an UndoRedoError.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.flush">
<tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all the alive leaves in the object tree.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.getCurrentMark">
<tt class="descname">getCurrentMark</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.getCurrentMark" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the identifier of the current mark.</p>
<p>Returns the identifier of the current mark. This can be used
to know the state of a database after an application crash, or to
get the identifier of the initial implicit mark after a call
to <a class="reference internal" href="#tables.File.enableUndo" title="tables.File.enableUndo"><tt class="xref py py-meth docutils literal"><span class="pre">File.enableUndo()</span></tt></a>.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.getNode">
<tt class="descname">getNode</tt><big>(</big><em>where</em>, <em>name=None</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.getNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the node under where with the given name.</p>
<p>where can be a Node instance (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) or a path
string leading to a node. If no name is specified, that node is returned.</p>
<p>If a name is specified, this must be a string with the name of a node
under where.  In this case the where argument can only lead to a
Group (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) instance (else a TypeError is
raised). The node called name under the group where is returned.</p>
<p>In both cases, if the node to be returned does not exist, a
NoSuchNodeError is raised. Please note that hidden nodes are also
considered.</p>
<p>If the classname argument is specified, it must be the name of a class
derived from Node. If the node is found but it is not an
instance of that class, a NoSuchNodeError is also raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.getNodeAttr">
<tt class="descname">getNodeAttr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.getNodeAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PyTables attribute from the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in <a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote class="last">
<div><p>The name of the attribute to retrieve.  If the named
attribute does not exist, an AttributeError is raised.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.goto">
<tt class="descname">goto</tt><big>(</big><em>mark</em><big>)</big><a class="headerlink" href="#tables.File.goto" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a specific mark of the database.</p>
<p>Returns the database to the state associated with the specified mark.
Both the identifier of a mark and its name can be used.</p>
<p>This method can only be called when the Undo/Redo mechanism has been
enabled. Otherwise, an UndoRedoError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.isUndoEnabled">
<tt class="descname">isUndoEnabled</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.isUndoEnabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the Undo/Redo mechanism enabled?</p>
<p>Returns True if the Undo/Redo mechanism has been enabled for this file,
False otherwise. Please note that this mechanism is persistent, so a
newly opened PyTables file may already have Undo/Redo support enabled.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.isVisibleNode">
<tt class="descname">isVisibleNode</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#tables.File.isVisibleNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the node under <cite>path</cite> visible?</p>
<p>If the node does not exist, a NoSuchNodeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.iterNodes">
<tt class="descname">iterNodes</tt><big>(</big><em>where</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.iterNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over children nodes hanging from where.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> :</p>
<blockquote>
<div><p>This argument works as in <a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>classname</strong> :</p>
<blockquote class="last">
<div><p>If the name of a class derived from
Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) is supplied, only instances of
that class (or subclasses of it) will be returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The returned nodes are alphanumerically sorted by their
name.  This is an iterator version of <a class="reference internal" href="#tables.File.listNodes" title="tables.File.listNodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.listNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.listNodes">
<tt class="descname">listNodes</tt><big>(</big><em>where</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.listNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <em>list</em> with children nodes hanging from where.</p>
<p>This is a list-returning version of <a class="reference internal" href="#tables.File.iterNodes" title="tables.File.iterNodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.iterNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.mark">
<tt class="descname">mark</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the state of the database.</p>
<p>Creates a mark for the current state of the database. A unique (and
immutable) identifier for the mark is returned. An optional name (a
string) can be assigned to the mark. Both the identifier of a mark and
its name can be used in <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a> and <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a>
operations. When the name has already been used for another mark,
an UndoRedoError is raised.</p>
<p>This method can only be called when the Undo/Redo mechanism has been
enabled. Otherwise, an UndoRedoError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.moveNode">
<tt class="descname">moveNode</tt><big>(</big><em>where</em>, <em>newparent=None</em>, <em>newname=None</em>, <em>name=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.moveNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the node specified by where and name to newparent/newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> : path</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>newparent</strong> :</p>
<blockquote>
<div><p>The destination group the node will be moved into (a
path name or a Group instance). If it is
not specified or None, the current parent
group is chosen as the new parent.</p>
</div></blockquote>
<p><strong>newname</strong> :</p>
<blockquote class="last">
<div><p>The new name to be assigned to the node in its
destination (a string). If it is not specified or
None, the current name is chosen as the
new name.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The other arguments work as in <a class="reference internal" href="#tables.Node._f_move" title="tables.Node._f_move"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_move()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.redo">
<tt class="descname">redo</tt><big>(</big><em>mark=None</em><big>)</big><a class="headerlink" href="#tables.File.redo" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a future state of the database.</p>
<p>Returns the database to the state associated with the specified
mark.  Both the identifier of a mark and its name can be used.
If the <cite>mark</cite> is omitted, the next created mark is used.  If
there are no future marks, or the specified mark is not newer
than the current one, an UndoRedoError is raised.</p>
<p>This method can only be called when the Undo/Redo mechanism has
been enabled.  Otherwise, an UndoRedoError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.removeNode">
<tt class="descname">removeNode</tt><big>(</big><em>where</em>, <em>name=None</em>, <em>recursive=False</em><big>)</big><a class="headerlink" href="#tables.File.removeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the object node <em>name</em> under <em>where</em> location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>recursive</strong> : bool</p>
<blockquote class="last">
<div><p>If not supplied or false, the node will be removed
only if it has no children; if it does, a
NodeError will be raised. If supplied
with a true value, the node and all its descendants will be
completely removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.renameNode">
<tt class="descname">renameNode</tt><big>(</big><em>where</em>, <em>newname</em>, <em>name=None</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#tables.File.renameNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the name of the node specified by where and name to newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>newname</strong> : str</p>
<blockquote>
<div><p>The new name to be assigned to the node (a string).</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool</p>
<blockquote class="last">
<div><p>Whether to recursively remove a node with the same
newname if it already exists (not done by default).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.setNodeAttr">
<tt class="descname">setNodeAttr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>attrvalue</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.setNodeAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute for the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote>
<div><p>The name of the attribute to set.</p>
</div></blockquote>
<p><strong>attrvalue</strong> :</p>
<blockquote class="last">
<div><p>The value of the attribute to set. Any kind of Python
object (like strings, ints, floats, lists, tuples, dicts,
small NumPy/Numeric/numarray objects...) can be stored as an
attribute. However, if necessary, cPickle
is automatically used so as to serialize objects that you
might want to save. See the AttributeSet
class (in <a class="reference internal" href="#attributesetclassdescr"><em>The AttributeSet class</em></a>) for details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the node already has a large number of attributes, a
PerformanceWarning is issued.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.undo">
<tt class="descname">undo</tt><big>(</big><em>mark=None</em><big>)</big><a class="headerlink" href="#tables.File.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a past state of the database.</p>
<p>Returns the database to the state associated with the specified mark.
Both the identifier of a mark and its name can be used. If the mark is
omitted, the last created mark is used. If there are no past
marks, or the specified mark is not older than the current one, an
UndoRedoError is raised.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.walkGroups">
<tt class="descname">walkGroups</tt><big>(</big><em>where='/'</em><big>)</big><a class="headerlink" href="#tables.File.walkGroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over groups (not leaves) hanging from where.</p>
<p>The where group itself is listed first (preorder), then each of its
child groups (following an alphanumerical order) is also traversed,
following the same procedure.  If where is not supplied, the root
group is used.</p>
<p>The where argument can be a path string
or a Group instance (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.walkNodes">
<tt class="descname">walkNodes</tt><big>(</big><em>where='/'</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.walkNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over nodes hanging from where.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group, optional</p>
<blockquote>
<div><p>If supplied, the iteration starts from (and includes)
this group. It can be a path string or a
Group instance (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>classname</strong> :</p>
<blockquote class="last">
<div><p>If the name of a class derived from
Node (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) is supplied, only instances of
that class (or subclasses of it) will be returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This version iterates over the leaves in the same group in order
to avoid having a list referencing to them and thus, preventing
the LRU cache to remove them after their use.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively print all the nodes hanging from &#39;/detector&#39;.</span>
<span class="k">print</span> <span class="s">&quot;Nodes hanging from group &#39;/detector&#39;:&quot;</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">walkNodes</span><span class="p">(</span><span class="s">&#39;/detector&#39;</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="s">&#39;EArray&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">node</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.File.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.filename">
<tt class="descname">filename</tt><em class="property"> = None</em><a class="headerlink" href="#tables.File.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the opened file.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.filters">
<tt class="descname">filters</tt><a class="headerlink" href="#tables.File.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Default filter properties for the root group (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.format_version">
<tt class="descname">format_version</tt><em class="property"> = None</em><a class="headerlink" href="#tables.File.format_version" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables version number of this file.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.isopen">
<tt class="descname">isopen</tt><em class="property"> = None</em><a class="headerlink" href="#tables.File.isopen" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the underlying file os open, False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.mode">
<tt class="descname">mode</tt><em class="property"> = None</em><a class="headerlink" href="#tables.File.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The mode in which the file was opened</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.open_count">
<tt class="descname">open_count</tt><a class="headerlink" href="#tables.File.open_count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of times this file has been opened currently.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.root">
<tt class="descname">root</tt><em class="property"> = None</em><a class="headerlink" href="#tables.File.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>root</em> of the object tree hierarchy (a Group instance).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.title">
<tt class="descname">title</tt><a class="headerlink" href="#tables.File.title" title="Permalink to this definition">¶</a></dt>
<dd><p>The title of the root group in the file.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-node-class">
<span id="nodeclassdescr"></span><h2>The Node class<a class="headerlink" href="#the-node-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Node">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Node</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>_log=True</em><big>)</big><a class="headerlink" href="#tables.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for all PyTables nodes.</p>
<p>This is the base class for <em>all</em> nodes in a PyTables hierarchy. It is an
abstract class, i.e. it may not be directly instantiated; however, every
node in the hierarchy is an instance of this class.</p>
<p>A PyTables node is always hosted in a PyTables <em>file</em>, under a <em>parent
group</em>, at a certain <em>depth</em> in the node hierarchy. A node knows its own
<em>name</em> in the parent group and its own <em>path name</em> in the file.</p>
<p>All the previous information is location-dependent, i.e. it may change when
moving or renaming a node in the hierarchy. A node also has
location-independent information, such as its <em>HDF5 object identifier</em> and
its <em>attribute set</em>.</p>
<p>This class gathers the operations and attributes (both location-dependent
and independent) which are common to all PyTables nodes, whatever their
type is. Nonetheless, due to natural naming restrictions, the names of all
of these members start with a reserved prefix (see the Group class
in <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
<p>Sub-classes with no children (e.g. <em>leaf nodes</em>) may define new methods,
attributes and properties to avoid natural naming restrictions. For
instance, _v_attrs may be shortened to attrs and _f_rename to
rename. However, the original methods and attributes should still be
available.</p>
<dl class="attribute">
<dt id="tables.Node._AttributeSet">
<tt class="descname">_AttributeSet</tt><a class="headerlink" href="#tables.Node._AttributeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">AttributeSet</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_close">
<tt class="descname">_f_close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._f_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this node in the tree.</p>
<p>This releases all resources held by the node, so it should not
be used again.  On nodes with data, it may be flushed to disk.</p>
<p>You should not need to close nodes manually because they are
automatically opened/closed when they are loaded/evicted from
the integrated LRU cache.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_copy">
<tt class="descname">_f_copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Node._f_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node and return the new node.</p>
<p>Creates and returns a copy of the node, maybe in a different place in
the hierarchy. newparent can be a Group object (see
<a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) or a pathname in string form. If it is not
specified or None, the current parent group is chosen as the new
parent.  newname must be a string with a new name. If it is not
specified or None, the current name is chosen as the new name. If
recursive copy is stated, all descendants are copied as well. If
createparents is true, the needed groups for the given new parent group
path to exist will be created.</p>
<p>Copying a node across databases is supported but can not be
undone. Copying a node over itself is not allowed, nor it is
recursively copying a node into itself. These result in a
NodeError. Copying over another existing node is similarly not allowed,
unless the optional overwrite argument is true, in which case that node
is recursively removed before copying.</p>
<p>Additional keyword arguments may be passed to customize the copying
process. For instance, title and filters may be changed, user
attributes may be or may not be copied, data may be sub-sampled, stats
may be collected, etc. See the documentation for the particular node
type.</p>
<p>Using only the first argument is equivalent to copying the node to a
new location without changing its name. Using only the second argument
is equivalent to making a copy of the node in the same group.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_delAttr">
<tt class="descname">_f_delAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Node._f_delAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute from this node.</p>
<p>If the named attribute does not exist, an AttributeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_getAttr">
<tt class="descname">_f_getAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Node._f_getAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PyTables attribute from this node.</p>
<p>If the named attribute does not exist, an AttributeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_isVisible">
<tt class="descname">_f_isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._f_isVisible" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this node visible?</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_move">
<tt class="descname">_f_move</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.Node._f_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move or rename this node.</p>
<p>Moves a node into a new parent group, or changes the name of the
node. newparent can be a Group object (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) or a
pathname in string form. If it is not specified or None, the current
parent group is chosen as the new parent.  newname must be a string
with a new name. If it is not specified or None, the current name is
chosen as the new name. If createparents is true, the needed groups for
the given new parent group path to exist will be created.</p>
<p>Moving a node across databases is not allowed, nor it is moving a node
<em>into</em> itself. These result in a NodeError. However, moving a node
<em>over</em> itself is allowed and simply does nothing. Moving over another
existing node is similarly not allowed, unless the optional overwrite
argument is true, in which case that node is recursively removed before
moving.</p>
<p>Usually, only the first argument will be used, effectively moving the
node to a new location without changing its name.  Using only the
second argument is equivalent to renaming the node in place.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_remove">
<tt class="descname">_f_remove</tt><big>(</big><em>recursive=False</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#tables.Node._f_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this node from the hierarchy.</p>
<p>If the node has children, recursive removal must be stated by giving
recursive a true value; otherwise, a NodeError will be raised.</p>
<p>If the node is a link to a Group object, and you are sure that you want
to delete it, you can do this by setting the force flag to true.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_rename">
<tt class="descname">_f_rename</tt><big>(</big><em>newname</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#tables.Node._f_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node in place.</p>
<p>Changes the name of a node to <em>newname</em> (a string).  If a node with the
same newname already exists and overwrite is true, recursively remove
it before renaming.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._f_setAttr">
<tt class="descname">_f_setAttr</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Node._f_setAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute for this node.</p>
<p>If the node already has a large number of attributes, a
PerformanceWarning is issued.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_checkName">
<tt class="descname">_g_checkName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Node._g_checkName" title="Permalink to this definition">¶</a></dt>
<dd><p>Check validity of name for this particular kind of node.</p>
<p>This is invoked once the standard HDF5 and natural naming checks
have successfully passed.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_checkOpen">
<tt class="descname">_g_checkOpen</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_checkOpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the node is open.</p>
<p>If the node is closed, a <cite>ClosedNodeError</cite> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_copy">
<tt class="descname">_g_copy</tt><big>(</big><em>newParent</em>, <em>newName</em>, <em>recursive</em>, <em>_log=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Node._g_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node and return the new one.</p>
<p>Creates and returns a copy of the node in the given <cite>newParent</cite>,
with the given <cite>newName</cite>.  If <cite>recursive</cite> copy is stated, all
descendents are copied as well.  Additional keyword argumens may
affect the way that the copy is made.  Unknown arguments must be
ignored.  On recursive copies, all keyword arguments must be
passed on to the children invocation of this method.</p>
<p>If <cite>_log</cite> is false, the change is not logged.  This is <em>only</em>
intended to be used by <tt class="docutils literal"><span class="pre">_g_copyAsChild()</span></tt> as a means of
optimising sub-tree copies.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_copyAsChild">
<tt class="descname">_g_copyAsChild</tt><big>(</big><em>newParent</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Node._g_copyAsChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node as a child of another group.</p>
<p>Copies just this node into <cite>newParent</cite>, not recursing children
nor overwriting nodes nor logging the copy.  This is intended to
be used when copying whole sub-trees.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_create">
<tt class="descname">_g_create</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new HDF5 node and return its object identifier.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_delLocation">
<tt class="descname">_g_delLocation</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_delLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear location-dependent attributes.</p>
<p>This also triggers the removal of file references to this node.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_move">
<tt class="descname">_g_move</tt><big>(</big><em>newParent</em>, <em>newName</em><big>)</big><a class="headerlink" href="#tables.Node._g_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move this node in the hierarchy.</p>
<p>Moves the node into the given <cite>newParent</cite>, with the given
<cite>newName</cite>.</p>
<p>It does not log the change.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_open">
<tt class="descname">_g_open</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an existing HDF5 node and return its object identifier.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_postInitHook">
<tt class="descname">_g_postInitHook</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_postInitHook" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be run after node creation and before creation logging.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_postReviveHook">
<tt class="descname">_g_postReviveHook</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_postReviveHook" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be called after reviving the node.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_preKillHook">
<tt class="descname">_g_preKillHook</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_preKillHook" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be called before killing the node.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_remove">
<tt class="descname">_g_remove</tt><big>(</big><em>recursive</em>, <em>force</em><big>)</big><a class="headerlink" href="#tables.Node._g_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this node from the hierarchy.</p>
<p>If the node has children, recursive removal must be stated by
giving <cite>recursive</cite> a true value; otherwise, a <cite>NodeError</cite> will
be raised.</p>
<p>If <cite>force</cite> is set to true, the node will be removed no matter it
has children or not (useful for deleting hard links).</p>
<p>It does not log the change.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_setLocation">
<tt class="descname">_g_setLocation</tt><big>(</big><em>parentNode</em>, <em>name</em><big>)</big><a class="headerlink" href="#tables.Node._g_setLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Set location-dependent attributes.</p>
<p>Sets the location-dependent attributes of this node to reflect
that it is placed under the specified <cite>parentNode</cite>, with the
specified <cite>name</cite>.</p>
<p>This also triggers the insertion of file references to this
node.  If the maximum recommended tree depth is exceeded, a
<cite>PerformanceWarning</cite> is issued.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_updateDependent">
<tt class="descname">_g_updateDependent</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Node._g_updateDependent" title="Permalink to this definition">¶</a></dt>
<dd><p>Update dependent objects after a location change.</p>
<p>All dependent objects (but not nodes!) referencing this node
must be updated here.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Node._g_updateLocation">
<tt class="descname">_g_updateLocation</tt><big>(</big><em>newParentPath</em><big>)</big><a class="headerlink" href="#tables.Node._g_updateLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Update location-dependent attributes.</p>
<p>Updates location data when an ancestor node has changed its
location in the hierarchy to <cite>newParentPath</cite>.  In fact, this
method is expected to be called by an ancestor of this node.</p>
<p>This also triggers the update of file references to this node.
If the maximum recommended node depth is exceeded, a
<cite>PerformanceWarning</cite> is issued.  This warning is assured to be
unique.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_attrs">
<tt class="descname">_v_attrs</tt><a class="headerlink" href="#tables.Node._v_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated <cite>AttributeSet</cite> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_parent">
<tt class="descname">_v_parent</tt><a class="headerlink" href="#tables.Node._v_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent <cite>Group</cite> instance (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Node._v_title">
<tt class="descname">_v_title</tt><a class="headerlink" href="#tables.Node._v_title" title="Permalink to this definition">¶</a></dt>
<dd><p>A description of this node. A shorthand for TITLE attribute.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-group-class">
<span id="groupclassdescr"></span><h2>The Group class<a class="headerlink" href="#the-group-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Group">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Group</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>title=''</em>, <em>new=False</em>, <em>filters=None</em>, <em>_log=True</em><big>)</big><a class="headerlink" href="#tables.Group" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic PyTables grouping structure.</p>
<p>Instances of this class are grouping structures containing <em>child</em>
instances of zero or more groups or leaves, together with supporting
metadata. Each group has exactly one <em>parent</em> group.</p>
<p>Working with groups and leaves is similar in many ways to working with
directories and files, respectively, in a Unix filesystem. As with Unix
directories and files, objects in the object tree are often described by
giving their full (or absolute) path names. This full path can be specified
either as a string (like in &#8216;/group1/group2&#8217;) or as a complete object path
written in <em>natural naming</em> schema (like in file.root.group1.group2).</p>
<p>A collateral effect of the <em>natural naming</em> schema is that the names of
members in the Group class and its instances must be carefully chosen to
avoid colliding with existing children node names.  For this reason and to
avoid polluting the children namespace all members in a Group start with
some reserved prefix, like _f_ (for public methods), _g_ (for private
ones), _v_ (for instance variables) or _c_ (for class variables). Any
attempt to create a new child node whose name starts with one of these
prefixes will raise a ValueError exception.</p>
<p>Another effect of natural naming is that children named after Python
keywords or having names not valid as Python identifiers (e.g.  class, $a
or 44) can not be accessed using the node.child syntax. You will be forced
to use node._f_getChild(child) to access them (which is recommended for
programmatic accesses).</p>
<p>You will also need to use _f_getChild() to access an existing child node if
you set a Python attribute in the Group with the same name as that node
(you will get a NaturalNameWarning when doing this).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>title</strong> :</p>
<blockquote>
<div><p>The title for this group</p>
</div></blockquote>
<p><strong>new</strong> :</p>
<blockquote>
<div><p>If this group is new or has to be read from disk</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote class="last">
<div><p>A Filters instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The following documentation includes methods that are automatically called
when a Group instance is accessed in a special way.</p>
<p>For instance, this class defines the __setattr__, __getattr__, and
__delattr__ methods, and they set, get and delete <em>ordinary Python
attributes</em> as normally intended. In addition to that, __getattr__ allows
getting <em>child nodes</em> by their name for the sake of easy interaction on the
command line, as long as there is no Python attribute with the same
name. Groups also allow the interactive completion (when using readline) of
the names of child nodes. For instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># get a Python attribute</span>
<span class="n">nchild</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">_v_nchildren</span>

<span class="c"># Add a Table child called &#39;table&#39; under &#39;group&#39;.</span>
<span class="n">h5file</span><span class="o">.</span><span class="n">createTable</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s">&#39;table&#39;</span><span class="p">,</span> <span class="n">myDescription</span><span class="p">)</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>          <span class="c"># get the table child instance</span>
<span class="n">group</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="s">&#39;foo&#39;</span>          <span class="c"># set a Python attribute</span>

<span class="c"># (PyTables warns you here about using the name of a child node.)</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>            <span class="c"># get a Python attribute</span>
<span class="k">del</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>              <span class="c"># delete a Python attribute</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">table</span>          <span class="c"># get the table child instance again</span>
</pre></div>
</div>
<dl class="method">
<dt id="tables.Group.__contains__">
<tt class="descname">__contains__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there a child with that <cite>name</cite>?</p>
<p>Returns a true value if the group has a child node (visible or
hidden) with the given <cite>name</cite> (a string), false otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__delattr__">
<tt class="descname">__delattr__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a Python attribute called name.</p>
<p>This method deletes an <em>ordinary Python attribute</em> from the object. It
does <em>not</em> remove children nodes from this group; for that,
use <a class="reference internal" href="#tables.File.removeNode" title="tables.File.removeNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.removeNode()</span></tt></a> or <a class="reference internal" href="#tables.Node._f_remove" title="tables.Node._f_remove"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_remove()</span></tt></a>. It does <em>neither</em>
delete a PyTables node attribute; for that,
use <a class="reference internal" href="#tables.File.delNodeAttr" title="tables.File.delNodeAttr"><tt class="xref py py-meth docutils literal"><span class="pre">File.delNodeAttr()</span></tt></a>, <a class="reference internal" href="#tables.Node._f_delAttr" title="tables.Node._f_delAttr"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_delAttr()</span></tt></a>
or <tt class="xref py py-attr docutils literal"><span class="pre">Node._v_attrs`</span></tt>.</p>
<p>If there is an attribute and a child node with the same name, the child
node will be made accessible again via natural naming.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__getattr__">
<tt class="descname">__getattr__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Python attribute or child node called name.</p>
<p>If the object has a Python attribute called name, its value is
returned. Else, if the node has a child node called name, it is
returned.  Else, an AttributeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the child nodes hanging directly from the group.</p>
<p>This iterator is <em>not</em> recursive.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Non-recursively list all the nodes hanging from &#39;/detector&#39;</span>
<span class="k">print</span> <span class="s">&quot;Nodes in &#39;/detector&#39; group:&quot;</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">detector</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">node</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a detailed string representation of the group.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">group0</span>
<span class="go">/group0 (Group) &#39;First Group&#39;</span>
<span class="go">  children := [&#39;tuple1&#39; (Table), &#39;group1&#39; (Group)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__setattr__">
<tt class="descname">__setattr__</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Group.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a Python attribute called name with the given value.</p>
<p>This method stores an <em>ordinary Python attribute</em> in the object. It
does <em>not</em> store new children nodes under this group; for that, use the
File.create*() methods (see the File class
in <a class="reference internal" href="#fileclassdescr"><em>The File Class</em></a>). It does <em>neither</em> store a PyTables node
attribute; for that,
use <a class="reference internal" href="#tables.File.setNodeAttr" title="tables.File.setNodeAttr"><tt class="xref py py-meth docutils literal"><span class="pre">File.setNodeAttr()</span></tt></a>, :meth`:Node._f_setAttr`
or <a class="reference internal" href="#tables.Node._v_attrs" title="tables.Node._v_attrs"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_attrs</span></tt></a>.</p>
<p>If there is already a child node with the same name, a
NaturalNameWarning will be issued and the child node will not be
accessible via natural naming nor getattr(). It will still be available
via <a class="reference internal" href="#tables.File.getNode" title="tables.File.getNode"><tt class="xref py py-meth docutils literal"><span class="pre">File.getNode()</span></tt></a>, <a class="reference internal" href="#tables.Group._f_getChild" title="tables.Group._f_getChild"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_getChild()</span></tt></a> and children
dictionaries in the group (if visible).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the group.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">group0</span>
<span class="go">/group0 (Group) &#39;First Group&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_close">
<tt class="descname">_f_close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._f_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this group and all its descendents.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_close" title="tables.Node._f_close"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_close()</span></tt></a>.  It
should be noted that this operation closes all the nodes descending
from this group.</p>
<p>You should not need to close nodes manually because they are
automatically opened/closed when they are loaded/evicted from the
integrated LRU cache.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_copy">
<tt class="descname">_f_copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Group._f_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node and return the new one.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a>.
In addition, it recognizes the following keyword arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>title</strong> :</p>
<blockquote>
<div><p>The new title for the destination. If omitted or None, the original
title is used. This only applies to the topmost node in recursive
copies.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>Specifying this parameter overrides the original filter properties
in the source node. If specified, it must be an instance of the
Filters class (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>).
The default is to copy the filter properties from the source node.</p>
</div></blockquote>
<p><strong>copyuserattrs</strong> :</p>
<blockquote>
<div><p>You can prevent the user attributes from being copied by setting
thisparameter to False. The default is to copy them.</p>
</div></blockquote>
<p><strong>stats</strong> :</p>
<blockquote class="last">
<div><p>This argument may be used to collect statistics on the copy
process. When used, it should be a dictionary with keys &#8216;groups&#8217;,
&#8216;leaves&#8217;, &#8216;links&#8217; and &#8216;bytes&#8217; having a numeric value. Their values
willbe incremented to reflect the number of groups, leaves and
bytes, respectively, that have been copied during the operation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_copyChildren">
<tt class="descname">_f_copyChildren</tt><big>(</big><em>dstgroup</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Group._f_copyChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the children of this group into another group.</p>
<p>Children hanging directly from this group are copied into dstgroup,
which can be a Group (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>) object or its
pathname in string form. If createparents is true, the needed groups
for the given destination group path to exist will be created.</p>
<p>The operation will fail with a NodeError if there is a child node in
the destination group with the same name as one of the copied children
from this one, unless overwrite is true; in this case, the former child
node is recursively removed before copying the later.</p>
<p>By default, nodes descending from children groups of this node are not
copied. If the recursive argument is true, all descendant nodes of this
node are recursively copied.</p>
<p>Additional keyword arguments may be passed to customize the copying
process. For instance, title and filters may be changed, user
attributes may be or may not be copied, data may be sub-sampled, stats
may be collected, etc. Arguments unknown to nodes are simply
ignored. Check the documentation for copying operations of nodes to see
which options they support.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_flush">
<tt class="descname">_f_flush</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._f_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush this Group</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_getChild">
<tt class="descname">_f_getChild</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#tables.Group._f_getChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the child called childname of this group.</p>
<p>If the child exists (be it visible or not), it is returned.  Else, a
NoSuchNodeError is raised.</p>
<p>Using this method is recommended over getattr() when doing programmatic
accesses to children if childname is unknown beforehand or when its
name is not a valid Python identifier.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_iterNodes">
<tt class="descname">_f_iterNodes</tt><big>(</big><em>classname=None</em><big>)</big><a class="headerlink" href="#tables.Group._f_iterNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over children nodes.</p>
<p>Child nodes are yielded alphanumerically sorted by node name.  If the
name of a class derived from Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) is
supplied in the classname parameter, only instances of that class (or
subclasses of it) will be returned.</p>
<p>This is an iterator version of <a class="reference internal" href="#tables.Group._f_listNodes" title="tables.Group._f_listNodes"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_listNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_listNodes">
<tt class="descname">_f_listNodes</tt><big>(</big><em>classname=None</em><big>)</big><a class="headerlink" href="#tables.Group._f_listNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <em>list</em> with children nodes.</p>
<p>This is a list-returning version of <a class="reference internal" href="#tables.Group._f_iterNodes" title="tables.Group._f_iterNodes"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_iterNodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_walkGroups">
<tt class="descname">_f_walkGroups</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._f_walkGroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over descendent groups (not leaves).</p>
<p>This method starts by yielding <em>self</em>, and then it goes on to
recursively iterate over all child groups in alphanumerical order, top
to bottom (preorder), following the same procedure.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._f_walkNodes">
<tt class="descname">_f_walkNodes</tt><big>(</big><em>classname=None</em><big>)</big><a class="headerlink" href="#tables.Group._f_walkNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over descendant nodes.</p>
<p>This method recursively walks <em>self</em> top to bottom (preorder),
iterating over child groups in alphanumerical order, and yielding
nodes.  If classname is supplied, only instances of the named class are
yielded.</p>
<p>If <em>classname</em> is Group, it behaves like <a class="reference internal" href="#tables.Group._f_walkGroups" title="tables.Group._f_walkGroups"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_walkGroups()</span></tt></a>,
yielding only groups.  If you don&#8217;t want a recursive behavior,
use <a class="reference internal" href="#tables.Group._f_iterNodes" title="tables.Group._f_iterNodes"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_iterNodes()</span></tt></a> instead.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively print all the arrays hanging from &#39;/&#39;</span>
<span class="k">print</span> <span class="s">&quot;Arrays in the object tree &#39;/&#39;:&quot;</span>
<span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_f_walkNodes</span><span class="p">(</span><span class="s">&#39;Array&#39;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">array</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_addChildrenNames">
<tt class="descname">_g_addChildrenNames</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._g_addChildrenNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Add children names to this group taking into account their
visibility and kind.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_checkHasChild">
<tt class="descname">_g_checkHasChild</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group._g_checkHasChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether &#8216;name&#8217; is a children of &#8216;self&#8217; and return its type.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_close">
<tt class="descname">_g_close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._g_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this (open) group.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_closeDescendents">
<tt class="descname">_g_closeDescendents</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._g_closeDescendents" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all the <em>loaded</em> descendent nodes of this group.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_copyChildren">
<tt class="descname">_g_copyChildren</tt><big>(</big><em>newParent</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Group._g_copyChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy child nodes.</p>
<p>Copies all nodes descending from this one into the specified
<cite>newParent</cite>.  If the new parent has a child node with the same
name as one of the nodes in this group, the copy fails with a
<cite>NodeError</cite>, maybe resulting in a partial copy.  Nothing is
logged.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_getChildGroupClass">
<tt class="descname">_g_getChildGroupClass</tt><big>(</big><em>childName</em><big>)</big><a class="headerlink" href="#tables.Group._g_getChildGroupClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the class of a not-yet-loaded group child.</p>
<p><cite>childName</cite> must be the name of a <em>group</em> child.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_getChildLeafClass">
<tt class="descname">_g_getChildLeafClass</tt><big>(</big><em>childName</em>, <em>warn=True</em><big>)</big><a class="headerlink" href="#tables.Group._g_getChildLeafClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the class of a not-yet-loaded leaf child.</p>
<p><cite>childName</cite> must be the name of a <em>leaf</em> child.  If the child
belongs to an unknown kind of leaf, or if its kind can not be
guessed, <cite>UnImplemented</cite> will be returned and a warning will be
issued if <cite>warn</cite> is true.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_join">
<tt class="descname">_g_join</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Group._g_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to correctly concatenate a name child object
with the pathname of this group.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_refNode">
<tt class="descname">_g_refNode</tt><big>(</big><em>childNode</em>, <em>childName</em>, <em>validate=True</em><big>)</big><a class="headerlink" href="#tables.Group._g_refNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert references to a <cite>childNode</cite> via a <cite>childName</cite>.</p>
<p>Checks that the <cite>childName</cite> is valid and does not exist, then
creates references to the given <cite>childNode</cite> by that <cite>childName</cite>.
The validation of the name can be omitted by setting <cite>validate</cite>
to a false value (this may be useful for adding already existing
nodes to the tree).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_remove">
<tt class="descname">_g_remove</tt><big>(</big><em>recursive=False</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#tables.Group._g_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove (recursively if needed) the Group.</p>
<p>This version correctly handles both visible and hidden nodes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_unrefNode">
<tt class="descname">_g_unrefNode</tt><big>(</big><em>childName</em><big>)</big><a class="headerlink" href="#tables.Group._g_unrefNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove references to a node.</p>
<p>Removes all references to the named node.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Group._g_widthWarning">
<tt class="descname">_g_widthWarning</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Group._g_widthWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a <a class="reference internal" href="#tables.PerformanceWarning" title="tables.PerformanceWarning"><tt class="xref py py-exc docutils literal"><span class="pre">PerformanceWarning</span></tt></a> on too many children.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.Group.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_filters">
<tt class="descname">_v_filters</tt><a class="headerlink" href="#tables.Group._v_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Default filter properties for child nodes.</p>
<p>You can (and are encouraged to) use this property to get, set and
delete the FILTERS HDF5 attribute of the group, which stores a Filters
instance (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>). When the group has no such
attribute, a default Filters instance is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Group._v_nchildren">
<tt class="descname">_v_nchildren</tt><a class="headerlink" href="#tables.Group._v_nchildren" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of children hanging from this group.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-leaf-class">
<span id="leafclassdescr"></span><h2>The Leaf class<a class="headerlink" href="#the-leaf-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Leaf">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Leaf</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>new=False</em>, <em>filters=None</em>, <em>byteorder=None</em>, <em>_log=True</em><big>)</big><a class="headerlink" href="#tables.Leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for all PyTables leaves.</p>
<p>A leaf is a node (see the Node class in <a class="reference internal" href="#tables.Node" title="tables.Node"><tt class="xref py py-class docutils literal"><span class="pre">Node</span></tt></a>) which hangs from a
group (see the Group class in <a class="reference internal" href="#tables.Group" title="tables.Group"><tt class="xref py py-class docutils literal"><span class="pre">Group</span></tt></a>) but, unlike a group, it can
not have any further children below it (i.e. it is an end node).</p>
<p>This definition includes all nodes which contain actual data (datasets
handled by the Table - see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>, Array -
see <a class="reference internal" href="#arrayclassdescr"><em>The Array class</em></a>, CArray - see <a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>, EArray -
see <a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>, and VLArray - see <a class="reference internal" href="#vlarrayclassdescr"><em>The VLArray class</em></a>
classes) and unsupported nodes (the UnImplemented
class - <a class="reference internal" href="#unimplementedclassdescr"><em>The UnImplemented class</em></a>) these classes do in fact inherit
from Leaf.</p>
<dl class="method">
<dt id="tables.Leaf._calc_chunkshape">
<tt class="descname">_calc_chunkshape</tt><big>(</big><em>expectedrows</em>, <em>rowsize</em>, <em>itemsize</em><big>)</big><a class="headerlink" href="#tables.Leaf._calc_chunkshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the shape for the HDF5 chunk.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf._calc_nrowsinbuf">
<tt class="descname">_calc_nrowsinbuf</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf._calc_nrowsinbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of rows that fits on a PyTables buffer.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf._f_close">
<tt class="descname">_f_close</tt><big>(</big><em>flush=True</em><big>)</big><a class="headerlink" href="#tables.Leaf._f_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this node in the tree.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_close" title="tables.Node._f_close"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_close()</span></tt></a>.
Besides that, the optional argument flush tells whether to flush
pending data to disk or not before closing.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf._g_fix_byteorder_data">
<tt class="descname">_g_fix_byteorder_data</tt><big>(</big><em>data</em>, <em>dbyteorder</em><big>)</big><a class="headerlink" href="#tables.Leaf._g_fix_byteorder_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix the byteorder of data passed in constructors.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf._g_postInitHook">
<tt class="descname">_g_postInitHook</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf._g_postInitHook" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be run after node creation and before creation logging.</p>
<p>This method gets or sets the flavor of the leaf.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf._pointSelection">
<tt class="descname">_pointSelection</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Leaf._pointSelection" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a point-wise selection.</p>
<p><cite>key</cite> can be any of the following items:</p>
<ul class="simple">
<li>A boolean array with the same shape than self. Those positions
with True values will signal the coordinates to be returned.</li>
<li>A numpy array (or list or tuple) with the point coordinates.
This has to be a two-dimensional array of size len(self.shape)
by num_elements containing a list of of zero-based values
specifying the coordinates in the dataset of the selected
elements. The order of the element coordinates in the array
specifies the order in which the array elements are iterated
through when I/O is performed. Duplicate coordinate locations
are not checked for.</li>
</ul>
<p>Return the coordinates array.  If this is not possible, raise a
<cite>TypeError</cite> so that the next selection method can be tried out.</p>
<p>This is useful for whatever <cite>Leaf</cite> instance implementing a
point-wise selection.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.close">
<tt class="descname">close</tt><big>(</big><em>flush=True</em><big>)</big><a class="headerlink" href="#tables.Leaf.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this node in the tree.</p>
<p>This method is completely equivalent to <a class="reference internal" href="#tables.Leaf._f_close" title="tables.Leaf._f_close"><tt class="xref py py-meth docutils literal"><span class="pre">Leaf._f_close()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.copy">
<tt class="descname">copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Leaf.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this node and return the new one.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a>. Please
note that there is no recursive flag since leaves do not have child
nodes.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that unknown parameters passed to this method will be
ignored, so may want to double check the spelling of these
(i.e. if you write them incorrectly, they will most probably
be ignored).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>title</strong> :</p>
<blockquote>
<div><p>The new title for the destination. If omitted or None, the original
title is used.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>Specifying this parameter overrides the original filter properties
in the source node. If specified, it must be an instance of the
Filters class (see <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>). The default is to
copy the filter properties from the source node.</p>
</div></blockquote>
<p><strong>copyuserattrs</strong> :</p>
<blockquote>
<div><p>You can prevent the user attributes from being copied by setting
this parameter to False. The default is to copy them.</p>
</div></blockquote>
<p><strong>start, stop, step</strong> : int</p>
<blockquote>
<div><p>Specify the range of rows to be copied; the default is to copy all
the rows.</p>
</div></blockquote>
<p><strong>stats</strong> :</p>
<blockquote>
<div><p>This argument may be used to collect statistics on the copy
process. When used, it should be a dictionary with keys &#8216;groups&#8217;,
&#8216;leaves&#8217; and &#8216;bytes&#8217; having a numeric value. Their values will be
incremented to reflect the number of groups, leaves and bytes,
respectively, that have been copied during the operation.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote class="last">
<div><p>The chunkshape of the new leaf.  It supports a couple of special
values.  A value of keep means that the chunkshape will be the same
than original leaf (this is the default).  A value of auto means
that a new shape will be computed automatically in order to ensure
best performance when accessing the dataset through the main
dimension.  Any other value should be an integer or a tuple
matching the dimensions of the leaf.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.delAttr">
<tt class="descname">delAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Leaf.delAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute from this node.</p>
<p>This method has the behavior described in <tt class="xref py py-meth docutils literal"><span class="pre">Node_f_delAttr()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.flush">
<tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush pending data to disk.</p>
<p>Saves whatever remaining buffered data to disk. It also releases I/O
buffers, so if you are filling many datasets in the same PyTables
session, please call flush() extensively so as to help PyTables to keep
memory requirements low.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.getAttr">
<tt class="descname">getAttr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Leaf.getAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PyTables attribute from this node.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_getAttr" title="tables.Node._f_getAttr"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_getAttr()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.isVisible">
<tt class="descname">isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf.isVisible" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this node visible?</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_isVisible" title="tables.Node._f_isVisible"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_isVisible()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.move">
<tt class="descname">move</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.Leaf.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move or rename this node.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_move" title="tables.Node._f_move"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_move()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.remove">
<tt class="descname">remove</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Leaf.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this node from the hierarchy.</p>
<p>This method has the behavior described
in <a class="reference internal" href="#tables.Node._f_remove" title="tables.Node._f_remove"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_remove()</span></tt></a>. Please note that there is no recursive flag
since leaves do not have child nodes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.rename">
<tt class="descname">rename</tt><big>(</big><em>newname</em><big>)</big><a class="headerlink" href="#tables.Leaf.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node in place.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_rename" title="tables.Node._f_rename"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_rename()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.setAttr">
<tt class="descname">setAttr</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Leaf.setAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute for this node.</p>
<p>This method has the behavior described in <a class="reference internal" href="#tables.Node._f_setAttr" title="tables.Node._f_setAttr"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_setAttr()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Leaf.truncate">
<tt class="descname">truncate</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#tables.Leaf.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncate the main dimension to be size rows.</p>
<p>If the main dimension previously was larger than this size, the extra
data is lost.  If the main dimension previously was shorter, it is
extended, and the extended part is filled with the default values.</p>
<p>The truncation operation can only be applied to <em>enlargeable</em> datasets,
else a TypeError will be raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.attrs">
<tt class="descname">attrs</tt><a class="headerlink" href="#tables.Leaf.attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated AttributeSet instance - see <a class="reference internal" href="#attributesetclassdescr"><em>The AttributeSet class</em></a>
(This is an easier-to-write alias of <a class="reference internal" href="#tables.Node._v_attrs" title="tables.Node._v_attrs"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_attrs</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.byteorder">
<tt class="descname">byteorder</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Leaf.byteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>The byte ordering of the leaf data <em>on disk</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.chunkshape">
<tt class="descname">chunkshape</tt><a class="headerlink" href="#tables.Leaf.chunkshape" title="Permalink to this definition">¶</a></dt>
<dd><p>The HDF5 chunk size for chunked leaves (a tuple).</p>
<p>This is read-only because you cannot change the chunk size of a
leaf once it has been created.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.filters">
<tt class="descname">filters</tt><a class="headerlink" href="#tables.Leaf.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter properties for this leaf</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Filters in <a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.flavor">
<tt class="descname">flavor</tt><a class="headerlink" href="#tables.Leaf.flavor" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of data object read from this leaf.</p>
<p>It can be any of &#8216;numpy&#8217;, &#8216;numarray&#8217;, &#8216;numeric&#8217; or &#8216;python&#8217; (the set of
supported flavors depends on which packages you have installed on your
system).</p>
<p>You can (and are encouraged to) use this property to get, set and
delete the FLAVOR HDF5 attribute of the leaf. When the leaf has no such
attribute, the default flavor is used.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The &#8216;numarray&#8217; and &#8216;numeric&#8217; flavors are deprecated since
version 2.3. Support for these flavors will be removed in
future versions.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.maindim">
<tt class="descname">maindim</tt><a class="headerlink" href="#tables.Leaf.maindim" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension along which iterators work.</p>
<p>Its value is 0 (i.e. the first dimension) when the dataset is not
extendable, and self.extdim (where available) for extendable ones.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.name">
<tt class="descname">name</tt><a class="headerlink" href="#tables.Leaf.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this node in its parent group
(This is an easier-to-write alias of <tt class="xref py py-attr docutils literal"><span class="pre">Node._v_name</span></tt>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.ndim">
<tt class="descname">ndim</tt><a class="headerlink" href="#tables.Leaf.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dimensions of the leaf data.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.nrowsinbuf">
<tt class="descname">nrowsinbuf</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Leaf.nrowsinbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of rows that fits in internal input buffers.</p>
<p>You can change this to fine-tune the speed or memory
requirements of your application.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.objectID">
<tt class="descname">objectID</tt><a class="headerlink" href="#tables.Leaf.objectID" title="Permalink to this definition">¶</a></dt>
<dd><p>A node identifier, which may change from run to run.
(This is an easier-to-write alias of <tt class="xref py py-attr docutils literal"><span class="pre">Node._v_objectID</span></tt>)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.size_on_disk">
<tt class="descname">size_on_disk</tt><a class="headerlink" href="#tables.Leaf.size_on_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of this leaf&#8217;s data in bytes as it is stored on disk.  If the
data is compressed, this shows the compressed size.  In the case of
uncompressed, chunked data, this may be slightly larger than the amount
of data, due to partially filled chunks.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Leaf.title">
<tt class="descname">title</tt><a class="headerlink" href="#tables.Leaf.title" title="Permalink to this definition">¶</a></dt>
<dd><p>A description for this node
(This is an easier-to-write alias of <a class="reference internal" href="#tables.Node._v_title" title="tables.Node._v_title"><tt class="xref py py-attr docutils literal"><span class="pre">Node._v_title</span></tt></a>).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-table-class">
<span id="tableclassdescr"></span><h2>The Table class<a class="headerlink" href="#the-table-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Table">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Table</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>description=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=None</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>_log=True</em><big>)</big><a class="headerlink" href="#tables.Table" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents heterogeneous datasets in an HDF5 file.</p>
<p>Tables are leaves (see the Leaf class in <a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>) whose data
consists of a unidimensional sequence of <em>rows</em>, where each row contains
one or more <em>fields</em>.  Fields have an associated unique <em>name</em> and
<em>position</em>, with the first field having position 0.  All rows have the same
fields, which are arranged in <em>columns</em>.</p>
<p>Fields can have any type supported by the Col class (see
<a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>) and its descendants, which support multidimensional
data.  Moreover, a field can be <em>nested</em> (to an arbitrary depth), meaning
that it includes further fields inside.  A field named x inside a nested
field a in a table can be accessed as the field a/x (its <em>path name</em>) from
the table.</p>
<p>The structure of a table is declared by its description, which is made
available in the Table.description attribute (see
<em class="xref std std-ref">TableInstanceVariablesDescr</em>).</p>
<p>This class provides new methods to read, write and search table data
efficiently.  It also provides special Python methods to allow accessing
the table as a normal sequence or array (with extended slicing supported).</p>
<p>PyTables supports <em>in-kernel</em> searches working simultaneously on several
columns using complex conditions.  These are faster than selections using
Python expressions.  See the <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method for more
information on in-kernel searches.</p>
<p>Non-nested columns can be <em>indexed</em>.  Searching an indexed column can be
several times faster than searching a non-nested one.  Search methods
automatically take advantage of indexing where available.</p>
<p>When iterating a table, an object from the Row (see <a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>)
class is used.  This object allows to read and write data one row at a
time, as well as to perform queries which are not supported by in-kernel
syntax (at a much lower speed, of course).</p>
<p>Objects of this class support access to individual columns via <em>natural
naming</em> through the Table.cols accessor (see
<em class="xref std std-ref">TableInstanceVariablesDescr</em>).  Nested columns are mapped to Cols
instances, and non-nested ones to Column instances.  See the Column class
in <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a> for examples of this feature.</p>
<p>The instance variables below are provided in addition to those in Leaf (see
<a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>).  Please note that there are several col*
dictionaries to ease retrieving information about a column directly by its
path name, avoiding the need to walk through Table.description or
Table.cols.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>description</strong> :</p>
<blockquote>
<div><p>An IsDescription subclass or a dictionary where the keys are the field
names, and the values the type definitions. In addition, a pure NumPy
dtype is accepted.  And it can be also a recarray NumPy object,
RecArray numarray object or NestedRecArray. If None, the table metadata
is read from disk, else, it&#8217;s taken from previous parameters.</p>
</div></blockquote>
<p><strong>title</strong> :</p>
<blockquote>
<div><p>Sets a TITLE attribute on the HDF5 table entity.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class that provides information about the
desired I/O filters to be applied during the life of this object.</p>
</div></blockquote>
<p><strong>expectedrows</strong> :</p>
<blockquote>
<div><p>A user estimate about the number of rows that will be on table. If not
provided, the default value is <tt class="docutils literal"><span class="pre">EXPECTED_ROWS_TABLE</span></tt> (see
<tt class="docutils literal"><span class="pre">tables/parameters.py</span></tt>).  If you plan to save bigger tables, try
providing a guess; this will optimize the HDF5 B-Tree creation and
management process time and memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written as a single HDF5 I/O
operation. The filters are applied to those chunks of data. Its rank
for tables has to be 1.  If <tt class="docutils literal"><span class="pre">None</span></tt>, a sensible value is calculated
based on the <cite>expectedrows</cite> parameter (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> :</p>
<blockquote class="last">
<div><p>The byteorder of the data <em>on-disk</em>, specified as &#8216;little&#8217; or &#8216;big&#8217;. If
this is not specified, the byteorder is that of the platform, unless
you passed a recarray as the <cite>description</cite>, in which case the recarray
byteorder will be chosen.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tables.Table.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Table.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from the table.</p>
<p>If key argument is an integer, the corresponding table row is returned
as a record of the current flavor. If key is a slice, the range of rows
determined by it is returned as a structured array of the current
flavor.</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row coordinates, the set of rows
determined by it is returned.  Furthermore, if key is an array of
boolean values, only the coordinates where key is True are returned.
Note that for the latter to work it is necessary that key list would
contain exactly as many rows as the table has.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">record</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1000</span><span class="p">]]</span>   <span class="c"># only retrieves rows 4 and 1000</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="p">[[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="bp">True</span><span class="p">]]</span>
</pre></div>
</div>
<p>Those statements are equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">record</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">readCoordinates</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">1000</span><span class="p">])</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">readCoordinates</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
</pre></div>
</div>
<p>Here, you can see how indexing can be used as a shorthand for the
<a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a> and <a class="reference internal" href="#tables.Table.readCoordinates" title="tables.Table.readCoordinates"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readCoordinates()</span></tt></a> methods.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the table using a Row instance.</p>
<p>This is equivalent to calling <a class="reference internal" href="#tables.Table.iterrows" title="tables.Table.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.iterrows()</span></tt></a> with default
arguments, i.e. it iterates over <em>all the rows</em> in the table.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a></p>
</div>
<p class="rubric">Notes</p>
<p>This iterator can be nested (see <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> for an example).</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span>
                                        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Table.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>This provides column metainfo in addition to standard __str__</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Table.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row or a range of rows in the table.</p>
<p>It takes different actions depending on the type of the key parameter:
if it is an integer, the corresponding table row is set to value (a
record or sequence capable of being converted to the table
structure). If key is a slice, the row slice determined by it is set to
value (a record array or sequence capable of being converted to the
table structure).</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row coordinates, the set of rows
determined by it is set to value.  Furthermore, if key is an array of
boolean values, only the coordinates where key is True are set to
values from value.  Note that for the latter to work it is necessary
that key list would contain exactly as many rows as the table has.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Modify just one existing row</span>
<span class="n">table</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">456</span><span class="p">,</span><span class="s">&#39;db2&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">]</span>

<span class="c"># Modify two existing rows</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">457</span><span class="p">,</span><span class="s">&#39;db1&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="s">&#39;de2&#39;</span><span class="p">,</span><span class="mf">1.3</span><span class="p">]],</span>
                       <span class="n">formats</span><span class="o">=</span><span class="s">&#39;i4,a3,f8&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rows</span>             <span class="c"># modify a table slice</span>
<span class="n">table</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">rows</span>              <span class="c"># only modifies rows 1 and 3</span>
<span class="n">table</span><span class="p">[[</span><span class="bp">True</span><span class="p">,</span><span class="bp">False</span><span class="p">,</span><span class="bp">True</span><span class="p">]]</span> <span class="o">=</span> <span class="n">rows</span>  <span class="c"># only modifies rows 0 and 2</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">table</span><span class="o">.</span><span class="n">modifyRows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="p">[</span><span class="mi">456</span><span class="p">,</span><span class="s">&#39;db2&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">])</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">457</span><span class="p">,</span><span class="s">&#39;db1&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="s">&#39;de2&#39;</span><span class="p">,</span><span class="mf">1.3</span><span class="p">]],</span>
                       <span class="n">formats</span><span class="o">=</span><span class="s">&#39;i4,a3,f8&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyRows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyCoordinates</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">rows</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyCoordinates</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">],</span> <span class="n">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, you can see how indexing can be used as a shorthand for the
<a class="reference internal" href="#tables.Table.modifyRows" title="tables.Table.modifyRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyRows()</span></tt></a> and <a class="reference internal" href="#tables.Table.modifyCoordinates" title="tables.Table.modifyCoordinates"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyCoordinates()</span></tt></a> methods.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.append">
<tt class="descname">append</tt><big>(</big><em>rows</em><big>)</big><a class="headerlink" href="#tables.Table.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a sequence of rows to the end of the table.</p>
<p>The rows argument may be any object which can be converted to a record
array compliant with the table structure (otherwise, a ValueError is
raised).  This includes NumPy structured arrays, RecArray (depracated)
or NestedRecArray (deprecated) objects if numarray is available, lists
of tuples or array records, and a string or Python buffer.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">tables</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Particle</span><span class="p">(</span><span class="n">IsDescription</span><span class="p">):</span>
    <span class="n">name</span>        <span class="o">=</span> <span class="n">StringCol</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c"># 16-character String</span>
    <span class="n">lati</span>        <span class="o">=</span> <span class="n">IntCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>        <span class="c"># integer</span>
    <span class="n">longi</span>       <span class="o">=</span> <span class="n">IntCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># integer</span>
    <span class="n">pressure</span>    <span class="o">=</span> <span class="n">Float32Col</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>    <span class="c"># float  (single-precision)</span>
    <span class="n">temperature</span> <span class="o">=</span> <span class="n">FloatCol</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>      <span class="c"># double (double-precision)</span>

<span class="n">fileh</span> <span class="o">=</span> <span class="n">openFile</span><span class="p">(</span><span class="s">&#39;test4.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createTable</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;table&#39;</span><span class="p">,</span> <span class="n">Particle</span><span class="p">,</span> <span class="s">&quot;A table&quot;</span><span class="p">)</span>

<span class="c"># Append several rows in only one call</span>
<span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="s">&quot;Particle:     10&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
              <span class="p">(</span><span class="s">&quot;Particle:     11&quot;</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="o">*</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
              <span class="p">(</span><span class="s">&quot;Particle:     12&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Table.col">
<tt class="descname">col</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#tables.Table.col" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a column from the table.</p>
<p>If a column called name exists in the table, it is read and returned as
a NumPy object, or as a numarray object (depending on the flavor of the
table). If it does not exist, a KeyError is raised.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">narray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s">&#39;var2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>That statement is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">narray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="s">&#39;var2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here you can see how this method can be used as a shorthand for the
<a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.copy">
<tt class="descname">copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Table.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this table and return the new one.</p>
<p>This method has the behavior and keywords described in
<a class="reference internal" href="#tables.Leaf.copy" title="tables.Leaf.copy"><tt class="xref py py-meth docutils literal"><span class="pre">Leaf.copy()</span></tt></a>.  Moreover, it recognises the following additional
keyword arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>sortby</strong> :</p>
<blockquote>
<div><p>If specified, and sortby corresponds to a column with an index,
then the copy will be sorted by this index.  If you want to ensure
a fully sorted order, the index must be a CSI one.  A reverse
sorted copy can be achieved by specifying a negative value for the
step keyword.  If sortby is omitted or None, the original table
order is used.</p>
</div></blockquote>
<p><strong>checkCSI</strong> :</p>
<blockquote>
<div><p>If true and a CSI index does not exist for the sortby column, an
error will be raised.  If false (the default), it does nothing.
You can use this flag in order to explicitly check for the
existence of a CSI index.</p>
</div></blockquote>
<p><strong>propindexes</strong> :</p>
<blockquote class="last">
<div><p>If true, the existing indexes in the source table are propagated
(created) to the new one.  If false (the default), the indexes are
not propagated.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Table.flush">
<tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush the table buffers.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.flushRowsToIndex">
<tt class="descname">flushRowsToIndex</tt><big>(</big><em>_lastrow=True</em><big>)</big><a class="headerlink" href="#tables.Table.flushRowsToIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add remaining rows in buffers to non-dirty indexes.</p>
<p>This can be useful when you have chosen non-automatic indexing for the
table (see the <a class="reference internal" href="#tables.Table.autoIndex" title="tables.Table.autoIndex"><tt class="xref py py-attr docutils literal"><span class="pre">Table.autoIndex</span></tt></a> property in
<em class="xref std std-ref">TableInstanceVariablesDescr</em>) and you want to update the indexes
on it.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.getEnum">
<tt class="descname">getEnum</tt><big>(</big><em>colname</em><big>)</big><a class="headerlink" href="#tables.Table.getEnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the enumerated type associated with the named column.</p>
<p>If the column named colname (a string) exists and is of an enumerated
type, the corresponding Enum instance (see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>) is
returned. If it is not of an enumerated type, a TypeError is raised. If
the column does not exist, a KeyError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.getWhereList">
<tt class="descname">getWhereList</tt><big>(</big><em>condition</em>, <em>condvars=None</em>, <em>sort=False</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.getWhereList" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the row coordinates fulfilling the given condition.</p>
<p>The coordinates are returned as a list of the current flavor.  sort
means that you want to retrieve the coordinates ordered. The default is
to not sort them.</p>
<p>The meaning of the other arguments is the same as in the
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.iterrows">
<tt class="descname">iterrows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the table using a Row instance.</p>
<p>If a range is not supplied, <em>all the rows</em> in the table are iterated
upon - you can also use the <a class="reference internal" href="#tables.Table.__iter__" title="tables.Table.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">Table.__iter__()</span></tt></a> special method for
that purpose. If you want to iterate over a given <em>range of rows</em> in
the table, you may use the start, stop and step parameters, which have
the same meaning as in <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When in the middle of a table row iterator, you should not
use methods that can change the number of rows in the table
(like <a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a> or <a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>) or
unexpected errors will happen.</p>
</div>
<p class="rubric">Notes</p>
<p>This iterator can be nested (see <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> for an example).</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Table.itersequence">
<tt class="descname">itersequence</tt><big>(</big><em>sequence</em><big>)</big><a class="headerlink" href="#tables.Table.itersequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over a sequence of row coordinates.</p>
<p class="rubric">Notes</p>
<p>This iterator can be nested (see <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> for an example).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.itersorted">
<tt class="descname">itersorted</tt><big>(</big><em>sortby</em>, <em>checkCSI=False</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.itersorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate table data following the order of the index of sortby
column.</p>
<p>The sortby column must have associated a full index.  If you want to
ensure a fully sorted order, the index must be a CSI one.  You may want
to use the checkCSI argument in order to explicitly check for the
existence of a CSI index.</p>
<p>The meaning of the start, stop and step arguments is the same as in
<a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>.  However, in this case a negative value of step is
supported, meaning that the results will be returned in reverse sorted
order.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyColumn">
<tt class="descname">modifyColumn</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em>, <em>column=None</em>, <em>colname=None</em><big>)</big><a class="headerlink" href="#tables.Table.modifyColumn" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify one single column in the row slice [start:stop:step].</p>
<p>The colname argument specifies the name of the column in the table to
be modified with the data given in column.  This method returns the
number of rows modified.  Should the modification exceed the length of
the table, an IndexError is raised before changing data.</p>
<p>The column argument may be any object which can be converted to a
(record) array compliant with the structure of the column to be
modified (otherwise, a ValueError is raised).  This includes NumPy
(record) arrays, NumArray (deprecated), RecArray (deprecated) or
NestedRecArray (deprecated) objects if numarray is available, Numeric
arrays if available (deprecated), lists of scalars, tuples or array
records, and a string or Python buffer.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyColumns">
<tt class="descname">modifyColumns</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em>, <em>columns=None</em>, <em>names=None</em><big>)</big><a class="headerlink" href="#tables.Table.modifyColumns" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a series of columns in the row slice [start:stop:step].</p>
<p>The names argument specifies the names of the columns in the table to
be modified with the data given in columns.  This method returns the
number of rows modified.  Should the modification exceed the length of
the table, an IndexError is raised before changing data.</p>
<p>The columns argument may be any object which can be converted to a
structured array compliant with the structure of the columns to be
modified (otherwise, a ValueError is raised).  This includes NumPy
structured arrays, RecArray (deprecated) or NestedRecArray (deprecated)
objects if numarray is available, lists of tuples or array records, and
a string or Python buffer.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyCoordinates">
<tt class="descname">modifyCoordinates</tt><big>(</big><em>coords</em>, <em>rows</em><big>)</big><a class="headerlink" href="#tables.Table.modifyCoordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a series of rows in positions specified in coords</p>
<p>The values in the selected rows will be modified with the data given in
rows.  This method returns the number of rows modified.</p>
<p>The possible values for the rows argument are the same as in
<a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.modifyRows">
<tt class="descname">modifyRows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em>, <em>rows=None</em><big>)</big><a class="headerlink" href="#tables.Table.modifyRows" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a series of rows in the slice [start:stop:step].</p>
<p>The values in the selected rows will be modified with the data given in
rows.  This method returns the number of rows modified.  Should the
modification exceed the length of the table, an IndexError is raised
before changing data.</p>
<p>The possible values for the rows argument are the same as in
<a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.reIndex">
<tt class="descname">reIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.reIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute all the existing indexes in the table.</p>
<p>This can be useful when you suspect that, for any reason, the index
information for columns is no longer valid and want to rebuild the
indexes on it.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.reIndexDirty">
<tt class="descname">reIndexDirty</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Table.reIndexDirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the existing indexes in table, <em>if</em> they are dirty.</p>
<p>This can be useful when you have set <a class="reference internal" href="#tables.Table.autoIndex" title="tables.Table.autoIndex"><tt class="xref py py-attr docutils literal"><span class="pre">Table.autoIndex</span></tt></a> (see
<em class="xref std std-ref">TableInstanceVariablesDescr</em>) to false for the table and you want
to update the indexes after a invalidating index operation
(<a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>, for example).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.read">
<tt class="descname">read</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em>, <em>field=None</em><big>)</big><a class="headerlink" href="#tables.Table.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data in the table as a (record) array.</p>
<p>The start, stop and step parameters can be used to select only a <em>range
of rows</em> in the table. Their meanings are the same as in the built-in
range() Python function, except that negative values of step are not
allowed yet. Moreover, if only start is specified, then stop will be
set to start+1. If you do not specify neither start nor stop, then <em>all
the rows</em> in the table are selected.</p>
<p>If field is supplied only the named column will be selected.  If the
column is not nested, an <em>array</em> of the current flavor will be
returned; if it is, a <em>structured array</em> will be used instead.  If no
field is specified, all the columns will be returned in a structured
array of the current flavor.</p>
<p>Columns under a nested column can be specified in the field parameter by
using a slash character (/) as a separator (e.g. &#8216;position/x&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.readCoordinates">
<tt class="descname">readCoordinates</tt><big>(</big><em>coords</em>, <em>field=None</em><big>)</big><a class="headerlink" href="#tables.Table.readCoordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a set of rows given their indexes as a (record) array.</p>
<p>This method works much like the <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a> method, but it uses
a sequence (coords) of row indexes to select the wanted columns,
instead of a column range.</p>
<p>The selected rows are returned in an array or structured array of the
current flavor.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.readSorted">
<tt class="descname">readSorted</tt><big>(</big><em>sortby</em>, <em>checkCSI=False</em>, <em>field=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.readSorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Read table data following the order of the index of sortby column.</p>
<p>The sortby column must have associated a full index.  If you want to
ensure a fully sorted order, the index must be a CSI one.  You may want
to use the checkCSI argument in order to explicitly check for the
existence of a CSI index.</p>
<p>If field is supplied only the named column will be selected.  If the
column is not nested, an <em>array</em> of the current flavor will be
returned; if it is, a <em>structured array</em> will be used instead.  If no
field is specified, all the columns will be returned in a structured
array of the current flavor.</p>
<p>The meaning of the start, stop and step arguments is the same as in
<a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>.  However, in this case a negative value of step is
supported, meaning that the results will be returned in reverse sorted
order.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.readWhere">
<tt class="descname">readWhere</tt><big>(</big><em>condition</em>, <em>condvars=None</em>, <em>field=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.readWhere" title="Permalink to this definition">¶</a></dt>
<dd><p>Read table data fulfilling the given <em>condition</em>.</p>
<p>This method is similar to <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a>, having their common
arguments and return values the same meanings. However, only the rows
fulfilling the <em>condition</em> are included in the result.</p>
<p>The meaning of the other arguments is the same as in the
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.removeRows">
<tt class="descname">removeRows</tt><big>(</big><em>start</em>, <em>stop=None</em><big>)</big><a class="headerlink" href="#tables.Table.removeRows" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a range of rows in the table.</p>
<p>If only start is supplied, only this row is to be deleted.  If a range
is supplied, i.e. both the start and stop parameters are passed, all
the rows in the range are removed. A step parameter is not supported,
and it is not foreseen to be implemented anytime soon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>start</strong> : int</p>
<blockquote>
<div><p>Sets the starting row to be removed. It accepts negative values
meaning that the count starts from the end.  A value of 0 means the
first row.</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote class="last">
<div><p>Sets the last row to be removed to stop-1, i.e. the end point is
omitted (in the Python range() tradition). Negative values are also
accepted. A special value of None (the default) means removing just
the row supplied in start.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Table.where">
<tt class="descname">where</tt><big>(</big><em>condition</em>, <em>condvars=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over values fulfilling a condition.</p>
<p>This method returns a Row iterator (see <a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>) which
only selects rows in the table that satisfy the given condition (an
expression-like string).</p>
<p>The condvars mapping may be used to define the variable names appearing
in the condition. condvars should consist of identifier-like strings
pointing to Column (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) instances <em>of this
table</em>, or to other values (which will be converted to arrays). A
default set of condition variables is provided where each top-level,
non-nested column with an identifier-like name appears. Variables in
condvars override the default ones.</p>
<p>When condvars is not provided or None, the current local and global
namespace is sought instead of condvars. The previous mechanism is
mostly intended for interactive usage. To disable it, just specify a
(maybe empty) mapping as condvars.</p>
<p>If a range is supplied (by setting some of the start, stop or step
parameters), only the rows in that range and fulfilling the condition
are used. The meaning of the start, stop and step parameters is the
same as in the range() Python function, except that negative values of
step are not allowed. Moreover, if only start is specified, then stop
will be set to start+1.</p>
<p>When possible, indexed columns participating in the condition will be
used to speed up the search. It is recommended that you place the
indexed columns as left and out in the condition as possible. Anyway,
this method has always better performance than regular Python
selections on the table.</p>
<p>You can mix this method with regular Python selections in order to
support even more complex queries. It is strongly recommended that you
pass the most restrictive condition as the parameter to this method if
you want to achieve maximum performance.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When in the middle of a table row iterator, you should not
use methods that can change the number of rows in the table
(like <a class="reference internal" href="#tables.Table.append" title="tables.Table.append"><tt class="xref py py-meth docutils literal"><span class="pre">Table.append()</span></tt></a> or <a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>) or
unexpected errors will happen.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">passvalues</span> <span class="o">=</span> <span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span>
<span class="gp">... </span>               <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;(col1 &gt; 0) &amp; (col2 &lt;= 20)&#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span>               <span class="k">if</span> <span class="n">your_function</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">])</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Values that pass the cuts:&quot;</span><span class="p">,</span> <span class="n">passvalues</span>
</pre></div>
</div>
<p>Note that, from PyTables 1.1 on, you can nest several
iterators over the same table. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;pressure &lt; 16&#39;</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">rout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;pressure &lt; 9&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">rout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;energy &lt; 10&#39;</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;pressure, energy:&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;pressure&#39;</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In this example, iterators returned by <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> have been
used, but you may as well use any of the other reading iterators that
Table objects offer. See the file <tt class="file docutils literal"><span class="pre">examples/nested-iter.py</span></tt> for
the full code.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.whereAppend">
<tt class="descname">whereAppend</tt><big>(</big><em>dstTable</em>, <em>condition</em>, <em>condvars=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Table.whereAppend" title="Permalink to this definition">¶</a></dt>
<dd><p>Append rows fulfilling the condition to the dstTable table.</p>
<p>dstTable must be capable of taking the rows resulting from the query,
i.e. it must have columns with the expected names and compatible
types. The meaning of the other arguments is the same as in the
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method.</p>
<p>The number of rows appended to dstTable is returned as a result.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Table.willQueryUseIndexing">
<tt class="descname">willQueryUseIndexing</tt><big>(</big><em>condition</em>, <em>condvars=None</em><big>)</big><a class="headerlink" href="#tables.Table.willQueryUseIndexing" title="Permalink to this definition">¶</a></dt>
<dd><p>Will a query for the condition use indexing?</p>
<p>The meaning of the condition and <em>condvars</em> arguments is the same as in
the <a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a> method. If condition can use indexing, this
method returns a frozenset with the path names of the columns whose
index is usable. Otherwise, it returns an empty list.</p>
<p>This method is mainly intended for testing. Keep in mind that changing
the set of indexed columns or their dirtiness may make this method
return different values for the same arguments at different times.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.Table.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.autoIndex">
<tt class="descname">autoIndex</tt><a class="headerlink" href="#tables.Table.autoIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically keep column indexes up to date?</p>
<p>Setting this value states whether existing indexes should be automatically
updated after an append operation or recomputed after an index-invalidating
operation (i.e. removal and modification of rows). The default is true.</p>
<p>This value gets into effect whenever a column is altered. If you don&#8217;t have
automatic indexing activated and you want to do an immediate update use
<a class="reference internal" href="#tables.Table.flushRowsToIndex" title="tables.Table.flushRowsToIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Table.flushRowsToIndex()</span></tt></a>; for immediate reindexing of invalidated
indexes, use <a class="reference internal" href="#tables.Table.reIndexDirty" title="tables.Table.reIndexDirty"><tt class="xref py py-meth docutils literal"><span class="pre">Table.reIndexDirty()</span></tt></a>.</p>
<p>This value is persistent.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coldescrs">
<tt class="descname">coldescrs</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.coldescrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its Col description (see
<a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coldflts">
<tt class="descname">coldflts</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.coldflts" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its default value.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coldtypes">
<tt class="descname">coldtypes</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.coldtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its NumPy data type.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colindexed">
<tt class="descname">colindexed</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.colindexed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the column which name is used as a key indexed?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colindexes">
<tt class="descname">colindexes</tt><a class="headerlink" href="#tables.Table.colindexes" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary with the indexes of the indexed columns.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colinstances">
<tt class="descname">colinstances</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.colinstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its Column (see
<a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) or Cols (see <a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>)
instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colnames">
<tt class="descname">colnames</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.colnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing the names of <em>top-level</em> columns in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.colpathnames">
<tt class="descname">colpathnames</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.colpathnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing the pathnames of <em>bottom-level</em> columns in the
table.</p>
<p>These are the leaf columns obtained when walking the
table description left-to-right, bottom-first.  Columns inside a
nested column have slashes (/) separating name components in
their pathname.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.cols">
<tt class="descname">cols</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.cols" title="Permalink to this definition">¶</a></dt>
<dd><p>A Cols instance that provides <em>natural naming</em> access to non-nested
(Column, see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) and nested (Cols, see
<a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>) columns.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.coltypes">
<tt class="descname">coltypes</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.coltypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the name of a column to its PyTables data type.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.description">
<tt class="descname">description</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.description" title="Permalink to this definition">¶</a></dt>
<dd><p>A Description instance (see <a class="reference internal" href="#descriptionclassdescr"><em>The Description class</em></a>)
reflecting the structure of the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#tables.Table.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy <tt class="docutils literal"><span class="pre">dtype</span></tt> that most closely matches this table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.extdim">
<tt class="descname">extdim</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.extdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the enlargeable dimension (always 0 for tables).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.indexed">
<tt class="descname">indexed</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.indexed" title="Permalink to this definition">¶</a></dt>
<dd><p>Does this table have any indexed columns?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.indexedcolpathnames">
<tt class="descname">indexedcolpathnames</tt><a class="headerlink" href="#tables.Table.indexedcolpathnames" title="Permalink to this definition">¶</a></dt>
<dd><p>List of pathnames of indexed columns in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.new">
<tt class="descname">new</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this the first time the node has been created?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.nrows">
<tt class="descname">nrows</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Table.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The current number of rows in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.row">
<tt class="descname">row</tt><a class="headerlink" href="#tables.Table.row" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated Row instance (see <a class="reference internal" href="#rowclassdescr"><em>The Row class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.rowsize">
<tt class="descname">rowsize</tt><a class="headerlink" href="#tables.Table.rowsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size in bytes of each row in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#tables.Table.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Table.size_in_memory">
<tt class="descname">size_in_memory</tt><a class="headerlink" href="#tables.Table.size_in_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of this table&#8217;s data in bytes when it is fully loaded into
memory.  This may be used in combination with size_on_disk to calculate
the compression ratio of the data.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-cols-class">
<span id="colsclassdescr"></span><h2>The Cols class<a class="headerlink" href="#the-cols-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Cols">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Cols</tt><big>(</big><em>table</em>, <em>desc</em><big>)</big><a class="headerlink" href="#tables.Cols" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for columns in a table or nested column.</p>
<p>This class is used as an <em>accessor</em> to the columns in a table or nested
column.  It supports the <em>natural naming</em> convention, so that you can
access the different columns as attributes which lead to Column instances
(for non-nested columns) or other Cols instances (for nested columns).</p>
<p>For instance, if table.cols is a Cols instance with a column named col1
under it, the later can be accessed as table.cols.col1. If col1 is nested
and contains a col2 column, this can be accessed as table.cols.col1.col2
and so on. Because of natural naming, the names of members start with
special prefixes, like in the Group class (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
<p>Like the Column class (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>), Cols supports item
access to read and write ranges of values in the table or nested column.</p>
<dl class="method">
<dt id="tables.Cols.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Cols.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from a table or nested column.</p>
<p>If key argument is an integer, the corresponding nested type row is
returned as a record of the current flavor. If key is a slice, the
range of rows determined by it is returned as a structured array of the
current flavor.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">record</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="c"># equivalent to table[4]</span>
<span class="n">recarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">Info</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Those statements are equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nrecord</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nrecarray</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;Info&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here you can see how a mix of natural naming, indexing and slicing can
be used as shorthands for the <a class="reference internal" href="#tables.Table.read" title="tables.Table.read"><tt class="xref py py-meth docutils literal"><span class="pre">Table.read()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols.__len__">
<tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Cols.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of top level columns in table.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Cols.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>A detailed string representation for this object.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Cols.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row or a range of rows in a table or nested column.</p>
<p>If key argument is an integer, the corresponding row is set to
value. If key is a slice, the range of rows determined by it is set to
value.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>
<span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">Info</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">recarray</span>
</pre></div>
</div>
<p>Those statements are equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">table</span><span class="o">.</span><span class="n">modifyRows</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="n">record</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyColumn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">colname</span><span class="o">=</span><span class="s">&#39;Info&#39;</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">recarray</span><span class="p">)</span>
</pre></div>
</div>
<p>Here you can see how a mix of natural naming, indexing and slicing can
be used as shorthands for the <a class="reference internal" href="#tables.Table.modifyRows" title="tables.Table.modifyRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyRows()</span></tt></a> and
<a class="reference internal" href="#tables.Table.modifyColumn" title="tables.Table.modifyColumn"><tt class="xref py py-meth docutils literal"><span class="pre">Table.modifyColumn()</span></tt></a> methods.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Cols.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>The string representation for this object.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols._f_col">
<tt class="descname">_f_col</tt><big>(</big><em>colname</em><big>)</big><a class="headerlink" href="#tables.Cols._f_col" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an accessor to the column colname.</p>
<p>This method returns a Column instance (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) if
the requested column is not nested, and a Cols instance (see
<a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>) if it is.  You may use full column pathnames in
colname.</p>
<p>Calling cols._f_col(&#8216;col1/col2&#8217;) is equivalent to using cols.col1.col2.
However, the first syntax is more intended for programmatic use.  It is
also better if you want to access columns with names that are not valid
Python identifiers.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols._g_col">
<tt class="descname">_g_col</tt><big>(</big><em>colname</em><big>)</big><a class="headerlink" href="#tables.Cols._g_col" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>self._f_col()</cite> but it does not check arguments.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Cols._g_updateTableLocation">
<tt class="descname">_g_updateTableLocation</tt><big>(</big><em>table</em><big>)</big><a class="headerlink" href="#tables.Cols._g_updateTableLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the location information about the associated <cite>table</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Cols.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.Cols.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Cols._v_table">
<tt class="descname">_v_table</tt><a class="headerlink" href="#tables.Cols._v_table" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent Table instance (see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-column-class">
<span id="columnclassdescr"></span><h2>The Column class<a class="headerlink" href="#the-column-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Column">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Column</tt><big>(</big><em>table</em>, <em>name</em>, <em>descr</em><big>)</big><a class="headerlink" href="#tables.Column" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for a non-nested column in a table.</p>
<p>Each instance of this class is associated with one <em>non-nested</em> column of a
table. These instances are mainly used to read and write data from the
table columns using item access (like the Cols class - see
<a class="reference internal" href="#colsclassdescr"><em>The Cols class</em></a>), but there are a few other associated methods to
deal with indexes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>table</strong> :</p>
<blockquote>
<div><p>The parent table instance</p>
</div></blockquote>
<p><strong>name</strong> :</p>
<blockquote>
<div><p>The name of the column that is associated with this object</p>
</div></blockquote>
<p><strong>descr</strong> :</p>
<blockquote class="last">
<div><p>The parent description object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tables.Column.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Column.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from a column.</p>
<p>If key argument is an integer, the corresponding element in the column
is returned as an object of the current flavor.  If key is a slice, the
range of elements determined by it is returned as an array of the
current flavor.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;Column handlers:&quot;</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_f_col</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols.name[1]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols.name[1:2]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols.name[:]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">name</span><span class="p">[:]</span>
    <span class="k">print</span> <span class="s">&quot;Select table.cols._f_col(&#39;name&#39;)[:]--&gt;&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">_f_col</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)[:]</span>
</pre></div>
</div>
<p>The output of this for a certain arbitrary table is:</p>
<div class="highlight-python"><pre>Column handlers:
/table.cols.name (Column(), string, idx=None)
/table.cols.lati (Column(), int32, idx=None)
/table.cols.longi (Column(), int32, idx=None)
/table.cols.vector (Column(2,), int32, idx=None)
/table.cols.matrix2D (Column(2, 2), float64, idx=None)
Select table.cols.name[1]--&gt; Particle:     11
Select table.cols.name[1:2]--&gt; ['Particle:     11']
Select table.cols.name[:]--&gt; ['Particle:     10'
 'Particle:     11' 'Particle:     12'
 'Particle:     13' 'Particle:     14']
Select table.cols._f_col('name')[:]--&gt; ['Particle:     10'
 'Particle:     11' 'Particle:     12'
 'Particle:     13' 'Particle:     14']</pre>
</div>
<p>See the <tt class="file docutils literal"><span class="pre">examples/table2.py</span></tt> file for a more complete example.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.__len__">
<tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of elements in the column.</p>
<p>This matches the length in rows of the parent table.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>A detailed string representation for this object.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Column.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row or a range of rows in a column.</p>
<p>If key argument is an integer, the corresponding element is set to
value.  If key is a slice, the range of elements determined by it is
set to value.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Modify row 1</span>
<span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">col1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="c"># Modify rows 1 and 3</span>
<span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">col1</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Modify row 1</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyColumns</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">])</span>

<span class="c"># Modify rows 1 and 3</span>
<span class="n">columns</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="n">formats</span><span class="o">=</span><span class="s">&#39;i4&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">modifyColumns</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Column.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>The string representation for this object.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this column</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.createCSIndex">
<tt class="descname">createCSIndex</tt><big>(</big><em>filters=None</em>, <em>tmp_dir=None</em>, <em>_blocksizes=None</em>, <em>_testmode=False</em>, <em>_verbose=False</em><big>)</big><a class="headerlink" href="#tables.Column.createCSIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a completely sorted index (CSI) for this column.</p>
<p>This method guarantees the creation of an index with zero entropy, that
is, a completely sorted index (CSI) &#8211; provided that the number of rows
in the table does not exceed the 2**48 figure (that is more than 100
trillions of rows).  A CSI index is needed for some table methods (like
<a class="reference internal" href="#tables.Table.itersorted" title="tables.Table.itersorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.itersorted()</span></tt></a> or <a class="reference internal" href="#tables.Table.readSorted" title="tables.Table.readSorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readSorted()</span></tt></a>) in order to
ensure completely sorted results.</p>
<p>For the meaning of filters and tmp_dir arguments see
<a class="reference internal" href="#tables.Column.createIndex" title="tables.Column.createIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createIndex()</span></tt></a>.</p>
<p class="rubric">Notes</p>
<p>This method is equivalent to
Column.createIndex(optlevel=9, kind=&#8217;full&#8217;, ...).</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.createIndex">
<tt class="descname">createIndex</tt><big>(</big><em>optlevel=6</em>, <em>kind='medium'</em>, <em>filters=None</em>, <em>tmp_dir=None</em>, <em>_blocksizes=None</em>, <em>_testmode=False</em>, <em>_verbose=False</em><big>)</big><a class="headerlink" href="#tables.Column.createIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an index for this column.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In some situations it is useful to get a completely sorted
index (CSI).  For those cases, it is best to use the
<a class="reference internal" href="#tables.Column.createCSIndex" title="tables.Column.createCSIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createCSIndex()</span></tt></a> method instead.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>optlevel</strong> : int</p>
<blockquote>
<div><p>The optimization level for building the index.  The levels ranges
from 0 (no optimization) up to 9 (maximum optimization).  Higher
levels of optimization mean better chances for reducing the entropy
of the index at the price of using more CPU, memory and I/O
resources for creating the index.</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>The kind of the index to be built.  It can take the &#8216;ultralight&#8217;,
&#8216;light&#8217;, &#8216;medium&#8217; or &#8216;full&#8217; values.  Lighter kinds (&#8216;ultralight&#8217;
and &#8216;light&#8217;) mean that the index takes less space on disk, but will
perform queries slower.  Heavier kinds (&#8216;medium&#8217; and &#8216;full&#8217;) mean
better chances for reducing the entropy of the index (increasing
the query speed) at the price of using more disk space as well as
more CPU, memory and I/O resources for creating the index.</p>
<p>Note that selecting a full kind with an optlevel of 9 (the maximum)
guarantees the creation of an index with zero entropy, that is, a
completely sorted index (CSI) - provided that the number of rows in
the table does not exceed the 2**48 figure (that is more than 100
trillions of rows).  See <a class="reference internal" href="#tables.Column.createCSIndex" title="tables.Column.createCSIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createCSIndex()</span></tt></a> method for a
more direct way to create a CSI index.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>Specify the Filters instance used to compress the index.  If None,
default index filters will be used (currently, zlib level 1 with
shuffling).</p>
</div></blockquote>
<p><strong>tmp_dir</strong> :</p>
<blockquote class="last">
<div><p>When kind is other than &#8216;ultralight&#8217;, a temporary file is created
during the index build process.  You can use the tmp_dir argument
to specify the directory for this temporary file.  The default is
to create it in the same directory as the file containing the
original table.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.Column.reIndex">
<tt class="descname">reIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.reIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the index associated with this column.</p>
<p>This can be useful when you suspect that, for any reason,
the index information is no longer valid and you want to rebuild it.</p>
<p>This method does nothing if the column is not indexed.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.reIndexDirty">
<tt class="descname">reIndexDirty</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.reIndexDirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the associated index only if it is dirty.</p>
<p>This can be useful when you have set <a class="reference internal" href="#tables.Table.autoIndex" title="tables.Table.autoIndex"><tt class="xref py py-attr docutils literal"><span class="pre">Table.autoIndex</span></tt></a> to false
for the table and you want to update the column&#8217;s index after an
invalidating index operation (like <a class="reference internal" href="#tables.Table.removeRows" title="tables.Table.removeRows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.removeRows()</span></tt></a>).</p>
<p>This method does nothing if the column is not indexed.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Column.removeIndex">
<tt class="descname">removeIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Column.removeIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the index associated with this column.</p>
<p>This method does nothing if the column is not indexed. The removed
index can be created again by calling the <a class="reference internal" href="#tables.Column.createIndex" title="tables.Column.createIndex"><tt class="xref py py-meth docutils literal"><span class="pre">Column.createIndex()</span></tt></a>
method.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.Column.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.descr">
<tt class="descname">descr</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Column.descr" title="Permalink to this definition">¶</a></dt>
<dd><p>The Description (see <a class="reference internal" href="#descriptionclassdescr"><em>The Description class</em></a>) instance of the
parent table or nested column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#tables.Column.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy dtype that most closely matches this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.index">
<tt class="descname">index</tt><a class="headerlink" href="#tables.Column.index" title="Permalink to this definition">¶</a></dt>
<dd><p>The Index instance (see <a class="reference internal" href="#indexclassdescr"><em>The Index class</em></a>)
associated with this column (None if the column is not
indexed).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.is_indexed">
<tt class="descname">is_indexed</tt><a class="headerlink" href="#tables.Column.is_indexed" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the column is indexed, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.maindim">
<tt class="descname">maindim</tt><a class="headerlink" href="#tables.Column.maindim" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;The dimension along which iterators work. Its value is 0 (i.e. the
first dimension).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.name">
<tt class="descname">name</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Column.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the associated column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.pathname">
<tt class="descname">pathname</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Column.pathname" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete pathname of the associated column (the same as
Column.name if the column is not inside a nested column).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#tables.Column.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.table">
<tt class="descname">table</tt><a class="headerlink" href="#tables.Column.table" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent Table instance (see
<a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Column.type">
<tt class="descname">type</tt><a class="headerlink" href="#tables.Column.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables type of the column (a string).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-row-class">
<span id="rowclassdescr"></span><h2>The Row class<a class="headerlink" href="#the-row-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.tableExtension.Row">
<em class="property">class </em><tt class="descclassname">tables.tableExtension.</tt><tt class="descname">Row</tt><a class="headerlink" href="#tables.tableExtension.Row" title="Permalink to this definition">¶</a></dt>
<dd><p>Table row iterator and field accessor.</p>
<p>Instances of this class are used to fetch and set the values
of individual table fields.  It works very much like a dictionary,
where keys are the pathnames or positions (extended slicing is
supported) of the fields in the associated table in a specific row.</p>
<p>This class provides an <em>iterator interface</em>
so that you can use the same Row instance to
access successive table rows one after the other.  There are also
some important methods that are useful for accessing, adding and
modifying values in tables.</p>
<dl class="staticmethod">
<dt id="tables.tableExtension.Row.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#tables.tableExtension.Row.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tables.tableExtension.Row.__next__">
<tt class="descname">__next__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.tableExtension.Row.__next__" title="Permalink to this definition">¶</a></dt>
<dd><p>next() method for __iter__() that is called on each iteration</p>
</dd></dl>

<dl class="method">
<dt id="tables.tableExtension.Row.append">
<tt class="descname">append</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.tableExtension.Row.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new row of data to the end of the dataset.</p>
<p>Once you have filled the proper fields for the current
row, calling this method actually appends the new data to the
<em>output buffer</em> (which will eventually be
dumped to disk).  If you have not set the value of a field, the
default value of the column will be used.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">After completion of the loop in which <tt class="xref py py-meth docutils literal"><span class="pre">Row.append()</span></tt> has
been called, it is always convenient to make a call to
<a class="reference internal" href="#tables.Table.flush" title="tables.Table.flush"><tt class="xref py py-meth docutils literal"><span class="pre">Table.flush()</span></tt></a> in order to avoid losing the last rows that
may still remain in internal buffers.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">row</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">row</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.tableExtension.Row.fetch_all_fields">
<tt class="descname">fetch_all_fields</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.tableExtension.Row.fetch_all_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve all the fields in the current row.</p>
<p>Contrarily to row[:] (see <em class="xref std std-ref">RowSpecialMethods</em>), this returns row
data as a NumPy void scalar.  For instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">fetch_all_fields</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;col1 &lt; 3&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>will select all the rows that fulfill the given condition
as a list of NumPy records.</p>
</dd></dl>

<dl class="method">
<dt id="tables.tableExtension.Row.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.tableExtension.Row.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the data of the current row in the dataset.</p>
<p>This method allows you to modify values in a table when you are in the
middle of a table iterator like <a class="reference internal" href="#tables.Table.iterrows" title="tables.Table.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">Table.iterrows()</span></tt></a> or
<a class="reference internal" href="#tables.Table.where" title="tables.Table.where"><tt class="xref py py-meth docutils literal"><span class="pre">Table.where()</span></tt></a>.</p>
<p>Once you have filled the proper fields for the current row, calling
this method actually changes data in the <em>output buffer</em> (which will
eventually be dumped to disk).  If you have not set the value of a
field, its original value will be used.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">After completion of the loop in which <tt class="xref py py-meth docutils literal"><span class="pre">Row.update()</span></tt> has
been called, it is always convenient to make a call to
<a class="reference internal" href="#tables.Table.flush" title="tables.Table.flush"><tt class="xref py py-meth docutils literal"><span class="pre">Table.flush()</span></tt></a> in order to avoid losing changed rows that
may still remain in internal buffers.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">nrow</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>which modifies every tenth row in table.  Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;col1 &gt; 3&#39;</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">nrow</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>which just updates the rows with values bigger than 3 in the first
column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.__contains__">
<tt class="descname">__contains__</tt><big>(</big><em>item</em><big>)</big><a class="headerlink" href="#tables.tableExtension.Row.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>A true value is returned if item is found in current row, false
otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.__delitem__">
<tt class="descname">__delitem__</tt><a class="headerlink" href="#tables.tableExtension.Row.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__delitem__(y) &lt;==&gt; del x[y]</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.tableExtension.Row.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the row field specified by the <cite>key</cite>.</p>
<p>The key can be a string (the name of the field), an integer (the
position of the field) or a slice (the range of field positions). When
key is a slice, the returned value is a <em>tuple</em> containing the values
of the specified fields.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s">&#39;var3&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s">&#39;var2 &lt; 20&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>which selects the var3 field for all the rows that fulfil the
condition. Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>which selects the field in the <em>4th</em> position for all the rows that
fulfil the condition. Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s">&#39;var2&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>which selects the all the fields (in the form of a <em>tuple</em>) for all the
rows that fulfil the condition. Or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>which selects all the fields in even positions (in the form of a
<em>tuple</em>) for all the rows in the slice [2:3000:3].</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#tables.tableExtension.Row.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that traverses all the data in the Table</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.__repr__">
<tt class="descname">__repr__</tt><a class="headerlink" href="#tables.tableExtension.Row.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the record as an string</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.tableExtension.Row.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the key row field to the specified value.</p>
<p>Differently from its __getitem__() counterpart, in this case key can
only be a string (the name of the field). The changes done via
__setitem__() will not take effect on the data on disk until any of the
<tt class="xref py py-meth docutils literal"><span class="pre">Row.append()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">Row.update()</span></tt> methods are called.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">nrow</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>
    <span class="n">row</span><span class="p">[</span><span class="s">&#39;col3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>
</div>
<p>which modifies every tenth row in the table.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.__str__">
<tt class="descname">__str__</tt><a class="headerlink" href="#tables.tableExtension.Row.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the record as an string</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.next">
<tt class="descname">next</tt><a class="headerlink" href="#tables.tableExtension.Row.next" title="Permalink to this definition">¶</a></dt>
<dd><p>x.next() -&gt; the next value, or raise StopIteration</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.tableExtension.Row.nrow">
<tt class="descname">nrow</tt><a class="headerlink" href="#tables.tableExtension.Row.nrow" title="Permalink to this definition">¶</a></dt>
<dd><p>The current row number.</p>
<p>This property is useful for knowing which row is being dealt with in the
middle of a loop or iterator.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-description-class">
<span id="descriptionclassdescr"></span><h2>The Description class<a class="headerlink" href="#the-description-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Description">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Description</tt><big>(</big><em>classdict</em>, <em>nestedlvl=-1</em>, <em>validate=True</em><big>)</big><a class="headerlink" href="#tables.Description" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents descriptions of the structure of tables.</p>
<p>An instance of this class is automatically bound to Table (see
<a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>) objects when they are created.  It provides a
browseable representation of the structure of the table, made of non-nested
(Col - see <a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>) and nested (Description) columns. It also
contains information that will allow you to build NestedRecArray
(deprecated) objects suited for the different columns in a table (be they
nested or not).</p>
<p>Column definitions under a description can be accessed as attributes of it
(<em>natural naming</em>). For instance, if table.description is a Description
instance with a column named col1 under it, the later can be accessed as
table.description.col1. If col1 is nested and contains a col2 column, this
can be accessed as table.description.col1.col2. Because of natural naming,
the names of members start with special prefixes, like in the Group class
(see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>).</p>
<dl class="method">
<dt id="tables.Description._f_walk">
<tt class="descname">_f_walk</tt><big>(</big><em>type='All'</em><big>)</big><a class="headerlink" href="#tables.Description._f_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over nested columns.</p>
<p>If type is &#8216;All&#8217; (the default), all column description objects (Col and
Description instances) are yielded in top-to-bottom order (preorder).</p>
<p>If type is &#8216;Col&#8217; or &#8216;Description&#8217;, only column descriptions of that
type are yielded.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Description._g_setNestedNamesDescr">
<tt class="descname">_g_setNestedNamesDescr</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Description._g_setNestedNamesDescr" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the nested names and descriptions for nested datatypes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Description._g_setPathNames">
<tt class="descname">_g_setPathNames</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Description._g_setPathNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pathnames for arbitrary nested descriptions.</p>
<p>This method sets the <tt class="docutils literal"><span class="pre">_v_pathname</span></tt> and <tt class="docutils literal"><span class="pre">_v_pathnames</span></tt>
attributes of all the elements (both descriptions and columns)
in this nested description.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-col-class-and-its-descendants">
<span id="colclassdescr"></span><h2>The Col class and its descendants<a class="headerlink" href="#the-col-class-and-its-descendants" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Col</tt><big>(</big><em>nptype</em>, <em>shape</em>, <em>dflt</em><big>)</big><a class="headerlink" href="#tables.Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column.</p>
<p>Col instances are used as a means to declare the different properties of a
non-nested column in a table or nested column.  Col classes are descendants
of their equivalent Atom classes (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>), but their
instances have an additional _v_pos attribute that is used to decide the
position of the column inside its parent table or nested column (see the
IsDescription class in <a class="reference internal" href="#isdescriptionclassdescr"><em>The IsDescription class</em></a> for more information
on column positions).</p>
<p>In the same fashion as Atom, you should use a particular Col descendant
class whenever you know the exact type you will need when writing your
code. Otherwise, you may use one of the Col.from_*() factory methods.</p>
<p>Each factory method inherited from the Atom class is available with the
same signature, plus an additional pos parameter (placed in last position)
which defaults to None and that may take an integer value.  This parameter
might be used to specify the position of the column in the table.</p>
<p>Besides, there are the next additional factory methods, available only for
Col objects.</p>
<p>The following parameters are available for most Col-derived constructors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>itemsize</strong> : int</p>
<blockquote>
<div><p>For types with a non-fixed size, this sets the size in bytes of
individual items in the column.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>Sets the shape of the column. An integer shape of N is equivalent to
the tuple (N,).</p>
</div></blockquote>
<p><strong>dflt</strong> :</p>
<blockquote>
<div><p>Sets the default value for the column.</p>
</div></blockquote>
<p><strong>pos</strong> : int</p>
<blockquote class="last">
<div><p>Sets the position of column in table.  If unspecified, the position
will be randomly selected.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tables.Col._get_init_args">
<tt class="descname">_get_init_args</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Col._get_init_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of instance constructor arguments.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Col._subclass_from_prefix">
<em class="property">classmethod </em><tt class="descname">_subclass_from_prefix</tt><big>(</big><em>class_</em>, <em>prefix</em><big>)</big><a class="headerlink" href="#tables.Col._subclass_from_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a column subclass for the given <cite>prefix</cite>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Col.from_atom">
<em class="property">classmethod </em><tt class="descname">from_atom</tt><big>(</big><em>class_</em>, <em>atom</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Col.from_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Col definition from a PyTables atom.</p>
<p>An optional position may be specified as the pos argument.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Col.from_dtype">
<em class="property">classmethod </em><tt class="descname">from_dtype</tt><big>(</big><em>class_</em>, <em>dtype</em>, <em>dflt=None</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Col.from_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <cite>Col</cite> definition from a NumPy <cite>dtype</cite>.</p>
<p>Optional default value and position may be specified as the
<cite>dflt</cite> and <cite>pos</cite> arguments, respectively.  The <cite>dtype</cite> must have
a byte order which is irrelevant or compatible with that of the
system.  Information in the <cite>dtype</cite> not represented in a <cite>Col</cite>
is ignored.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Col.from_kind">
<em class="property">classmethod </em><tt class="descname">from_kind</tt><big>(</big><em>class_</em>, <em>kind</em>, <em>itemsize=None</em>, <em>shape=()</em>, <em>dflt=None</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Col.from_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <cite>Col</cite> definition from a PyTables <cite>kind</cite>.</p>
<p>Optional item size, shape, default value and position may be
specified as the <cite>itemsize</cite>, <cite>shape</cite>, <cite>dflt</cite> and <cite>pos</cite>
arguments, respectively.  Bear in mind that not all columns
support a default item size.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Col.from_sctype">
<em class="property">classmethod </em><tt class="descname">from_sctype</tt><big>(</big><em>class_</em>, <em>sctype</em>, <em>shape=()</em>, <em>dflt=None</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Col.from_sctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <cite>Col</cite> definition from a NumPy scalar type <cite>sctype</cite>.</p>
<p>Optional shape, default value and position may be specified as
the <cite>shape</cite>, <cite>dflt</cite> and <cite>pos</cite> arguments, respectively.
Information in the <cite>sctype</cite> not represented in a <cite>Col</cite> is
ignored.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Col.from_type">
<em class="property">classmethod </em><tt class="descname">from_type</tt><big>(</big><em>class_</em>, <em>type</em>, <em>shape=()</em>, <em>dflt=None</em>, <em>pos=None</em><big>)</big><a class="headerlink" href="#tables.Col.from_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <cite>Col</cite> definition from a PyTables <cite>type</cite>.</p>
<p>Optional shape, default value and position may be specified as
the <cite>shape</cite>, <cite>dflt</cite> and <cite>pos</cite> arguments, respectively.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Col.prefix">
<em class="property">classmethod </em><tt class="descname">prefix</tt><big>(</big><em>class_</em><big>)</big><a class="headerlink" href="#tables.Col.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the column class prefix.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tables.StringCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">StringCol</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.StringCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.BoolCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">BoolCol</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.BoolCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.IntCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">IntCol</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.IntCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int8Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int8Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Int8Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int16Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int16Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Int16Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int32Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Int32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int64Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Int64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UIntCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UIntCol</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.UIntCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt8Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt8Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.UInt8Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt16Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt16Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.UInt16Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt32Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.UInt32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt64Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.UInt64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float32Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Float32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float64Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Float64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.ComplexCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">ComplexCol</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.ComplexCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.TimeCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">TimeCol</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.TimeCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Time32Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time32Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Time32Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Time64Col">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time64Col</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Time64Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

<dl class="class">
<dt id="tables.EnumCol">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">EnumCol</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.EnumCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a non-nested column of a particular type.</p>
<p>The constructor accepts the same arguments as the equivalent
<cite>Atom</cite> class, plus an additional <tt class="docutils literal"><span class="pre">pos</span></tt> argument for
position information, which is assigned to the <cite>_v_pos</cite>
attribute.</p>
</dd></dl>

</div>
<div class="section" id="the-isdescription-class">
<span id="isdescriptionclassdescr"></span><h2>The IsDescription class<a class="headerlink" href="#the-isdescription-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.IsDescription">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">IsDescription</tt><a class="headerlink" href="#tables.IsDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of the structure of a table or nested column.</p>
<p>This class is designed to be used as an easy, yet meaningful way to
describe the structure of new Table (see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>) datasets
or nested columns through the definition of <em>derived classes</em>. In order to
define such a class, you must declare it as descendant of IsDescription,
with as many attributes as columns you want in your table. The name of each
attribute will become the name of a column, and its value will hold a
description of it.</p>
<p>Ordinary columns can be described using instances of the Col class (see
<a class="reference internal" href="#colclassdescr"><em>The Col class and its descendants</em></a>). Nested columns can be described by using classes
derived from IsDescription, instances of it, or name-description
dictionaries. Derived classes can be declared in place (in which case the
column takes the name of the class) or referenced by name.</p>
<p>Nested columns can have a _v_pos special attribute which sets the
<em>relative</em> position of the column among sibling columns <em>also having
explicit positions</em>.  The pos constructor argument of Col instances is used
for the same purpose.  Columns with no explicit position will be placed
afterwards in alphanumeric order.</p>
<p>Once you have created a description object, you can pass it to the Table
constructor, where all the information it contains will be used to define
the table structure.</p>
</dd></dl>

</div>
<div class="section" id="the-array-class">
<span id="arrayclassdescr"></span><h2>The Array class<a class="headerlink" href="#the-array-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Array">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Array</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>object=None</em>, <em>title=''</em>, <em>byteorder=None</em>, <em>_log=True</em>, <em>_atom=None</em><big>)</big><a class="headerlink" href="#tables.Array" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents homogeneous datasets in an HDF5 file.</p>
<p>This class provides methods to write or read data to or from array objects
in the file. This class does not allow you neither to enlarge nor compress
the datasets on disk; use the EArray class (see <a class="reference internal" href="#earrayclassdescr"><em>The EArray class</em></a>) if
you want enlargeable dataset support or compression features, or CArray
(see <a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>) if you just want compression.</p>
<p>An interesting property of the Array class is that it remembers the
<em>flavor</em> of the object that has been saved so that if you saved, for
example, a list, you will get a list during readings afterwards; if you
saved a NumPy array, you will get a NumPy object, and so forth.</p>
<p>Note that this class inherits all the public attributes and methods that
Leaf (see <a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>) already provides. However, as Array
instances have no internal I/O buffers, it is not necessary to use the
flush() method they inherit from Leaf in order to save their internal state
to disk.  When a writing method call returns, all the data is already on
disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>object</strong> :</p>
<blockquote>
<div><p>The array or scalar to be saved.  Accepted types are NumPy arrays and
scalars, <tt class="docutils literal"><span class="pre">numarray</span></tt> arrays and string arrays, Numeric arrays and
scalars, as well as native Python sequences and scalars, provided that
values are regular (i.e. they are not like <tt class="docutils literal"><span class="pre">[[1,2],2]</span></tt>) and
homogeneous (i.e. all the elements are of the same type).</p>
</div></blockquote>
<p><strong>title</strong> :</p>
<blockquote>
<div><p>A description for this node (it sets the <tt class="docutils literal"><span class="pre">TITLE</span></tt> HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>byteorder</strong> :</p>
<blockquote class="last">
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or &#8216;big&#8217;.
If this is not specified, the byteorder is that of the given <cite>object</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tables.Array.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.Array.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row, a range of rows or a slice from the array.</p>
<p>The set of tokens allowed for the key is the same as that for extended
slicing in Python (including the Ellipsis or ... token).  The result is
an object of the current flavor; its shape depends on the kind of slice
used as key and the shape of the array itself.</p>
<p>Furthermore, NumPy-style fancy indexing, where a list of indices in a
certain axis is specified, is also supported.  Note that only one list
per selection is supported right now.  Finally, NumPy-style point and
boolean selections are supported as well.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">array1</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>                       <span class="c"># simple selection</span>
<span class="n">array2</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                <span class="c"># slice selection</span>
<span class="n">array3</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">:]</span>    <span class="c"># general slice selection</span>
<span class="n">array4</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c"># fancy selection</span>
<span class="n">array5</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">array</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)]</span>  <span class="c"># point selection</span>
<span class="n">array6</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">array</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span>            <span class="c"># boolean selection</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Array.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Array.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This is equivalent to calling <a class="reference internal" href="#tables.Array.iterrows" title="tables.Array.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">Array.iterrows()</span></tt></a> with default
arguments, i.e. it iterates over <em>all the rows</em> in the array.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">array</span><span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Array.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Array.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>This provides more metainfo in addition to standard __str__</p>
</dd></dl>

<dl class="method">
<dt id="tables.Array.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.Array.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row, a range of rows or a slice in the array.</p>
<p>It takes different actions depending on the type of the key parameter:
if it is an integer, the corresponding array row is set to value (the
value is broadcast when needed).  If key is a slice, the row slice
determined by it is set to value (as usual, if the slice to be updated
exceeds the actual shape of the array, only the values in the existing
range are updated).</p>
<p>If value is a multidimensional object, then its shape must be
compatible with the shape determined by key, otherwise, a ValueError
will be raised.</p>
<p>Furthermore, NumPy-style fancy indexing, where a list of indices in a
certain axis is specified, is also supported.  Note that only one list
per selection is supported right now.  Finally, NumPy-style point and
boolean selections are supported as well.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">333</span>        <span class="c"># assign an integer to a Integer Array row</span>
<span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>        <span class="c"># assign a string to a string Array row</span>
<span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>        <span class="c"># broadcast 5 to slice 1:4</span>
<span class="n">a4</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;xXx&#39;</span>  <span class="c"># broadcast &#39;xXx&#39; to slice 1:4:2</span>

<span class="c"># General slice update (a5.shape = (4,3,2,8,5,10).</span>
<span class="n">a5</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1728</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">a6</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>    <span class="c"># fancy selection</span>
<span class="n">a7</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a6</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">4</span>       <span class="c"># point selection + broadcast</span>
<span class="n">a8</span><span class="p">[</span><span class="n">arr</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr2</span>                <span class="c"># boolean selection</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Array.getEnum">
<tt class="descname">getEnum</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Array.getEnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the enumerated type associated with this array.</p>
<p>If this array is of an enumerated type, the corresponding Enum instance
(see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>) is returned. If it is not of an enumerated
type, a TypeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Array.iterrows">
<tt class="descname">iterrows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Array.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This method returns an iterator yielding an object of the current
flavor for each selected row in the array.  The returned rows are taken
from the <em>main dimension</em>.</p>
<p>If a range is not supplied, <em>all the rows</em> in the array are iterated
upon - you can also use the <a class="reference internal" href="#tables.Array.__iter__" title="tables.Array.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">Array.__iter__()</span></tt></a> special method for
that purpose.  If you only want to iterate over a given <em>range of rows</em>
in the array, you may use the start, stop and step parameters, which
have the same meaning as in <a class="reference internal" href="#tables.Array.read" title="tables.Array.read"><tt class="xref py py-meth docutils literal"><span class="pre">Array.read()</span></tt></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">arrayInstance</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Array.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Array.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next element of the array during an iteration.</p>
<p>The element is returned as an object of the current flavor.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Array.read">
<tt class="descname">read</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Array.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data in the array as an object of the current flavor.</p>
<p>The start, stop and step parameters can be used to select only a <em>range
of rows</em> in the array.  Their meanings are the same as in the built-in
range() Python function, except that negative values of step are not
allowed yet. Moreover, if only start is specified, then stop will be
set to start+1. If you do not specify neither start nor stop, then <em>all
the rows</em> in the array are selected.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.Array.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.atom">
<tt class="descname">atom</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Array.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing the <em>type</em>
and <em>shape</em> of the atomic objects to be saved.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#tables.Array.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy <tt class="docutils literal"><span class="pre">dtype</span></tt> that most closely matches this array.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.extdim">
<tt class="descname">extdim</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Array.extdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the enlargeable dimension.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.listarr">
<tt class="descname">listarr</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Array.listarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Current buffer in iterators.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.new">
<tt class="descname">new</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Array.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this the first time the node has been created?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.nrow">
<tt class="descname">nrow</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Array.nrow" title="Permalink to this definition">¶</a></dt>
<dd><p>On iterators, this is the index of the current row.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.nrows">
<tt class="descname">nrows</tt><a class="headerlink" href="#tables.Array.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of rows in the array.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.rowsize">
<tt class="descname">rowsize</tt><a class="headerlink" href="#tables.Array.rowsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the rows in bytes in dimensions orthogonal to <em>maindim</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.shape">
<tt class="descname">shape</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Array.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the stored array.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Array.size_in_memory">
<tt class="descname">size_in_memory</tt><a class="headerlink" href="#tables.Array.size_in_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of this array&#8217;s data in bytes when it is fully loaded into
memory.  Since arrays do not support compression or chunking, this will
always equal size_on_disk.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-carray-class">
<span id="carrayclassdescr"></span><h2>The CArray class<a class="headerlink" href="#the-carray-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.CArray">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">CArray</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>atom=None</em>, <em>shape=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>_log=True</em><big>)</big><a class="headerlink" href="#tables.CArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents homogeneous datasets in an HDF5 file.</p>
<p>The difference between a CArray and a normal Array (see
<a class="reference internal" href="#arrayclassdescr"><em>The Array class</em></a>), from which it inherits, is that a CArray has a
chunked layout and, as a consequence, it supports compression.  You can use
datasets of this class to easily save or load arrays to or from disk, with
compression support included.</p>
<p>CArray includes all the instance variables and methods of Array.  Only those
with different behavior are mentioned here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>atom</strong> :</p>
<blockquote>
<div><p>An <cite>Atom</cite> instance representing the <em>type</em> and <em>shape</em> of
the atomic objects to be saved.</p>
</div></blockquote>
<p><strong>shape</strong> :</p>
<blockquote>
<div><p>The shape of the new array.</p>
</div></blockquote>
<p><strong>title</strong> :</p>
<blockquote>
<div><p>A description for this node (it sets the <tt class="docutils literal"><span class="pre">TITLE</span></tt> HDF5
attribute on disk).</p>
</div></blockquote>
<p><strong>filters</strong> :</p>
<blockquote>
<div><p>An instance of the <cite>Filters</cite> class that provides
information about the desired I/O filters to be applied
during the life of this object.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation.  Filters are applied to those
chunks of data.  The dimensionality of <cite>chunkshape</cite> must
be the same as that of <cite>shape</cite>.  If <tt class="docutils literal"><span class="pre">None</span></tt>, a sensible
value is calculated (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> :</p>
<blockquote class="last">
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217;
or &#8216;big&#8217;.  If this is not specified, the byteorder is that
of the platform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>See below a small example of the use of the <cite>CArray</cite> class.  The code is
available in <tt class="docutils literal"><span class="pre">examples/carray1.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">tables</span>

<span class="n">fileName</span> <span class="o">=</span> <span class="s">&#39;carray1.h5&#39;</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="n">atom</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">UInt8Atom</span><span class="p">()</span>
<span class="n">filters</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">Filters</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s">&#39;zlib&#39;</span><span class="p">)</span>

<span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">h5f</span><span class="o">.</span><span class="n">createCArray</span><span class="p">(</span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;carray&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>

<span class="c"># Fill a hyperslab in ``ca``.</span>
<span class="n">ca</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">20</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c"># Re-open a read another hyperslab</span>
<span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
<span class="k">print</span> <span class="n">h5f</span>
<span class="k">print</span> <span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">carray</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">:</span><span class="mi">22</span><span class="p">]</span>
<span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The output for the previous script is something like:</p>
<div class="highlight-python"><pre>carray1.h5 (File) ''
Last modif.: 'Thu Apr 12 10:15:38 2007'
Object Tree:
/ (RootGroup) ''
/carray (CArray(200, 300), shuffle, zlib(5)) ''

[[0 0 0 0]
 [0 0 0 0]
 [0 0 1 1]
 [0 0 1 1]]</pre>
</div>
<dl class="attribute">
<dt id="tables.CArray.atom">
<tt class="descname">atom</tt><em class="property"> = None</em><a class="headerlink" href="#tables.CArray.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>An <cite>Atom</cite> instance representing the shape, type of the atomic
objects to be saved.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.CArray.extdim">
<tt class="descname">extdim</tt><em class="property"> = None</em><a class="headerlink" href="#tables.CArray.extdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the enlargeable dimension.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.CArray.listarr">
<tt class="descname">listarr</tt><em class="property"> = None</em><a class="headerlink" href="#tables.CArray.listarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Current buffer in iterators.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.CArray.new">
<tt class="descname">new</tt><em class="property"> = None</em><a class="headerlink" href="#tables.CArray.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this the first time the node has been created?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.CArray.shape">
<tt class="descname">shape</tt><em class="property"> = None</em><a class="headerlink" href="#tables.CArray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the stored array.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-earray-class">
<span id="earrayclassdescr"></span><h2>The EArray class<a class="headerlink" href="#the-earray-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.EArray">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">EArray</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>atom=None</em>, <em>shape=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=None</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>_log=True</em><big>)</big><a class="headerlink" href="#tables.EArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents extendable, homogeneous datasets in an HDF5 file.</p>
<p>The main difference between an EArray and a CArray (see
<a class="reference internal" href="#carrayclassdescr"><em>The CArray class</em></a>), from which it inherits, is that the former
can be enlarged along one of its dimensions, the <em>enlargeable
dimension</em>.  That means that the <tt class="xref py py-attr docutils literal"><span class="pre">Leaf.extdim</span></tt> attribute (see
<em class="xref std std-ref">LeafInstanceVariables</em>) of any EArray instance will always be
non-negative.  Multiple enlargeable dimensions might be supported in
the future.</p>
<p>New rows can be added to the end of an enlargeable array by using the
<a class="reference internal" href="#tables.EArray.append" title="tables.EArray.append"><tt class="xref py py-meth docutils literal"><span class="pre">EArray.append()</span></tt></a> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>atom</strong> :</p>
<blockquote>
<div><p>An <cite>Atom</cite> instance representing the <em>type</em> and <em>shape</em>
of the atomic objects to be saved.</p>
</div></blockquote>
<p><strong>shape</strong> :</p>
<blockquote>
<div><p>The shape of the new array.  One (and only one) of
the shape dimensions <em>must</em> be 0.  The dimension being 0
means that the resulting <cite>EArray</cite> object can be extended
along it.  Multiple enlargeable dimensions are not supported
right now.</p>
</div></blockquote>
<p><strong>title</strong> :</p>
<blockquote>
<div><p>A description for this node (it sets the <tt class="docutils literal"><span class="pre">TITLE</span></tt>
HDF5 attribute on disk).</p>
</div></blockquote>
<p><strong>filters</strong> :</p>
<blockquote>
<div><p>An instance of the <cite>Filters</cite> class that provides information
about the desired I/O filters to be applied during the life
of this object.</p>
</div></blockquote>
<p><strong>expectedrows</strong> :</p>
<blockquote>
<div><p>A user estimate about the number of row elements that will
be added to the growable dimension in the <cite>EArray</cite> node.
If not provided, the default value is <tt class="docutils literal"><span class="pre">EXPECTED_ROWS_EARRAY</span></tt>
(see <tt class="docutils literal"><span class="pre">tables/parameters.py</span></tt>).  If you plan to create either
a much smaller or a much bigger <cite>EArray</cite> try providing a guess;
this will optimize the HDF5 B-Tree creation and management
process time and the amount of memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a single
HDF5 I/O operation.  Filters are applied to those chunks of data.
The dimensionality of <cite>chunkshape</cite> must be the same as that of
<cite>shape</cite> (beware: no dimension should be 0 this time!).
If <tt class="docutils literal"><span class="pre">None</span></tt>, a sensible value is calculated based on the
<cite>expectedrows</cite> parameter (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> :</p>
<blockquote class="last">
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;. If this is not specified, the byteorder is that of the
platform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>See below a small example of the use of the <cite>EArray</cite> class.  The
code is available in <tt class="docutils literal"><span class="pre">examples/earray1.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">tables</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">fileh</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;earray1.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">StringAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c"># Use ``a`` as the object type for the enlargeable array.</span>
<span class="n">array_c</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createEArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;array_c&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s">&quot;Chars&quot;</span><span class="p">)</span>
<span class="n">array_c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="o">*</span><span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;S8&#39;</span><span class="p">))</span>
<span class="n">array_c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="o">*</span><span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;S8&#39;</span><span class="p">))</span>

<span class="c"># Read the string ``EArray`` we have created on disk.</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">array_c</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;array_c[</span><span class="si">%s</span><span class="s">] =&gt; </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">array_c</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="c"># Close the file.</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The output for the previous script is something like:</p>
<div class="highlight-python"><pre>array_c[0] =&gt; 'aa'
array_c[1] =&gt; 'bbbb'
array_c[2] =&gt; 'aaaaaa'
array_c[3] =&gt; 'bbbbbbbb'
array_c[4] =&gt; 'cccccccc'</pre>
</div>
<dl class="method">
<dt id="tables.EArray.append">
<tt class="descname">append</tt><big>(</big><em>sequence</em><big>)</big><a class="headerlink" href="#tables.EArray.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a sequence of data to the end of the dataset.</p>
<p>The sequence must have the same type as the array; otherwise a
TypeError is raised. In the same way, the dimensions of the
sequence must conform to the shape of the array, that is, all
dimensions must match, with the exception of the enlargeable
dimension, which can be of any length (even 0!).  If the shape
of the sequence is invalid, a ValueError is raised.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-vlarray-class">
<span id="vlarrayclassdescr"></span><h2>The VLArray class<a class="headerlink" href="#the-vlarray-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.VLArray">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">VLArray</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>atom=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedsizeinMB=1.0</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>_log=True</em><big>)</big><a class="headerlink" href="#tables.VLArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents variable length (ragged) arrays in an HDF5 file.</p>
<p>Instances of this class represent array objects in the object tree
with the property that their rows can have a <em>variable</em> number of
homogeneous elements, called <em>atoms</em>. Like Table datasets (see
<a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>), variable length arrays can have only one
dimension, and the elements (atoms) of their rows can be fully
multidimensional.  VLArray objects do also support compression.</p>
<p>When reading a range of rows from a VLArray, you will <em>always</em> get
a Python list of objects of the current flavor (each of them for a
row), which may have different lengths.</p>
<p>This class provides methods to write or read data to or from
variable length array objects in the file. Note that it also
inherits all the public attributes and methods that Leaf (see
<a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>) already provides.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>atom</strong> :</p>
<blockquote>
<div><p>An <cite>Atom</cite> instance representing the <em>type</em> and <em>shape</em> of the atomic
objects to be saved.</p>
</div></blockquote>
<p><strong>title</strong> :</p>
<blockquote>
<div><p>A description for this node (it sets the <tt class="docutils literal"><span class="pre">TITLE</span></tt> HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>filters</strong> :</p>
<blockquote>
<div><p>An instance of the <cite>Filters</cite> class that provides information about the
desired I/O filters to be applied during the life of this object.</p>
</div></blockquote>
<p><strong>expectedsizeinMB</strong> :</p>
<blockquote>
<div><p>An user estimate about the size (in MB) in the final <cite>VLArray</cite> object.
If not provided, the default value is 1 MB.  If you plan to create
either a much smaller or a much bigger <cite>VLArray</cite> try providing a guess;
this will optimize the HDF5 B-Tree creation and management process time
and the amount of memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a single HDF5 I/O
operation.  Filters are applied to those chunks of data.  The
dimensionality of <cite>chunkshape</cite> must be 1.  If <tt class="docutils literal"><span class="pre">None</span></tt>, a sensible
value is calculated (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> :</p>
<blockquote class="last">
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or &#8216;big&#8217;.
If this is not specified, the byteorder is that of the platform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>See below a small example of the use of the VLArray class.  The code is
available in <tt class="file docutils literal"><span class="pre">examples/vlarray1.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">tables</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Create a VLArray:</span>
<span class="n">fileh</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;vlarray1.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">vlarray</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createVLArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;vlarray1&#39;</span><span class="p">,</span>
<span class="n">tables</span><span class="o">.</span><span class="n">Int32Atom</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">()),</span>
                <span class="s">&quot;ragged array of ints&quot;</span><span class="p">,</span>
                <span class="n">filters</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">Filters</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c"># Append some (variable length) rows:</span>
<span class="n">vlarray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="n">vlarray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="n">vlarray</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>

<span class="c"># Now, read it through an iterator:</span>
<span class="k">print</span> <span class="s">&#39;--&gt;&#39;</span><span class="p">,</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">title</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%d</span><span class="s">]--&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vlarray</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c"># Now, do the same with native Python strings.</span>
<span class="n">vlarray2</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createVLArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;vlarray2&#39;</span><span class="p">,</span>
<span class="n">tables</span><span class="o">.</span><span class="n">StringAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                    <span class="s">&quot;ragged array of strings&quot;</span><span class="p">,</span>
                    <span class="n">filters</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">Filters</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">flavor</span> <span class="o">=</span> <span class="s">&#39;python&#39;</span>

<span class="c"># Append some (variable length) rows:</span>
<span class="k">print</span> <span class="s">&#39;--&gt;&#39;</span><span class="p">,</span> <span class="n">vlarray2</span><span class="o">.</span><span class="n">title</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s">&#39;5&#39;</span><span class="p">,</span> <span class="s">&#39;66&#39;</span><span class="p">])</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s">&#39;5&#39;</span><span class="p">,</span> <span class="s">&#39;6&#39;</span><span class="p">,</span> <span class="s">&#39;77&#39;</span><span class="p">])</span>
<span class="n">vlarray2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s">&#39;5&#39;</span><span class="p">,</span> <span class="s">&#39;6&#39;</span><span class="p">,</span> <span class="s">&#39;9&#39;</span><span class="p">,</span> <span class="s">&#39;88&#39;</span><span class="p">])</span>

<span class="c"># Now, read it through an iterator:</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vlarray2</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%d</span><span class="s">]--&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vlarray2</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vlarray2</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c"># Close the file.</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The output for the previous script is something like:</p>
<div class="highlight-python"><pre>--&gt; ragged array of ints
vlarray1[0]--&gt; [5 6]
vlarray1[1]--&gt; [5 6 7]
vlarray1[2]--&gt; [5 6 9 8]
--&gt; ragged array of strings
vlarray2[0]--&gt; ['5', '66']
vlarray2[1]--&gt; ['5', '6', '77']
vlarray2[2]--&gt; ['5', '6', '9', '88']</pre>
</div>
<dl class="method">
<dt id="tables.VLArray.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#tables.VLArray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a row or a range of rows from the array.</p>
<p>If key argument is an integer, the corresponding array row is returned
as an object of the current flavor.  If key is a slice, the range of
rows determined by it is returned as a list of objects of the current
flavor.</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row coordinates, the set of rows
determined by it is returned.  Furthermore, if key is an array of
boolean values, only the coordinates where key is True are returned.
Note that for the latter to work it is necessary that key list would
contain exactly as many rows as the array has.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a_row</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">a_list</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">1000</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">a_list2</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>   <span class="c"># get list of coords</span>
<span class="n">a_list3</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>  <span class="c"># negative values accepted</span>
<span class="n">a_list4</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="bp">False</span><span class="p">])]</span>  <span class="c"># array of bools</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.VLArray.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This is equivalent to calling <a class="reference internal" href="#tables.VLArray.iterrows" title="tables.VLArray.iterrows"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.iterrows()</span></tt></a> with default
arguments, i.e. it iterates over <em>all the rows</em> in the array.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="p">]</span>
</pre></div>
</div>
<p>Which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.VLArray.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>This provides more metainfo in addition to standard __str__</p>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#tables.VLArray.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a row, or set of rows, in the array.</p>
<p>It takes different actions depending on the type of the key parameter:
if it is an integer, the corresponding table row is set to value (a
record or sequence capable of being converted to the table
structure). If key is a slice, the row slice determined by it is set to
value (a record array or sequence capable of being converted to the
table structure).</p>
<p>In addition, NumPy-style point selections are supported.  In
particular, if key is a list of row coordinates, the set of rows
determined by it is set to value.  Furthermore, if key is an array of
boolean values, only the coordinates where key is True are set to
values from value.  Note that for the latter to work it is necessary
that key list would contain exactly as many rows as the table has.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When updating the rows of a VLArray object which uses a
pseudo-atom, there is a problem: you can only update values
with <em>exactly</em> the same size in bytes than the original row.
This is very difficult to meet with object pseudo-atoms,
because <tt class="xref py py-mod docutils literal"><span class="pre">cPickle</span></tt> applied on a Python object does not
guarantee to return the same number of bytes than over another
object, even if they are of the same class.
This effectively limits the kinds of objects than can be
updated in variable-length arrays.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vlarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">vlarray</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">96</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>

<span class="c"># Negative values for the index are supported.</span>
<span class="n">vlarray</span><span class="p">[</span><span class="o">-</span><span class="mi">99</span><span class="p">]</span> <span class="o">=</span> <span class="n">vlarray</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">vlarray</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_of_rows</span>
<span class="n">vlarray</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_1_and_3_rows</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.append">
<tt class="descname">append</tt><big>(</big><em>sequence</em><big>)</big><a class="headerlink" href="#tables.VLArray.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a sequence of data to the end of the dataset.</p>
<p>This method appends the objects in the sequence to a <em>single row</em> in
this array. The type and shape of individual objects must be compliant
with the atoms in the array. In the case of serialized objects and
variable length strings, the object or string to append is itself the
sequence.</p>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.getEnum">
<tt class="descname">getEnum</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.VLArray.getEnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the enumerated type associated with this array.</p>
<p>If this array is of an enumerated type, the corresponding Enum instance
(see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>) is returned. If it is not of an enumerated
type, a TypeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.iterrows">
<tt class="descname">iterrows</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.VLArray.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the array.</p>
<p>This method returns an iterator yielding an object of the current
flavor for each selected row in the array.</p>
<p>If a range is not supplied, <em>all the rows</em> in the array are iterated
upon. You can also use the <a class="reference internal" href="#tables.VLArray.__iter__" title="tables.VLArray.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.__iter__()</span></tt></a> special method for
that purpose.  If you only want to iterate over a given <em>range of rows</em>
in the array, you may use the start, stop and step parameters, which
have the same meaning as in <a class="reference internal" href="#tables.VLArray.read" title="tables.VLArray.read"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.read()</span></tt></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%d</span><span class="s">]--&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vlarray</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vlarray</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.VLArray.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next element of the array during an iteration.</p>
<p>The element is returned as a list of objects of the current flavor.</p>
</dd></dl>

<dl class="method">
<dt id="tables.VLArray.read">
<tt class="descname">read</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=1</em><big>)</big><a class="headerlink" href="#tables.VLArray.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data in the array as a list of objects of the current flavor.</p>
<p>Please note that, as the lengths of the different rows are variable,
the returned value is a <em>Python list</em> (not an array of the current
flavor), with as many entries as specified rows in the range
parameters.</p>
<p>The start, stop and step parameters can be used to select only a <em>range
of rows</em> in the array.  Their meanings are the same as in the built-in
range() Python function, except that negative values of step are not
allowed yet. Moreover, if only start is specified, then stop will be
set to start+1. If you do not specify neither start nor stop, then <em>all
the rows</em> in the array are selected.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.VLArray.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.atom">
<tt class="descname">atom</tt><em class="property"> = None</em><a class="headerlink" href="#tables.VLArray.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>An Atom (see <a class="reference internal" href="#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing the
<em>type</em> and <em>shape</em> of the atomic objects to be saved. You may
use a <em>pseudo-atom</em> for storing a serialized object or
variable length string per row.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#tables.VLArray.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy <tt class="docutils literal"><span class="pre">dtype</span></tt> that most closely matches this array.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.extdim">
<tt class="descname">extdim</tt><em class="property"> = None</em><a class="headerlink" href="#tables.VLArray.extdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the enlargeable dimension (always 0 for vlarrays).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.listarr">
<tt class="descname">listarr</tt><em class="property"> = None</em><a class="headerlink" href="#tables.VLArray.listarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Current buffer in iterators.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.new">
<tt class="descname">new</tt><em class="property"> = None</em><a class="headerlink" href="#tables.VLArray.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this the first time the node has been created?</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.nrow">
<tt class="descname">nrow</tt><em class="property"> = None</em><a class="headerlink" href="#tables.VLArray.nrow" title="Permalink to this definition">¶</a></dt>
<dd><p>On iterators, this is the index of the current row.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.nrows">
<tt class="descname">nrows</tt><em class="property"> = None</em><a class="headerlink" href="#tables.VLArray.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The current number of rows in the array.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#tables.VLArray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the stored array.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.size_in_memory">
<tt class="descname">size_in_memory</tt><a class="headerlink" href="#tables.VLArray.size_in_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of this array&#8217;s data in bytes when it is fully loaded
into memory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When data is stored in a VLArray using the ObjectAtom type,
it is first serialized using cPickle, and then converted to
a NumPy array suitable for storage in an HDF5 file.
This attribute will return the size of that NumPy
representation.  If you wish to know the size of the Python
objects after they are loaded from disk, you can use this
<a class="reference external" href="http://code.activestate.com/recipes/577504/">ActiveState recipe</a>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tables.VLArray.size_on_disk">
<tt class="descname">size_on_disk</tt><a class="headerlink" href="#tables.VLArray.size_on_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>The HDF5 library does not include a function to determine size_on_disk
for variable-length arrays.  Accessing this attribute will raise a
NotImplementedError.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-link-class">
<span id="linkclassdescr"></span><h2>The Link class<a class="headerlink" href="#the-link-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.link.Link">
<em class="property">class </em><tt class="descclassname">tables.link.</tt><tt class="descname">Link</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>target=None</em>, <em>_log=False</em><big>)</big><a class="reference internal" href="../_modules/tables/link.html#Link"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.Link" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for all PyTables links.</p>
<p>A link is a node that refers to another node.  The Link class inherits from
Node class and the links that inherits from Link are SoftLink and
ExternalLink.  There is not a HardLink subclass because hard links behave
like a regular Group or Leaf.  Contrarily to other nodes, links cannot have
HDF5 attributes.  This is an HDF5 library limitation that might be solved
in future releases.</p>
<p>See <a class="reference internal" href="tutorials.html#linkstutorial"><em>Using links for more convenient access to nodes</em></a> for a small tutorial on how to work with links.</p>
<dl class="method">
<dt id="tables.link.Link.copy">
<tt class="descname">copy</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="reference internal" href="../_modules/tables/link.html#Link.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.Link.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this link and return the new one.</p>
<p>See <a class="reference internal" href="#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a> for a complete explanation of the arguments.
Please note that there is no recursive flag since links do not have
child nodes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.link.Link.move">
<tt class="descname">move</tt><big>(</big><em>newparent=None</em>, <em>newname=None</em>, <em>overwrite=False</em><big>)</big><a class="reference internal" href="../_modules/tables/link.html#Link.move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.Link.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move or rename this link.</p>
<p>See <a class="reference internal" href="#tables.Node._f_move" title="tables.Node._f_move"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_move()</span></tt></a> for a complete explanation of the arguments.</p>
</dd></dl>

<dl class="method">
<dt id="tables.link.Link.remove">
<tt class="descname">remove</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/link.html#Link.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.Link.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this link from the hierarchy.</p>
</dd></dl>

<dl class="method">
<dt id="tables.link.Link.rename">
<tt class="descname">rename</tt><big>(</big><em>newname=None</em>, <em>overwrite=False</em><big>)</big><a class="reference internal" href="../_modules/tables/link.html#Link.rename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.Link.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this link in place.</p>
<p>See <a class="reference internal" href="#tables.Node._f_rename" title="tables.Node._f_rename"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_rename()</span></tt></a> for a complete explanation of the arguments.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.link.Link._v_attrs">
<tt class="descname">_v_attrs</tt><a class="reference internal" href="../_modules/tables/link.html#Link._v_attrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.Link._v_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>A <em>NoAttrs</em> instance replacing the typical <em>AttributeSet</em> instance of
other node objects.  The purpose of <em>NoAttrs</em> is to make clear that
HDF5 attributes are not supported in link nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.link.Link.target">
<tt class="descname">target</tt><em class="property"> = None</em><a class="headerlink" href="#tables.link.Link.target" title="Permalink to this definition">¶</a></dt>
<dd><p>The path string to the pointed node.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-softlink-class">
<span id="softlinkclassdescr"></span><h2>The SoftLink class<a class="headerlink" href="#the-softlink-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.link.SoftLink">
<em class="property">class </em><tt class="descclassname">tables.link.</tt><tt class="descname">SoftLink</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>target=None</em>, <em>_log=False</em><big>)</big><a class="reference internal" href="../_modules/tables/link.html#SoftLink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.SoftLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a soft link (aka symbolic link).</p>
<p>A soft link is a reference to another node in the <em>same</em> file hierarchy.
Getting access to the pointed node (this action is called <em>dereferrencing</em>)
is done via the __call__ special method (see below).</p>
<dl class="method">
<dt id="tables.link.SoftLink.__call__">
<tt class="descname">__call__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/link.html#SoftLink.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.SoftLink.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dereference <cite>self.target</cite> and return the object.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link0</span>
<span class="go">/link0 (SoftLink) -&gt; /another/path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link0</span><span class="p">()</span>
<span class="go">/another/path (Group) &#39;&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.link.SoftLink.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/link.html#SoftLink.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.SoftLink.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the link.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link0</span>
<span class="go">/link0 (SoftLink) -&gt; /path/to/node</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tables.link.SoftLink.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.link.SoftLink.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-externallink-class">
<span id="externallinkclassdescr"></span><h2>The ExternalLink class<a class="headerlink" href="#the-externallink-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.link.ExternalLink">
<em class="property">class </em><tt class="descclassname">tables.link.</tt><tt class="descname">ExternalLink</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>target=None</em>, <em>_log=False</em><big>)</big><a class="reference internal" href="../_modules/tables/link.html#ExternalLink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.ExternalLink" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an external link.</p>
<p>An external link is a reference to a node in <em>another</em> file.
Getting access to the pointed node (this action is called
<em>dereferencing</em>) is done via the <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> special method
(see below).</p>
<dl class="method">
<dt id="tables.link.ExternalLink.__call__">
<tt class="descname">__call__</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/tables/link.html#ExternalLink.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.ExternalLink.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Dereference self.target and return the object.</p>
<p>You can pass all the arguments supported by the <a class="reference internal" href="#tables.openFile" title="tables.openFile"><tt class="xref py py-func docutils literal"><span class="pre">openFile()</span></tt></a>
function (except filename, of course) so as to open the referenced
external file.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data1/test1.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link2</span>
<span class="go">/link2 (ExternalLink) -&gt; data2/test2.h5:/path/to/node</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plink2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link2</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>  <span class="c"># open in &#39;a&#39;ppend mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">plink2</span>
<span class="go">/path/to/node (Group) &#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">plink2</span><span class="o">.</span><span class="n">_v_filename</span>
<span class="go">&#39;data2/test2.h5&#39;        # belongs to referenced file</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.link.ExternalLink.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/link.html#ExternalLink.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.ExternalLink.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the link.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">=</span><span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">&#39;data1/test1.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">link2</span>
<span class="go">/link2 (ExternalLink) -&gt; data2/test2.h5:/path/to/node</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.link.ExternalLink.umount">
<tt class="descname">umount</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/link.html#ExternalLink.umount"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.link.ExternalLink.umount" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely unmount self.extfile, if opened.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.link.ExternalLink.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.link.ExternalLink.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.link.ExternalLink.extfile">
<tt class="descname">extfile</tt><em class="property"> = None</em><a class="headerlink" href="#tables.link.ExternalLink.extfile" title="Permalink to this definition">¶</a></dt>
<dd><p>The external file handler, if the link has been dereferenced.
In case the link has not been dereferenced yet, its value is
None.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-unimplemented-class">
<span id="unimplementedclassdescr"></span><h2>The UnImplemented class<a class="headerlink" href="#the-unimplemented-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.UnImplemented">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UnImplemented</tt><big>(</big><em>parentNode</em>, <em>name</em><big>)</big><a class="headerlink" href="#tables.UnImplemented" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents datasets not supported by PyTables in an
HDF5 file.</p>
<p>When reading a generic HDF5 file (i.e. one that has not been created with
PyTables, but with some other HDF5 library based tool), chances are that
the specific combination of datatypes or dataspaces in some dataset might
not be supported by PyTables yet. In such a case, this dataset will be
mapped into an UnImplemented instance and the user will still be able to
access the complete object tree of the generic HDF5 file. The user will
also be able to <em>read and write the attributes</em> of the dataset, <em>access
some of its metadata</em>, and perform <em>certain hierarchy manipulation
operations</em> like deleting or moving (but not copying) the node. Of course,
the user will not be able to read the actual data on it.</p>
<p>This is an elegant way to allow users to work with generic HDF5 files
despite the fact that some of its datasets are not supported by
PyTables. However, if you are really interested in having full access to an
unimplemented dataset, please get in contact with the developer team.</p>
<p>This class does not have any public instance variables or methods, except
those inherited from the Leaf class (see <a class="reference internal" href="#leafclassdescr"><em>The Leaf class</em></a>).</p>
<dl class="attribute">
<dt id="tables.UnImplemented.byteorder">
<tt class="descname">byteorder</tt><em class="property"> = None</em><a class="headerlink" href="#tables.UnImplemented.byteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>The endianness of data in memory (&#8216;big&#8217;, &#8216;little&#8217; or &#8216;irrelevant&#8217;).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.UnImplemented.nrows">
<tt class="descname">nrows</tt><em class="property"> = None</em><a class="headerlink" href="#tables.UnImplemented.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The length of the first dimension of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.UnImplemented.shape">
<tt class="descname">shape</tt><em class="property"> = None</em><a class="headerlink" href="#tables.UnImplemented.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the stored data.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-unknown-class">
<span id="unknownclassdescr"></span><h2>The Unknown class<a class="headerlink" href="#the-unknown-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Unknown">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Unknown</tt><big>(</big><em>parentNode</em>, <em>name</em><big>)</big><a class="headerlink" href="#tables.Unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents nodes reported as <em>unknown</em> by the underlying
HDF5 library.</p>
<p>This class does not have any public instance variables or methods, except
those inherited from the Node class.</p>
</dd></dl>

</div>
<div class="section" id="the-attributeset-class">
<span id="attributesetclassdescr"></span><h2>The AttributeSet class<a class="headerlink" href="#the-attributeset-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.attributeset.AttributeSet">
<em class="property">class </em><tt class="descclassname">tables.attributeset.</tt><tt class="descname">AttributeSet</tt><big>(</big><em>node</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for the HDF5 attributes of a Node (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>).</p>
<p>This class provides methods to create new HDF5 node attributes,
and to get, rename or delete existing ones.</p>
<p>Like in Group instances (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>), AttributeSet
instances make use of the <em>natural naming</em> convention, i.e. you can
access the attributes on disk as if they were normal Python
attributes of the AttributeSet instance.</p>
<p>This offers the user a very convenient way to access HDF5 node
attributes. However, for this reason and in order not to pollute the
object namespace, one can not assign <em>normal</em> attributes to
AttributeSet instances, and their members use names which start by
special prefixes as happens with Group objects.</p>
<p class="rubric">Notes on native and pickled attributes</p>
<p>The values of most basic types are saved as HDF5 native data in the
HDF5 file.  This includes Python bool, int, float, complex and str
(but not long nor unicode) values, as well as their NumPy scalar
versions and homogeneous or <em>structured</em> NumPy arrays of them.  When
read, these values are always loaded as NumPy scalar or array
objects, as needed.</p>
<p>For that reason, attributes in native HDF5 files will be always
mapped into NumPy objects.  Specifically, a multidimensional
attribute will be mapped into a multidimensional ndarray and a
scalar will be mapped into a NumPy scalar object (for example, a
scalar H5T_NATIVE_LLONG will be read and returned as a numpy.int64
scalar).</p>
<p>However, other kinds of values are serialized using cPickle, so you
only will be able to correctly retrieve them using a Python-aware
HDF5 library.  Thus, if you want to save Python scalar values and
make sure you are able to read them with generic HDF5 tools, you
should make use of <em>scalar or homogeneous/structured array NumPy
objects</em> (for example, numpy.int64(1) or numpy.array([1, 2, 3],
dtype=&#8217;int16&#8217;)).</p>
<p>One more advice: because of the various potential difficulties in
restoring a Python object stored in an attribute, you may end up
getting a cPickle string where a Python object is expected. If this
is the case, you may wish to run cPickle.loads() on that string to
get an idea of where things went wrong, as shown in this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tables</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>  <span class="n">foo</span> <span class="o">=</span> <span class="s">&#39;bar&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myObject</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>  <span class="c"># save object of custom class in HDF5 attr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5fname</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s">&#39;.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">h5fname</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">myObject</span>  <span class="c"># store the object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>  <span class="c"># retrieve it</span>
<span class="go">bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">MyClass</span><span class="p">,</span> <span class="n">myObject</span>  <span class="c"># delete class of object and reopen file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h5f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span><span class="p">(</span><span class="n">h5fname</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="go">&#39;ccopy_reg\n_reconstructor...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cPickle</span>  <span class="c"># let&#39;s unpickle that to see what went wrong</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cPickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">h5f</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;module&#39; object has no attribute &#39;MyClass&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># So the problem was not in the stored object,</span>
<span class="gp">... </span><span class="c"># but in the *environment* where it was restored.</span>
<span class="gp">... </span><span class="n">h5f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">h5fname</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes on AttributeSet methods</p>
<p>Note that this class overrides the __getattr__(), __setattr__() and
__delattr__() special methods.  This allows you to read, assign or
delete attributes on disk by just using the next constructs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr</span> <span class="o">=</span> <span class="s">&#39;str attr&#39;</span>    <span class="c"># set a string (native support)</span>
<span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr2</span> <span class="o">=</span> <span class="mi">3</span>            <span class="c"># set an integer (native support)</span>
<span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>  <span class="c"># a generic object (Pickled)</span>
<span class="n">attrib</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr</span>        <span class="c"># get the attribute ``myattr``</span>
<span class="k">del</span> <span class="n">leaf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">myattr</span>             <span class="c"># delete the attribute ``myattr``</span>
</pre></div>
</div>
<p>In addition, the dictionary-like __getitem__(), __setitem__() and
__delitem__() methods are available, so you may write things like
this:</p>
<div class="highlight-python"><pre>for name in :attr:`Node._v_attrs`._f_list():
    print "name: %s, value: %s" % (name, :attr:`Node._v_attrs`[name])</pre>
</div>
<p>Use whatever idiom you prefer to access the attributes.</p>
<p>If an attribute is set on a target node that already has a large
number of attributes, a PerformanceWarning will be issued.</p>
<dl class="method">
<dt id="tables.attributeset.AttributeSet._f_copy">
<tt class="descname">_f_copy</tt><big>(</big><em>where</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet._f_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet._f_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy attributes to the where node.</p>
<p>Copies all user and certain system attributes to the given where
node (a Node instance - see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>), replacing
the existing ones.</p>
</dd></dl>

<dl class="method">
<dt id="tables.attributeset.AttributeSet._f_list">
<tt class="descname">_f_list</tt><big>(</big><em>attrset='user'</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet._f_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet._f_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of attribute names.</p>
<p>The attrset string selects the attribute set to be used.  A
&#8216;user&#8217; value returns only user attributes (this is the default).
A &#8216;sys&#8217; value returns only system attributes.  Finally, &#8216;all&#8217;
returns both system and user attributes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.attributeset.AttributeSet._f_rename">
<tt class="descname">_f_rename</tt><big>(</big><em>oldattrname</em>, <em>newattrname</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet._f_rename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet._f_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename an attribute from oldattrname to newattrname.</p>
</dd></dl>

<dl class="method">
<dt id="tables.attributeset.AttributeSet._g__delattr">
<tt class="descname">_g__delattr</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet._g__delattr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet._g__delattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute.</p>
<p>Deletes the specified existing PyTables attribute.</p>
<p>It does not log the change.</p>
</dd></dl>

<dl class="method">
<dt id="tables.attributeset.AttributeSet._g__setattr">
<tt class="descname">_g__setattr</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet._g__setattr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet._g__setattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute.</p>
<p>Sets a (maybe new) PyTables attribute with the specified <cite>name</cite>
and <cite>value</cite>.  If the attribute already exists, it is simply
replaced.</p>
<p>It does not log the change.</p>
</dd></dl>

<dl class="method">
<dt id="tables.attributeset.AttributeSet._g_copy">
<tt class="descname">_g_copy</tt><big>(</big><em>newSet</em>, <em>setAttr=None</em>, <em>copyClass=False</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet._g_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet._g_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy set attributes.</p>
<p>Copies all user and allowed system PyTables attributes to the
given attribute set, replacing the existing ones.</p>
<p>You can specify a <em>bound</em> method of the destination set that
will be used to set its attributes.  Else, its <cite>_g__setattr</cite>
method will be used.</p>
<p>Changes are logged depending on the chosen setting method.  The
default setting method does not log anything.</p>
</dd></dl>

<dl class="method">
<dt id="tables.attributeset.AttributeSet._g_updateNodeLocation">
<tt class="descname">_g_updateNodeLocation</tt><big>(</big><em>node</em><big>)</big><a class="reference internal" href="../_modules/tables/attributeset.html#AttributeSet._g_updateNodeLocation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.attributeset.AttributeSet._g_updateNodeLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the location information about the associated <cite>node</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.attributeset.AttributeSet._v_node">
<tt class="descname">_v_node</tt><a class="headerlink" href="#tables.attributeset.AttributeSet._v_node" title="Permalink to this definition">¶</a></dt>
<dd><p>The Node instance (see <a class="reference internal" href="#nodeclassdescr"><em>The Node class</em></a>) this
attribute set is associated with.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="declarative-classes">
<h2>Declarative classes<a class="headerlink" href="#declarative-classes" title="Permalink to this headline">¶</a></h2>
<p>In this section a series of classes that are meant to
<em>declare</em> datatypes that are required for creating
primary PyTables datasets are described.</p>
<div class="section" id="the-atom-class-and-its-descendants">
<span id="atomclassdescr"></span><h3>The Atom class and its descendants<a class="headerlink" href="#the-atom-class-and-its-descendants" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="tables.Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Atom</tt><big>(</big><em>nptype</em>, <em>shape</em>, <em>dflt</em><big>)</big><a class="headerlink" href="#tables.Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the type of atomic cells stored in a dataset.</p>
<p>The meaning of <em>atomic</em> is that individual elements of a cell can
not be extracted directly by indexing (i.e.  __getitem__()) the
dataset; e.g. if a dataset has shape (2, 2) and its atoms have
shape (3,), to get the third element of the cell at (1, 0) one
should use dataset[1,0][2] instead of dataset[1,0,2].</p>
<p>The Atom class is meant to declare the different properties of the
<em>base element</em> (also known as <em>atom</em>) of CArray, EArray and
VLArray datasets, although they are also used to describe the base
elements of Array datasets. Atoms have the property that their
length is always the same.  However, you can grow datasets along
the extensible dimension in the case of EArray or put a variable
number of them on a VLArray row. Moreover, they are not restricted
to scalar values, and they can be <em>fully multidimensional
objects</em>.</p>
<p>A series of descendant classes are offered in order to make the
use of these element descriptions easier. You should use a
particular Atom descendant class whenever you know the exact type
you will need when writing your code. Otherwise, you may use one
of the Atom.from_*() factory Methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>itemsize</strong> : int</p>
<blockquote>
<div><p>For types with a non-fixed size, this sets the size in
bytes of individual items in the atom.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>Sets the shape of the atom. An integer shape of
N is equivalent to the tuple (N,).</p>
</div></blockquote>
<p><strong>dflt</strong> :</p>
<blockquote>
<div><p>Sets the default value for the atom.</p>
</div></blockquote>
<p class="last"><strong>The following are the public methods and attributes of the Atom class.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tables.Atom.copy">
<tt class="descname">copy</tt><big>(</big><em>**override</em><big>)</big><a class="headerlink" href="#tables.Atom.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the atom, possibly overriding some arguments.</p>
<p>Constructor arguments to be overridden must be passed as
keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">=</span> <span class="n">StringAtom</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom1</span>
<span class="go">StringAtom(itemsize=12, shape=(), dflt=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom2</span>
<span class="go">StringAtom(itemsize=12, shape=(), dflt=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="ow">is</span> <span class="n">atom2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom3</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">itemsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom3</span>
<span class="go">StringAtom(itemsize=100, shape=(2, 2), dflt=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">foobar</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">__init__() got an unexpected keyword argument &#39;foobar&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Atom.from_dtype">
<em class="property">classmethod </em><tt class="descname">from_dtype</tt><big>(</big><em>class_</em>, <em>dtype</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a NumPy dtype.</p>
<p>An optional default value may be specified as the dflt
argument. Information in the dtype not represented in an Atom is
ignored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;S5&#39;</span><span class="p">),</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">StringAtom(itemsize=5, shape=(), dflt=&#39;hello&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;Float64&#39;</span><span class="p">))</span>
<span class="go">Float64Atom(shape=(), dflt=0.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Atom.from_kind">
<em class="property">classmethod </em><tt class="descname">from_kind</tt><big>(</big><em>class_</em>, <em>kind</em>, <em>itemsize=None</em>, <em>shape=()</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a PyTables kind.</p>
<p>Optional item size, shape and default value may be
specified as the itemsize, shape and dflt
arguments, respectively. Bear in mind that not all atoms support
a default item size:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int32Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Int32Atom(shape=(1,), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">StringAtom(itemsize=5, shape=(), dflt=&#39;hello&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">no default item size for kind ``string``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;Float&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown kind</span>: <span class="n">&#39;Float&#39;</span>
</pre></div>
</div>
<p>Moreover, some kinds with atypical constructor signatures
are not supported; you need to use the proper
constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_kind</span><span class="p">(</span><span class="s">&#39;enum&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the ``enum`` kind is not supported...</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Atom.from_sctype">
<em class="property">classmethod </em><tt class="descname">from_sctype</tt><big>(</big><em>class_</em>, <em>sctype</em>, <em>shape=()</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_sctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a NumPy scalar type sctype.</p>
<p>Optional shape and default value may be specified as the
shape and dflt
arguments, respectively. Information in the
sctype not represented in an Atom is ignored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_sctype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_sctype</span><span class="p">(</span><span class="s">&#39;S5&#39;</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown NumPy scalar type</span>: <span class="n">&#39;S5&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_sctype</span><span class="p">(</span><span class="s">&#39;Float64&#39;</span><span class="p">)</span>
<span class="go">Float64Atom(shape=(), dflt=0.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Atom.from_type">
<em class="property">classmethod </em><tt class="descname">from_type</tt><big>(</big><em>class_</em>, <em>type</em>, <em>shape=()</em>, <em>dflt=None</em><big>)</big><a class="headerlink" href="#tables.Atom.from_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Atom from a PyTables type.</p>
<p>Optional shape and default value may be specified as the
shape and dflt arguments, respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
<span class="go">BoolAtom(shape=(), dflt=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;int16&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Int16Atom(shape=(2, 2), dflt=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;string40&#39;</span><span class="p">,</span> <span class="n">dflt</span><span class="o">=</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown type</span>: <span class="n">&#39;string40&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Atom</span><span class="o">.</span><span class="n">from_type</span><span class="p">(</span><span class="s">&#39;Float64&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: unknown type</span>: <span class="n">&#39;Float64&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tables.Atom.prefix">
<em class="property">classmethod </em><tt class="descname">prefix</tt><big>(</big><em>class_</em><big>)</big><a class="headerlink" href="#tables.Atom.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atom class prefix.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.dflt">
<tt class="descname">dflt</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Atom.dflt" title="Permalink to this definition">¶</a></dt>
<dd><p>The default value of the atom.</p>
<p>If the user does not supply a value for an element while
filling a dataset, this default value will be written to
disk. If the user supplies a scalar value for a
multidimensional atom, this value is automatically <em>broadcast</em>
to all the items in the atom cell. If dflt is not supplied, an
appropriate zero value (or <em>null</em> string) will be chosen by
default.  Please note that default values are kept internally
as NumPy objects.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.dtype">
<tt class="descname">dtype</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Atom.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The NumPy dtype that most closely matches this atom.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.ndim">
<tt class="descname">ndim</tt><a class="headerlink" href="#tables.Atom.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dimensions of the atom.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.4.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.recarrtype">
<tt class="descname">recarrtype</tt><a class="headerlink" href="#tables.Atom.recarrtype" title="Permalink to this definition">¶</a></dt>
<dd><p>String type to be used in numpy.rec.array().</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.shape">
<tt class="descname">shape</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Atom.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the atom (a tuple for scalar atoms).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Atom.size">
<tt class="descname">size</tt><a class="headerlink" href="#tables.Atom.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total size in bytes of the atom.</p>
</dd></dl>

</dd></dl>

<div class="section" id="atom-constructors">
<span id="atomconstructors"></span><h4>Atom Constructors<a class="headerlink" href="#atom-constructors" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="tables.StringAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">StringAtom</tt><big>(</big><em>itemsize</em>, <em>shape=()</em>, <em>dflt=''</em><big>)</big><a class="headerlink" href="#tables.StringAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type string.</p>
<p>The item size is the <em>maximum</em> length in characters of strings.</p>
<dl class="attribute">
<dt id="tables.StringAtom.itemsize">
<tt class="descname">itemsize</tt><a class="headerlink" href="#tables.StringAtom.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size in bytes of a sigle item in the atom.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tables.BoolAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">BoolAtom</tt><big>(</big><em>shape=()</em>, <em>dflt=False</em><big>)</big><a class="headerlink" href="#tables.BoolAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type bool.</p>
</dd></dl>

<dl class="class">
<dt id="tables.IntAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">IntAtom</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.IntAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of a signed integral type (int kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int8Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int8Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int8Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">int8</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int16Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int16Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int16Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">int16</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">int32</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Int64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Int64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Int64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">int64</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UIntAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UIntAtom</tt><big>(</big><em>itemsize=4</em>, <em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UIntAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of an unsigned integral type (uint kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt8Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt8Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt8Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">uint8</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt16Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt16Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt16Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">uint16</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">uint32</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.UInt64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">UInt64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.UInt64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">uint64</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.FloatAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">FloatAtom</tt><big>(</big><em>itemsize=8</em>, <em>shape=()</em>, <em>dflt=0.0</em><big>)</big><a class="headerlink" href="#tables.FloatAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of a floating point type (float kind).</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em><big>)</big><a class="headerlink" href="#tables.Float32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">float32</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Float64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Float64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em><big>)</big><a class="headerlink" href="#tables.Float64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">float64</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="tables.ComplexAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">ComplexAtom</tt><big>(</big><em>itemsize</em>, <em>shape=()</em>, <em>dflt=0j</em><big>)</big><a class="headerlink" href="#tables.ComplexAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of kind complex.</p>
<p>Allowed item sizes are 8 (single precision) and 16 (double precision). This
class must be used instead of more concrete ones to avoid confusions with
numarray-like precision specifications used in PyTables 1.X.</p>
<dl class="attribute">
<dt id="tables.ComplexAtom.itemsize">
<tt class="descname">itemsize</tt><a class="headerlink" href="#tables.ComplexAtom.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size in bytes of a sigle item in the atom.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tables.Time32Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time32Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0</em><big>)</big><a class="headerlink" href="#tables.Time32Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type time32.</p>
</dd></dl>

<dl class="class">
<dt id="tables.Time64Atom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Time64Atom</tt><big>(</big><em>shape=()</em>, <em>dflt=0.0</em><big>)</big><a class="headerlink" href="#tables.Time64Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type time64.</p>
</dd></dl>

<dl class="class">
<dt id="tables.EnumAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">EnumAtom</tt><big>(</big><em>enum</em>, <em>dflt</em>, <em>base</em>, <em>shape=()</em><big>)</big><a class="headerlink" href="#tables.EnumAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of an atom of an enumerated type.</p>
<p>Instances of this class describe the atom type used to store enumerated
values. Those values belong to an enumerated type, defined by the first
argument (enum) in the constructor of the atom, which accepts the same
kinds of arguments as the Enum class (see <a class="reference internal" href="#enumclassdescr"><em>The Enum class</em></a>).  The
enumerated type is stored in the enum attribute of the atom.</p>
<p>A default value must be specified as the second argument (dflt) in the
constructor; it must be the <em>name</em> (a string) of one of the enumerated
values in the enumerated type. When the atom is created, the corresponding
concrete value is broadcast and stored in the dflt attribute (setting
different default values for items in a multidimensional atom is not
supported yet). If the name does not match any value in the enumerated
type, a KeyError is raised.</p>
<p>Another atom must be specified as the base argument in order to determine
the base type used for storing the values of enumerated values in memory
and disk. This <em>storage atom</em> is kept in the base attribute of the created
atom. As a shorthand, you may specify a PyTables type instead of the
storage atom, implying that this has a scalar shape.</p>
<p>The storage atom should be able to represent each and every concrete value
in the enumeration. If it is not, a TypeError is raised. The default value
of the storage atom is ignored.</p>
<p>The type attribute of enumerated atoms is always enum.</p>
<p>Enumerated atoms also support comparisons with other objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;int8&#39;</span><span class="p">)</span>  <span class="c"># same as ``atom2``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="n">Int8Atom</span><span class="p">())</span>  <span class="c"># same as ``atom1``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom3</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;int16&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom4</span> <span class="o">=</span> <span class="n">Int8Atom</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">enum</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom2</span> <span class="o">!=</span> <span class="n">atom1</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom1</span> <span class="o">==</span> <span class="n">atom4</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom4</span> <span class="o">!=</span> <span class="n">atom1</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<p>The next C enum construction:</p>
<div class="highlight-python"><pre>enum myEnum {
            T0,
            T1,
            T2
            };</pre>
</div>
<p>would correspond to the following PyTables
declaration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myEnumAtom</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">([</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">],</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;int32&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please note the dflt argument with a value of &#8216;T0&#8217;. Since the concrete
value matching T0 is unknown right now (we have not used explicit concrete
values), using the name is the only option left for defining a default
value for the atom.</p>
<p>The chosen representation of values for this enumerated atom uses unsigned
32-bit integers, which surely wastes quite a lot of memory. Another size
could be selected by using the base argument (this time with a full-blown
storage atom):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myEnumAtom</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">([</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">],</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="n">UInt8Atom</span><span class="p">())</span>
</pre></div>
</div>
<p>You can also define multidimensional arrays for data elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myEnumAtom</span> <span class="o">=</span> <span class="n">EnumAtom</span><span class="p">(</span>
<span class="gp">... </span>   <span class="p">[</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">],</span> <span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="s">&#39;uint32&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>for 3x2 arrays of uint32.</p>
<dl class="attribute">
<dt id="tables.EnumAtom.itemsize">
<tt class="descname">itemsize</tt><a class="headerlink" href="#tables.EnumAtom.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size in bytes of a sigle item in the atom.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pseudo-atoms">
<h4>Pseudo atoms<a class="headerlink" href="#pseudo-atoms" title="Permalink to this headline">¶</a></h4>
<p>Now, there come three special classes, ObjectAtom, VLStringAtom and
VLUnicodeAtom, that actually do not descend from Atom, but which goal is so
similar that they should be described here. Pseudo-atoms can only be used with
VLArray datasets (see <a class="reference internal" href="#vlarrayclassdescr"><em>The VLArray class</em></a>), and they do not support
multidimensional values, nor multiple values per row.</p>
<p>They can be recognised because they also have kind, type and shape attributes,
but no size, itemsize or dflt ones. Instead, they have a base atom which
defines the elements used for storage.</p>
<p>See <tt class="file docutils literal"><span class="pre">examples/vlarray1.py</span></tt> and <tt class="file docutils literal"><span class="pre">examples/vlarray2.py</span></tt> for further
examples on VLArray datasets, including object serialization and string
management.</p>
<div class="section" id="object-atom">
<h5>Object Atom<a class="headerlink" href="#object-atom" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="tables.ObjectAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">ObjectAtom</tt><a class="headerlink" href="#tables.ObjectAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type object.</p>
<p>This class is meant to fit <em>any</em> kind of Python object in a row of a
VLArray dataset by using cPickle behind the scenes. Due to the fact that
you can not foresee how long will be the output of the cPickle
serialization (i.e. the atom already has a <em>variable</em> length), you can only
fit <em>one object per row</em>. However, you can still group several objects in a
single tuple or list and pass it to the <a class="reference internal" href="#tables.VLArray.append" title="tables.VLArray.append"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.append()</span></tt></a> method.</p>
<p>Object atoms do not accept parameters and they cause the reads of rows to
always return Python objects. You can regard object atoms as an easy way to
save an arbitrary number of generic Python objects in a VLArray dataset.</p>
</dd></dl>

</div>
<div class="section" id="vlstringatom">
<span id="id2"></span><h5>VLStringAtom<a class="headerlink" href="#vlstringatom" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="tables.VLStringAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">VLStringAtom</tt><a class="headerlink" href="#tables.VLStringAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type <tt class="docutils literal"><span class="pre">vlstring</span></tt>.</p>
<p>This class describes a <em>row</em> of the VLArray class, rather than an atom. It
differs from the StringAtom class in that you can only add <em>one instance of
it to one specific row</em>, i.e. the <a class="reference internal" href="#tables.VLArray.append" title="tables.VLArray.append"><tt class="xref py py-meth docutils literal"><span class="pre">VLArray.append()</span></tt></a> method only
accepts one object when the base atom is of this type.</p>
<p>Like StringAtom, this class does not make assumptions on the encoding of
the string, and raw bytes are stored as is.  Unicode strings are supported
as long as no character is out of the ASCII set; otherwise, you will need
to <em>explicitly</em> convert them to strings before you can save them.  For full
Unicode support, using VLUnicodeAtom (see <a class="reference internal" href="#vlunicodeatom"><em>VLUnicodeAtom</em></a>) is
recommended.</p>
<p>Variable-length string atoms do not accept parameters and they cause the
reads of rows to always return Python strings.  You can regard vlstring
atoms as an easy way to save generic variable length strings.</p>
</dd></dl>

</div>
<div class="section" id="vlunicodeatom">
<span id="id3"></span><h5>VLUnicodeAtom<a class="headerlink" href="#vlunicodeatom" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="tables.VLUnicodeAtom">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">VLUnicodeAtom</tt><a class="headerlink" href="#tables.VLUnicodeAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an atom of type vlunicode.</p>
<p>This class describes a <em>row</em> of the VLArray class, rather than an atom.  It
is very similar to VLStringAtom (see <a class="reference internal" href="#vlstringatom"><em>VLStringAtom</em></a>), but it stores
Unicode strings (using 32-bit characters a la UCS-4, so all strings of the
same length also take up the same space).</p>
<p>This class does not make assumptions on the encoding of plain input
strings.  Plain strings are supported as long as no character is out of the
ASCII set; otherwise, you will need to <em>explicitly</em> convert them to Unicode
before you can save them.</p>
<p>Variable-length Unicode atoms do not accept parameters and they cause the
reads of rows to always return Python Unicode strings.  You can regard
vlunicode atoms as an easy way to save variable length Unicode strings.</p>
</dd></dl>

</div>
</div>
</div>
</div>
<div class="section" id="helper-classes">
<h2>Helper classes<a class="headerlink" href="#helper-classes" title="Permalink to this headline">¶</a></h2>
<p>This section describes some classes that do not fit in any other
section and that mainly serve for ancillary purposes.</p>
</div>
<div class="section" id="the-filters-class">
<span id="filtersclassdescr"></span><h2>The Filters class<a class="headerlink" href="#the-filters-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Filters">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Filters</tt><big>(</big><em>complevel=0</em>, <em>complib='zlib'</em>, <em>shuffle=True</em>, <em>fletcher32=False</em>, <em>_new=True</em><big>)</big><a class="headerlink" href="#tables.Filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for filter properties.</p>
<p>This class is meant to serve as a container that keeps information about
the filter properties associated with the chunked leaves, that is Table,
CArray, EArray and VLArray.</p>
<p>Instances of this class can be directly compared for equality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>complevel</strong> : int</p>
<blockquote>
<div><p>Specifies a compression level for data. The allowed
range is 0-9. A value of 0 (the default) disables
compression.</p>
</div></blockquote>
<p><strong>complib</strong> : str</p>
<blockquote>
<div><p>Specifies the compression library to be used. Right
now, &#8216;zlib&#8217; (the default), &#8216;lzo&#8217;, &#8216;bzip2&#8217;
and &#8216;blosc&#8217; are supported.  Specifying a
compression library which is not available in the system
issues a FiltersWarning and sets the library to the default one.</p>
</div></blockquote>
<p><strong>shuffle</strong> : bool</p>
<blockquote>
<div><p>Whether or not to use the <em>Shuffle</em>
filter in the HDF5 library. This is normally used to improve
the compression ratio. A false value disables shuffling and
a true one enables it. The default value depends on whether
compression is enabled or not; if compression is enabled,
shuffling defaults to be enabled, else shuffling is
disabled. Shuffling can only be used when compression is enabled.</p>
</div></blockquote>
<p><strong>fletcher32</strong> : bool</p>
<blockquote class="last">
<div><p>Whether or not to use the
<em>Fletcher32</em> filter in the HDF5 library.
This is used to add a checksum on each data chunk. A false
value (the default) disables the checksum.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This is a small example on using the Filters class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">tables</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">fileh</span> <span class="o">=</span> <span class="n">openFile</span><span class="p">(</span><span class="s">&#39;test5.h5&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="n">atom</span> <span class="o">=</span> <span class="n">Float32Atom</span><span class="p">()</span>
<span class="n">filters</span> <span class="o">=</span> <span class="n">Filters</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s">&#39;blosc&#39;</span><span class="p">,</span> <span class="n">fletcher32</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">fileh</span><span class="o">.</span><span class="n">createEArray</span><span class="p">(</span><span class="n">fileh</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;earray&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                         <span class="s">&quot;A growable array&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>

<span class="c"># Append several rows in only one call</span>
<span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

<span class="c"># Print information on that enlargeable array</span>
<span class="k">print</span> <span class="s">&quot;Result Array:&quot;</span>
<span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="n">fileh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This enforces the use of the Blosc library, a compression level of 1 and a
Fletcher32 checksum filter as well. See the output of this example:</p>
<div class="highlight-python"><pre>Result Array:
/earray (EArray(3, 2), fletcher32, shuffle, blosc(1)) 'A growable array'
type = float32
shape = (3, 2)
itemsize = 4
nrows = 3
extdim = 0
flavor = 'numpy'
byteorder = 'little'</pre>
</div>
<dl class="method">
<dt id="tables.Filters.copy">
<tt class="descname">copy</tt><big>(</big><em>**override</em><big>)</big><a class="headerlink" href="#tables.Filters.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the filters, possibly overriding some arguments.</p>
<p>Constructor arguments to be overridden must be passed as keyword
arguments.</p>
<p>Using this method is recommended over replacing the attributes of an
instance, since instances of this class may become immutable in the
future:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span> <span class="o">=</span> <span class="n">Filters</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters2</span> <span class="o">=</span> <span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span> <span class="o">==</span> <span class="n">filters2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span> <span class="ow">is</span> <span class="n">filters2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters3</span> <span class="o">=</span> <span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">compression library ``None`` is not supported...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters3</span> <span class="o">=</span> <span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s">&#39;zlib&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">filters1</span>
<span class="go">Filters(complevel=0, shuffle=False, fletcher32=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">filters3</span>
<span class="go">Filters(complevel=1, complib=&#39;zlib&#39;, shuffle=False, fletcher32=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filters1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">foobar</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">__init__() got an unexpected keyword argument &#39;foobar&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tables.Filters.complevel">
<tt class="descname">complevel</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Filters.complevel" title="Permalink to this definition">¶</a></dt>
<dd><p>The compression level (0 disables compression).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Filters.complib">
<tt class="descname">complib</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Filters.complib" title="Permalink to this definition">¶</a></dt>
<dd><p>The compression filter used (irrelevant when compression is
not enabled).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Filters.fletcher32">
<tt class="descname">fletcher32</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Filters.fletcher32" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the <em>Fletcher32</em> filter is active or not.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Filters.shuffle">
<tt class="descname">shuffle</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Filters.shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the <em>Shuffle</em> filter is active or not.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-index-class">
<span id="indexclassdescr"></span><h2>The Index class<a class="headerlink" href="#the-index-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.index.Index">
<em class="property">class </em><tt class="descclassname">tables.index.</tt><tt class="descname">Index</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>atom=None</em>, <em>title=''</em>, <em>kind=None</em>, <em>optlevel=None</em>, <em>filters=None</em>, <em>tmp_dir=None</em>, <em>expectedrows=0</em>, <em>byteorder=None</em>, <em>blocksizes=None</em>, <em>new=True</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the index of a column in a table.</p>
<p>This class is used to keep the indexing information for columns in a Table
dataset (see <a class="reference internal" href="#tableclassdescr"><em>The Table class</em></a>). It is actually a descendant of the
Group class (see <a class="reference internal" href="#groupclassdescr"><em>The Group class</em></a>), with some added functionality. An
Index is always associated with one and only one column in the table.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is mainly intended for internal use, but some of its
documented attributes and methods may be interesting for the
programmer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom object representing the shape and type of the atomic objects to
be saved. Only scalar atoms are supported.</p>
</div></blockquote>
<p><strong>title</strong> :</p>
<blockquote>
<div><p>Sets a TITLE attribute of the Index entity.</p>
</div></blockquote>
<p><strong>kind</strong> :</p>
<blockquote>
<div><p>The desired kind for this index.  The &#8216;full&#8217; kind specifies a complete
track of the row position (64-bit), while the &#8216;medium&#8217;, &#8216;light&#8217; or
&#8216;ultralight&#8217; kinds only specify in which chunk the row is (using
32-bit, 16-bit and 8-bit respectively).</p>
</div></blockquote>
<p><strong>optlevel</strong> :</p>
<blockquote>
<div><p>The desired optimization level for this index.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class that provides information about the
desired I/O filters to be applied during the life of this object.</p>
</div></blockquote>
<p><strong>tmp_dir</strong> :</p>
<blockquote>
<div><p>The directory for the temporary files.</p>
</div></blockquote>
<p><strong>expectedrows</strong> :</p>
<blockquote>
<div><p>Represents an user estimate about the number of row slices that will be
added to the growable dimension in the IndexArray object.</p>
</div></blockquote>
<p><strong>byteorder</strong> :</p>
<blockquote>
<div><p>The byteorder of the index datasets <em>on-disk</em>.</p>
</div></blockquote>
<p><strong>blocksizes</strong> :</p>
<blockquote class="last">
<div><p>The four main sizes of the compound blocks in index datasets (a low
level parameter).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tables.index.Index.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices values of index in the specified range.</p>
<p>If key argument is an integer, the corresponding index is returned.  If
key is a slice, the range of indices determined by it is returned.  A
negative value of step in slice is supported, meaning that the results
will be returned in reverse order.</p>
<p>This method is equivalent to <tt class="xref py py-meth docutils literal"><span class="pre">Index.readIndices()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>This provides more metainfo than standard __repr__</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>This provides a more compact representation than __repr__</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.append">
<tt class="descname">append</tt><big>(</big><em>xarr</em>, <em>update=False</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append the array to the index objects</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.appendLastRow">
<tt class="descname">appendLastRow</tt><big>(</big><em>xarr</em>, <em>update=False</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.appendLastRow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.appendLastRow" title="Permalink to this definition">¶</a></dt>
<dd><p>Append the array to the last row index objects</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.cleanup_temp">
<tt class="descname">cleanup_temp</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.cleanup_temp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.cleanup_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data and delete the temporaries for sorting purposes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.compute_overlaps">
<tt class="descname">compute_overlaps</tt><big>(</big><em>where</em>, <em>message</em>, <em>verbose</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.compute_overlaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.compute_overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute some statistics about overlaping of slices in index.</p>
<p>It returns the following info:</p>
<dl class="docutils">
<dt>noverlaps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The total number of slices that overlaps in index.</dd>
<dt>multiplicity <span class="classifier-delimiter">:</span> <span class="classifier">array of int</span></dt>
<dd>The number of times that a concrete slice overlaps with any other.</dd>
<dt>toverlap <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>An ovelap index: the sum of the values in segment slices that
overlaps divided by the entire range of values.  This index is only
computed for numerical types.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.compute_overlaps_finegrain">
<tt class="descname">compute_overlaps_finegrain</tt><big>(</big><em>where</em>, <em>message</em>, <em>verbose</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.compute_overlaps_finegrain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.compute_overlaps_finegrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute some statistics about overlaping of slices in index.</p>
<p>It returns the following info:</p>
<dl class="docutils">
<dt>noverlaps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The total number of elements that overlaps in index.</dd>
<dt>multiplicity <span class="classifier-delimiter">:</span> <span class="classifier">array of int</span></dt>
<dd>The number of times that a concrete slice overlaps with any other.</dd>
<dt>toverlap <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>An ovelap index: the sum of the values in segment slices that
overlaps divided by the entire range of values.  This index is only
computed for numerical types.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.create_temp">
<tt class="descname">create_temp</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.create_temp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.create_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create some temporary objects for slice sorting purposes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.create_temp2">
<tt class="descname">create_temp2</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.create_temp2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.create_temp2" title="Permalink to this definition">¶</a></dt>
<dd><p>Create some temporary objects for slice sorting purposes.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.do_complete_sort">
<tt class="descname">do_complete_sort</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.do_complete_sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.do_complete_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring an already optimized index into a complete sorted state.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.final_idx32">
<tt class="descname">final_idx32</tt><big>(</big><em>idx</em>, <em>offset</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.final_idx32"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.final_idx32" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform final operations in 32-bit indices.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.get_chunkmap">
<tt class="descname">get_chunkmap</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.get_chunkmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.get_chunkmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a map with the interesting chunks in index</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.get_neworder">
<tt class="descname">get_neworder</tt><big>(</big><em>neworder</em>, <em>src_disk</em>, <em>tmp_disk</em>, <em>lastrow</em>, <em>nslices</em>, <em>offset</em>, <em>dtype</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.get_neworder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.get_neworder" title="Permalink to this definition">¶</a></dt>
<dd><p>Get sorted &amp; indices values in new order.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.initial_append">
<tt class="descname">initial_append</tt><big>(</big><em>xarr</em>, <em>nrow</em>, <em>reduction</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.initial_append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.initial_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an initial indices arrays for data to be indexed.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.optimize">
<tt class="descname">optimize</tt><big>(</big><em>verbose=False</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize an index so as to allow faster searches.</p>
<dl class="docutils">
<dt>verbose</dt>
<dd>If True, messages about the progress of the
optimization process are printed out.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.readIndices">
<tt class="descname">readIndices</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.readIndices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.readIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices values of index in the specified range.</p>
<p>The meaning of the start, stop and step arguments is the same as in
<a class="reference internal" href="#tables.Table.readSorted" title="tables.Table.readSorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readSorted()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.readSorted">
<tt class="descname">readSorted</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.readSorted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.readSorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sorted values of index in the specified range.</p>
<p>The meaning of the start, stop and step arguments is the same as in
<a class="reference internal" href="#tables.Table.readSorted" title="tables.Table.readSorted"><tt class="xref py py-meth docutils literal"><span class="pre">Table.readSorted()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.read_slice">
<tt class="descname">read_slice</tt><big>(</big><em>where</em>, <em>nslice</em>, <em>buffer</em>, <em>start=0</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.read_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.read_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a slice from the <cite>where</cite> dataset and put it in <cite>buffer</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.read_sliceLR">
<tt class="descname">read_sliceLR</tt><big>(</big><em>where</em>, <em>buffer</em>, <em>start=0</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.read_sliceLR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.read_sliceLR" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a slice from the <cite>where</cite> dataset and put it in <cite>buffer</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.read_sorted_indices">
<tt class="descname">read_sorted_indices</tt><big>(</big><em>what</em>, <em>start</em>, <em>stop</em>, <em>step</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.read_sorted_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.read_sorted_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sorted or indices values in the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.reorder_slice">
<tt class="descname">reorder_slice</tt><big>(</big><em>nslice</em>, <em>sorted</em>, <em>indices</em>, <em>ssorted</em>, <em>sindices</em>, <em>tmp_sorted</em>, <em>tmp_indices</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.reorder_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.reorder_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy &amp; reorder the slice in source to final destination.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.reorder_slices">
<tt class="descname">reorder_slices</tt><big>(</big><em>tmp</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.reorder_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.reorder_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder completely the index at slice level.</p>
<p>This method has to maintain the locality of elements in the
ambit of <tt class="docutils literal"><span class="pre">blocks</span></tt>, i.e. an element of a <tt class="docutils literal"><span class="pre">block</span></tt> cannot be
sent to another <tt class="docutils literal"><span class="pre">block</span></tt> during this reordering.  This is
<em>critical</em> for <tt class="docutils literal"><span class="pre">light</span></tt> indexes to be able to use this.</p>
<p>This version of reorder_slices is optimized in that <em>two</em>
complete slices are taken at a time (including the last row
slice) so as to sort them.  Then, each new slice that is read is
put at the end of this two-slice buffer, while the previous one
is moved to the beginning of the buffer.  This is in order to
better reduce the entropy of the regular part (i.e. all except
the last row) of the index.</p>
<p>A secondary effect of this is that it takes at least <em>twice</em> of
memory than a previous version of reorder_slices() that only
reorders on a slice-by-slice basis.  However, as this is more
efficient than the old version, one can configure the slicesize
to be smaller, so the memory consumption is barely similar.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.restorecache">
<tt class="descname">restorecache</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.restorecache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.restorecache" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean the limits cache and resize starts and lengths arrays</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.search">
<tt class="descname">search</tt><big>(</big><em>item</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a binary search in this index for an item</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.search_item_lt">
<tt class="descname">search_item_lt</tt><big>(</big><em>where</em>, <em>item</em>, <em>nslice</em>, <em>limits</em>, <em>start=0</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.search_item_lt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.search_item_lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Search a single item in a specific sorted slice.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.search_scalar">
<tt class="descname">search_scalar</tt><big>(</big><em>item</em>, <em>sorted</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.search_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.search_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a binary search in this index for an item.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.swap">
<tt class="descname">swap</tt><big>(</big><em>what</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap chunks or slices using a certain bounds reference.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.swap_chunks">
<tt class="descname">swap_chunks</tt><big>(</big><em>mode='median'</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.swap_chunks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.swap_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap &amp; reorder the different chunks in a block.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.swap_slices">
<tt class="descname">swap_slices</tt><big>(</big><em>mode='median'</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.swap_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.swap_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap slices in a superblock.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.update_caches">
<tt class="descname">update_caches</tt><big>(</big><em>nslice</em>, <em>ssorted</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.update_caches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.update_caches" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the caches for faster lookups.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.write_slice">
<tt class="descname">write_slice</tt><big>(</big><em>where</em>, <em>nslice</em>, <em>buffer</em>, <em>start=0</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.write_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.write_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a <cite>slice</cite> to the <cite>where</cite> dataset with the <cite>buffer</cite> data.</p>
</dd></dl>

<dl class="method">
<dt id="tables.index.Index.write_sliceLR">
<tt class="descname">write_sliceLR</tt><big>(</big><em>where</em>, <em>buffer</em>, <em>start=0</em><big>)</big><a class="reference internal" href="../_modules/tables/index.html#Index.write_sliceLR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.write_sliceLR" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a slice from the <cite>where</cite> dataset with the <cite>buffer</cite> data.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.blocksize">
<tt class="descname">blocksize</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the block for this index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.blocksizes">
<tt class="descname">blocksizes</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.blocksizes" title="Permalink to this definition">¶</a></dt>
<dd><p>The four main sizes of the compound blocks (if specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.chunksize">
<tt class="descname">chunksize</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.chunksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the chunk for this index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.column">
<tt class="descname">column</tt><a class="headerlink" href="#tables.index.Index.column" title="Permalink to this definition">¶</a></dt>
<dd><p>The Column (see <a class="reference internal" href="#columnclassdescr"><em>The Column class</em></a>) instance for the indexed
column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.dirty">
<tt class="descname">dirty</tt><a class="headerlink" href="#tables.index.Index.dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the index is dirty or not.</p>
<p>Dirty indexes are out of sync with column data, so they exist but they
are not usable.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.dirtycache">
<tt class="descname">dirtycache</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.dirtycache" title="Permalink to this definition">¶</a></dt>
<dd><p>Dirty cache (for ranges, bounds &amp; sorted) flag.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.expectedrows">
<tt class="descname">expectedrows</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.expectedrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The expected number of items of index arrays.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.filters">
<tt class="descname">filters</tt><a class="headerlink" href="#tables.index.Index.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter properties for this index - see Filters in
<a class="reference internal" href="#filtersclassdescr"><em>The Filters class</em></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.indsize">
<tt class="descname">indsize</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.indsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The itemsize for the indices part of the index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.is_CSI">
<tt class="descname">is_CSI</tt><a class="headerlink" href="#tables.index.Index.is_CSI" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the index is completely sorted or not.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.kind">
<tt class="descname">kind</tt><a class="headerlink" href="#tables.index.Index.kind" title="Permalink to this definition">¶</a></dt>
<dd><p>The kind of this index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.lbucket">
<tt class="descname">lbucket</tt><a class="reference internal" href="../_modules/tables/index.html#Index.lbucket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.lbucket" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of a bucket based index type.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nblocks">
<tt class="descname">nblocks</tt><a class="headerlink" href="#tables.index.Index.nblocks" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of blocks in index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nblockssuperblock">
<tt class="descname">nblockssuperblock</tt><a class="headerlink" href="#tables.index.Index.nblockssuperblock" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of blocks in a superblock.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nchunks">
<tt class="descname">nchunks</tt><a class="headerlink" href="#tables.index.Index.nchunks" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of complete chunks in index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nchunkslice">
<tt class="descname">nchunkslice</tt><a class="headerlink" href="#tables.index.Index.nchunkslice" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of chunks in a slice.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nelements">
<tt class="descname">nelements</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.nelements" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of currently indexed rows for this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.noverlaps">
<tt class="descname">noverlaps</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.noverlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of overlaps in an index.  0 means a completely
sorted index. -1 means that this number is not computed yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nrows">
<tt class="descname">nrows</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of slices in the index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nrowsinchunk">
<tt class="descname">nrowsinchunk</tt><a class="reference internal" href="../_modules/tables/index.html#Index.nrowsinchunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.index.Index.nrowsinchunk" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of rows that fits in a <em>table</em> chunk.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nslices">
<tt class="descname">nslices</tt><a class="headerlink" href="#tables.index.Index.nslices" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of complete slices in index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nslicesblock">
<tt class="descname">nslicesblock</tt><a class="headerlink" href="#tables.index.Index.nslicesblock" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of slices in a block.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.nsuperblocks">
<tt class="descname">nsuperblocks</tt><a class="headerlink" href="#tables.index.Index.nsuperblocks" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of superblocks in index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.opt_search_types">
<tt class="descname">opt_search_types</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.opt_search_types" title="Permalink to this definition">¶</a></dt>
<dd><p>The types for which and optimized search has been implemented.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.optlevel">
<tt class="descname">optlevel</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.optlevel" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimization level for this index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#tables.index.Index.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of this index (in slices and elements).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.slicesize">
<tt class="descname">slicesize</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.slicesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the slice for this index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.superblocksize">
<tt class="descname">superblocksize</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.superblocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the superblock for this index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.table">
<tt class="descname">table</tt><a class="headerlink" href="#tables.index.Index.table" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for the <cite>Table</cite> object of this index.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.temp_required">
<tt class="descname">temp_required</tt><a class="headerlink" href="#tables.index.Index.temp_required" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether a temporary file for indexes is required or not.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.tmp_dir">
<tt class="descname">tmp_dir</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.tmp_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>The directory for the temporary files.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.tmpfilename">
<tt class="descname">tmpfilename</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.tmpfilename" title="Permalink to this definition">¶</a></dt>
<dd><p>Filename for temporary bounds.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.tprof">
<tt class="descname">tprof</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.tprof" title="Permalink to this definition">¶</a></dt>
<dd><p>Time counter for benchmarking purposes.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.type">
<tt class="descname">type</tt><em class="property"> = None</em><a class="headerlink" href="#tables.index.Index.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The datatypes to be stored by the sorted index array.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.index.Index.want_complete_sort">
<tt class="descname">want_complete_sort</tt><a class="headerlink" href="#tables.index.Index.want_complete_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether we should try to build a completely sorted index or not.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-indexarray-class">
<h2>The IndexArray class<a class="headerlink" href="#the-indexarray-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.indexes.IndexArray">
<em class="property">class </em><tt class="descclassname">tables.indexes.</tt><tt class="descname">IndexArray</tt><big>(</big><em>parentNode</em>, <em>name</em>, <em>atom=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>byteorder=None</em><big>)</big><a class="reference internal" href="../_modules/tables/indexes.html#IndexArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.indexes.IndexArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the index (sorted or reverse index) dataset in HDF5 file.</p>
<p>All NumPy typecodes are supported except for complex datatypes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>parentNode</strong> :</p>
<blockquote>
<div><p>The Index class from which this object will hang off.</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of this node in its parent group.</p>
</div></blockquote>
<p><strong>atom</strong> :</p>
<blockquote>
<div><p>An Atom object representing the shape and type of the atomic objects to
be saved. Only scalar atoms are supported.</p>
</div></blockquote>
<p><strong>title</strong> :</p>
<blockquote>
<div><p>Sets a TITLE attribute on the array entity.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class that provides information about the
desired I/O filters to be applied during the life of this object.</p>
</div></blockquote>
<p><strong>byteorder</strong> :</p>
<blockquote class="last">
<div><p>The byteroder of the data on-disk.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="tables.indexes.IndexArray.chunksize">
<tt class="descname">chunksize</tt><a class="headerlink" href="#tables.indexes.IndexArray.chunksize" title="Permalink to this definition">¶</a></dt>
<dd><p>The chunksize for this object.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.indexes.IndexArray.slicesize">
<tt class="descname">slicesize</tt><a class="headerlink" href="#tables.indexes.IndexArray.slicesize" title="Permalink to this definition">¶</a></dt>
<dd><p>The slicesize for this object.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-enum-class">
<span id="enumclassdescr"></span><h2>The Enum class<a class="headerlink" href="#the-enum-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.misc.enum.Enum">
<em class="property">class </em><tt class="descclassname">tables.misc.enum.</tt><tt class="descname">Enum</tt><big>(</big><em>enum</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerated type.</p>
<p>Each instance of this class represents an enumerated type. The
values of the type must be declared
<em>exhaustively</em> and named with
<em>strings</em>, and they might be given explicit
concrete values, though this is not compulsory. Once the type is
defined, it can not be modified.</p>
<p>There are three ways of defining an enumerated type. Each one
of them corresponds to the type of the only argument in the
constructor of Enum:</p>
<ul>
<li><p class="first"><em>Sequence of names</em>: each enumerated
value is named using a string, and its order is determined by
its position in the sequence; the concrete value is assigned
automatically:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">boolEnum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span><span class="s">&#39;True&#39;</span><span class="p">,</span> <span class="s">&#39;False&#39;</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>Mapping of names</em>: each enumerated
value is named by a string and given an explicit concrete value.
All of the concrete values must be different, or a
ValueError will be raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;red&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;green&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">colors</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;red&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;blue&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: enumerated values contain duplicate concrete values</span>: <span class="n">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>Enumerated type</em>: in that case, a copy
of the original enumerated type is created. Both enumerated
types are considered equal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prio2</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="n">priority</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span> <span class="o">==</span> <span class="n">prio2</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
</ul>
<p>Please note that names starting with _ are
not allowed, since they are reserved for internal usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prio2</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span><span class="s">&#39;_xx&#39;</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError: name of enumerated value can not start with ``_``</span>: <span class="n">&#39;_xx&#39;</span>
</pre></div>
</div>
<p>The concrete value of an enumerated value is obtained by
getting its name as an attribute of the Enum
instance (see __getattr__()) or as an item (see
__getitem__()). This allows comparisons between
enumerated values and assigning them to ordinary Python
variables:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">redv</span> <span class="o">=</span> <span class="n">priority</span><span class="o">.</span><span class="n">red</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">redv</span> <span class="o">==</span> <span class="n">priority</span><span class="p">[</span><span class="s">&#39;red&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">redv</span> <span class="o">&gt;</span> <span class="n">priority</span><span class="o">.</span><span class="n">green</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span><span class="o">.</span><span class="n">red</span> <span class="o">==</span> <span class="n">priority</span><span class="o">.</span><span class="n">orange</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The name of the enumerated value corresponding to a concrete
value can also be obtained by using the
__call__() method of the enumerated type. In this
way you get the symbolic name to use it later with
__getitem__():</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span><span class="p">(</span><span class="n">redv</span><span class="p">)</span>
<span class="go">&#39;red&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priority</span><span class="o">.</span><span class="n">red</span> <span class="o">==</span> <span class="n">priority</span><span class="p">[</span><span class="n">priority</span><span class="p">(</span><span class="n">priority</span><span class="o">.</span><span class="n">red</span><span class="p">)]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>(If you ask, the __getitem__() method is
not used for this purpose to avoid ambiguity in the case of using
strings as concrete values.)</p>
<dl class="method">
<dt id="tables.misc.enum.Enum.__call__">
<tt class="descname">__call__</tt><big>(</big><em>value</em>, <em>*default</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the enumerated value with that concrete value.</p>
<p>If there is no value with that concrete value in the enumeration and a
second argument is given as a default, this is returned. Else, a
ValueError is raised.</p>
<p>This method can be used for checking that a concrete value belongs to
the set of concrete values in an enumerated type.</p>
<p class="rubric">Examples</p>
<p>Let <tt class="docutils literal"><span class="pre">enum</span></tt> be an enumerated type defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;T2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ValueError: no enumerated value with that concrete value</span>: <span class="n">42</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__contains__">
<tt class="descname">__contains__</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__contains__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there an enumerated value with that name in the type?</p>
<p>If the enumerated type has an enumerated value with that name, True is
returned.  Otherwise, False is returned. The name must be a string.</p>
<p>This method does <em>not</em> check for concrete values matching a value in an
enumerated type. For that, please use the <tt class="xref py py-meth docutils literal"><span class="pre">Enum.__call__()</span></tt> method.</p>
<p class="rubric">Examples</p>
<p>Let <tt class="docutils literal"><span class="pre">enum</span></tt> be an enumerated type defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;T1&#39;</span> <span class="ow">in</span> <span class="n">enum</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;foo&#39;</span> <span class="ow">in</span> <span class="n">enum</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="ow">in</span> <span class="n">enum</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError: name of enumerated value is not a string</span>: <span class="n">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="o">.</span><span class="n">T1</span> <span class="ow">in</span> <span class="n">enum</span>  <span class="c"># Be careful with this!</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError: name of enumerated value is not a string</span>: <span class="n">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__delattr__">
<tt class="descname">__delattr__</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__delattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>This operation is forbidden.</p>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__delitem__">
<tt class="descname">__delitem__</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__delitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>This operation is forbidden.</p>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__eq__">
<tt class="descname">__eq__</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__eq__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the other enumerated type equivalent to this one?</p>
<p>Two enumerated types are equivalent if they have exactly the same
enumerated values (i.e. with the same names and concrete values).</p>
<p class="rubric">Examples</p>
<p>Let <tt class="docutils literal"><span class="pre">enum*</span></tt> be enumerated types defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum2</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="n">enum1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum3</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum4</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum5</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum6</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">==</span> <span class="n">enum1</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">==</span> <span class="n">enum2</span> <span class="o">==</span> <span class="n">enum3</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">==</span> <span class="n">enum4</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum5</span> <span class="o">==</span> <span class="n">enum1</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">==</span> <span class="n">enum6</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Comparing enumerated types with other kinds of objects produces
a false result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">==</span> <span class="p">{</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">==</span> <span class="p">[</span><span class="s">&#39;T0&#39;</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">]</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">==</span> <span class="mi">2</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__getattr__">
<tt class="descname">__getattr__</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__getattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the concrete value of the enumerated value with that name.</p>
<p>The name of the enumerated value must be a string. If there is no value
with that name in the enumeration, an AttributeError is raised.</p>
<p class="rubric">Examples</p>
<p>Let <tt class="docutils literal"><span class="pre">enum</span></tt> be an enumerated type defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="o">.</span><span class="n">T1</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="o">.</span><span class="n">foo</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AttributeError: no enumerated value with that name</span>: <span class="n">&#39;foo&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the concrete value of the enumerated value with that name.</p>
<p>The name of the enumerated value must be a string. If there is no value
with that name in the enumeration, a KeyError is raised.</p>
<p class="rubric">Examples</p>
<p>Let <tt class="docutils literal"><span class="pre">enum</span></tt> be an enumerated type defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="p">[</span><span class="s">&#39;T1&#39;</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError: &quot;no enumerated value with that name</span>: <span class="n">&#39;foo&#39;&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the enumerated values.</p>
<p>Enumerated values are returned as (name, value) pairs <em>in no particular
order</em>.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enumvals</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;red&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&#39;green&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;blue&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="n">enumvals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enumdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">enum</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enumvals</span> <span class="o">==</span> <span class="n">enumdict</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__len__">
<tt class="descname">__len__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of enumerated values in the enumerated type.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">Enum</span><span class="p">([</span><span class="s">&#39;e</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]))</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__ne__">
<tt class="descname">__ne__</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__ne__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the <cite>other</cite> enumerated type different from this one?</p>
<p>Two enumerated types are different if they don&#8217;t have exactly
the same enumerated values (i.e. with the same names and
concrete values).</p>
<p class="rubric">Examples</p>
<p>Let <tt class="docutils literal"><span class="pre">enum*</span></tt> be enumerated types defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum2</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="n">enum1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum3</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum4</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum5</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum6</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">({</span><span class="s">&#39;T0&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;T1&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">!=</span> <span class="n">enum1</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">!=</span> <span class="n">enum2</span> <span class="o">!=</span> <span class="n">enum3</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">!=</span> <span class="n">enum4</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum5</span> <span class="o">!=</span> <span class="n">enum1</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum1</span> <span class="o">!=</span> <span class="n">enum6</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the canonical string representation of the enumeration. The
output of this method can be evaluated to give a new enumeration object
that will compare equal to this one.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">Enum</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}))</span>
<span class="go">&quot;Enum({&#39;name&#39;: 10})&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__setattr__">
<tt class="descname">__setattr__</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>This operation is forbidden.</p>
</dd></dl>

<dl class="method">
<dt id="tables.misc.enum.Enum.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/tables/misc/enum.html#Enum.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tables.misc.enum.Enum.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>This operation is forbidden.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.misc.enum.Enum.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.misc.enum.Enum.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-expr-class-a-general-purpose-expression-evaluator">
<h2>The Expr class - a general-purpose expression evaluator<a class="headerlink" href="#the-expr-class-a-general-purpose-expression-evaluator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.Expr">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">Expr</tt><big>(</big><em>expr</em>, <em>uservars=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.Expr" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for evaluating expressions with arbitrary array-like objects.</p>
<p>Expr is a class for evaluating expressions containing array-like objects.
With it, you can evaluate expressions (like &#8220;3*a+4*b&#8221;) that operate on
arbitrary large arrays while optimizing the resources required to perform
them (basically main memory and CPU cache memory).  It is similar to the
Numexpr package (see <a class="reference internal" href="bibliography.html#numexpr"><em>[NUMEXPR]</em></a>), but in addition to NumPy
objects, it also accepts disk-based homogeneous arrays, like the Array,
CArray, EArray and Column PyTables objects.</p>
<p>All the internal computations are performed via the Numexpr package, so all
the broadcast and upcasting rules of Numexpr applies here too.  These rules
are very similar to the NumPy ones, but with some exceptions due to the
particularities of having to deal with potentially very large disk-based
arrays.  Be sure to read the documentation of the Expr constructor and
methods as well as that of Numexpr, if you want to fully grasp these
particularities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>expr</strong> : str</p>
<blockquote>
<div><p>This specifies the expression to be evaluated, such as &#8220;2*a+3*b&#8221;.</p>
</div></blockquote>
<p><strong>uservars</strong> : dict</p>
<blockquote>
<div><p>This can be used to define the variable names appearing in <em>expr</em>.
This mapping should consist of identifier-like strings pointing to any
<cite>Array</cite>, <cite>CArray</cite>, <cite>EArray</cite>, <cite>Column</cite> or NumPy ndarray instances (or
even others which will tried to be converted to ndarrays).  When
<cite>uservars</cite> is not provided or <cite>None</cite>, the current local and global
namespace is sought instead of <cite>uservars</cite>.  It is also possible to pass
just some of the variables in expression via the <cite>uservars</cite> mapping,
and the rest will be retrieved from the current local and global
namespaces.</p>
</div></blockquote>
<p><strong>kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>This is meant to pass additional parameters to the Numexpr kernel.
This is basically the same as the kwargs argument in
Numexpr.evaluate(), and is mainly meant for advanced use.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The following shows an example of using Expr.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Expr</span><span class="p">(</span><span class="s">&quot;2*a+b*c&quot;</span><span class="p">)</span>   <span class="c"># initialize the expression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>                 <span class="c"># evaluate it</span>
<span class="go">array([14, 24, 36])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>                   <span class="c"># use as an iterator</span>
<span class="go">74</span>
</pre></div>
</div>
<p>where you can see that you can mix different containers in
the expression (whenever shapes are consistent).</p>
<p>You can also work with multidimensional arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;a2&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;b2&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>           <span class="c"># This will be broadcasted</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Expr</span><span class="p">(</span><span class="s">&quot;2*a2+b2-c2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">array([ 8, 12])</span>
</pre></div>
</div>
<dl class="method">
<dt id="tables.Expr.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Expr.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rows of the outcome of the expression.</p>
<p>This iterator always returns rows as NumPy objects, so a possible out
container specified in <a class="reference internal" href="#tables.Expr.setOutput" title="tables.Expr.setOutput"><tt class="xref py py-meth docutils literal"><span class="pre">Expr.setOutput()</span></tt></a> method is ignored here.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.eval">
<tt class="descname">eval</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.Expr.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the expression and return the outcome.</p>
<p>Because of performance reasons, the computation order tries to go along
the common main dimension of all inputs.  If not such a common main
dimension is found, the iteration will go along the leading dimension
instead.</p>
<p>For non-consistent shapes in inputs (i.e. shapes having a different
number of dimensions), the regular NumPy broadcast rules applies.
There is one exception to this rule though: when the dimensions
orthogonal to the main dimension of the expression are consistent, but
the main dimension itself differs among the inputs, then the shortest
one is chosen for doing the computations.  This is so because trying to
expand very large on-disk arrays could be too expensive or simply not
possible.</p>
<p>Also, the regular Numexpr casting rules (which are similar to those of
NumPy, although you should check the Numexpr manual for the exceptions)
are applied to determine the output type.</p>
<p>Finally, if the setOuput() method specifying a user container has
already been called, the output is sent to this user-provided
container.  If not, a fresh NumPy container is returned instead.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When dealing with large on-disk inputs, failing to specify an
on-disk container may consume all your available memory.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.setInputsRange">
<tt class="descname">setInputsRange</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Expr.setInputsRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a range for all inputs in expression.</p>
<p>The computation will only take place for the range defined by the
start, stop and step parameters in the main dimension of inputs (or the
leading one, if the object lacks the concept of main dimension, like a
NumPy container).  If not a common main dimension exists for all
inputs, the leading dimension will be used instead.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.setOutput">
<tt class="descname">setOutput</tt><big>(</big><em>out</em>, <em>append_mode=False</em><big>)</big><a class="headerlink" href="#tables.Expr.setOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Set out as container for output as well as the append_mode.</p>
<p>The out must be a container that is meant to keep the outcome of the
expression.  It should be an homogeneous type container and can
typically be an Array, CArray, EArray, Column or a NumPy ndarray.</p>
<p>The append_mode specifies the way of which the output is filled.  If
true, the rows of the outcome are <em>appended</em> to the out container.  Of
course, for doing this it is necessary that out would have an append()
method (like an EArray, for example).</p>
<p>If append_mode is false, the output is set via the __setitem__() method
(see the Expr.setOutputRange() for info on how to select the rows to be
updated).  If out is smaller than what is required by the expression,
only the computations that are needed to fill up the container are
carried out.  If it is larger, the excess elements are unaffected.</p>
</dd></dl>

<dl class="method">
<dt id="tables.Expr.setOutputRange">
<tt class="descname">setOutputRange</tt><big>(</big><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#tables.Expr.setOutputRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a range for user-provided output object.</p>
<p>The output object will only be modified in the range specified by the
start, stop and step parameters in the main dimension of output (or the
leading one, if the object does not have the concept of main dimension,
like a NumPy container).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#tables.Expr.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.append_mode">
<tt class="descname">append_mode</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.append_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The append mode for user-provided output containers.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.maindim">
<tt class="descname">maindim</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.maindim" title="Permalink to this definition">¶</a></dt>
<dd><p>Common main dimension for inputs in expression.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.names">
<tt class="descname">names</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.names" title="Permalink to this definition">¶</a></dt>
<dd><p>The names of variables in expression (list).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.o_start">
<tt class="descname">o_start</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.o_start" title="Permalink to this definition">¶</a></dt>
<dd><p>The start range selection for the user-provided output.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.o_step">
<tt class="descname">o_step</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.o_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The step range selection for the user-provided output.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.o_stop">
<tt class="descname">o_stop</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.o_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>The stop range selection for the user-provided output.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.out">
<tt class="descname">out</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.out" title="Permalink to this definition">¶</a></dt>
<dd><p>The user-provided container (if any) for the expression outcome.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.shape">
<tt class="descname">shape</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Common shape for the arrays in expression.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.start">
<tt class="descname">start</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.start" title="Permalink to this definition">¶</a></dt>
<dd><p>The start range selection for the input.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.step">
<tt class="descname">step</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.step" title="Permalink to this definition">¶</a></dt>
<dd><p>The step range selection for the input.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.stop">
<tt class="descname">stop</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>The stop range selection for the input.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.Expr.values">
<tt class="descname">values</tt><em class="property"> = None</em><a class="headerlink" href="#tables.Expr.values" title="Permalink to this definition">¶</a></dt>
<dd><p>The values of variables in expression (list).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exceptions-module">
<span id="exceptionsdescr"></span><h2>Exceptions module<a class="headerlink" href="#exceptions-module" title="Permalink to this headline">¶</a></h2>
<p>In the <tt class="xref py py-mod docutils literal"><span class="pre">exceptions</span></tt> module exceptions and warnings that are specific
to PyTables are declared.</p>
<dl class="exception">
<dt id="tables.HDF5ExtError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">HDF5ExtError</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#tables.HDF5ExtError" title="Permalink to this definition">¶</a></dt>
<dd><p>A low level HDF5 operation failed.</p>
<p>This exception is raised the low level PyTables components used for
accessing HDF5 files.  It usually signals that something is not
going well in the HDF5 library or even at the Input/Output level.</p>
<p>Errors in the HDF5 C library may be accompanied by an extensive
HDF5 back trace on standard error (see also
<a class="reference internal" href="#tables.silenceHDF5Messages" title="tables.silenceHDF5Messages"><tt class="xref py py-func docutils literal"><span class="pre">tables.silenceHDF5Messages()</span></tt></a>).</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.4.</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>message</strong> :</p>
<blockquote>
<div><p>error message</p>
</div></blockquote>
<p><strong>h5bt</strong> :</p>
<blockquote class="last">
<div><p>This parameter (keyword only) controls the HDF5 back trace
handling. Any keyword arguments other than h5bt are ignored.</p>
<ul class="simple">
<li>if set to False the HDF5 back trace is ignored and the
<a class="reference internal" href="#tables.HDF5ExtError.h5backtrace" title="tables.HDF5ExtError.h5backtrace"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.h5backtrace</span></tt></a> attribute is set to None</li>
<li>if set to True the back trace is retrieved from the HDF5
library and stored in the <a class="reference internal" href="#tables.HDF5ExtError.h5backtrace" title="tables.HDF5ExtError.h5backtrace"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.h5backtrace</span></tt></a>
attribute as a list of tuples</li>
<li>if set to &#8220;VERBOSE&#8221; (default) the HDF5 back trace is
stored in the <a class="reference internal" href="#tables.HDF5ExtError.h5backtrace" title="tables.HDF5ExtError.h5backtrace"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.h5backtrace</span></tt></a> attribute
and also included in the string representation of the
exception</li>
<li>if not set (or set to None) the default policy is used
(see <a class="reference internal" href="#tables.HDF5ExtError.DEFAULT_H5_BACKTRACE_POLICY" title="tables.HDF5ExtError.DEFAULT_H5_BACKTRACE_POLICY"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.DEFAULT_H5_BACKTRACE_POLICY</span></tt></a>)</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tables.HDF5ExtError.format_h5_backtrace">
<tt class="descname">format_h5_backtrace</tt><big>(</big><em>backtrace=None</em><big>)</big><a class="headerlink" href="#tables.HDF5ExtError.format_h5_backtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the HDF5 trace back represented as a list of tuples
(see <a class="reference internal" href="#tables.HDF5ExtError.h5backtrace" title="tables.HDF5ExtError.h5backtrace"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.h5backtrace</span></tt></a>) into a string.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.4.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="tables.HDF5ExtError.DEFAULT_H5_BACKTRACE_POLICY">
<tt class="descname">DEFAULT_H5_BACKTRACE_POLICY</tt><em class="property"> = 'VERBOSE'</em><a class="headerlink" href="#tables.HDF5ExtError.DEFAULT_H5_BACKTRACE_POLICY" title="Permalink to this definition">¶</a></dt>
<dd><p>Default policy for HDF5 backtrace handling</p>
<ul class="simple">
<li>if set to False the HDF5 back trace is ignored and the
<a class="reference internal" href="#tables.HDF5ExtError.h5backtrace" title="tables.HDF5ExtError.h5backtrace"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.h5backtrace</span></tt></a> attribute is set to None</li>
<li>if set to True the back trace is retrieved from the HDF5
library and stored in the <a class="reference internal" href="#tables.HDF5ExtError.h5backtrace" title="tables.HDF5ExtError.h5backtrace"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.h5backtrace</span></tt></a>
attribute as a list of tuples</li>
<li>if set to &#8220;VERBOSE&#8221; (default) the HDF5 back trace is
stored in the <a class="reference internal" href="#tables.HDF5ExtError.h5backtrace" title="tables.HDF5ExtError.h5backtrace"><tt class="xref py py-attr docutils literal"><span class="pre">HDF5ExtError.h5backtrace</span></tt></a> attribute
and also included in the string representation of the
exception</li>
</ul>
<p>This parameter can be set using the
<span class="target" id="index-0"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PT_DEFAULT_H5_BACKTRACE_POLICY</span></tt> environment variable.
Allowed values are &#8220;IGNORE&#8221; (or &#8220;FALSE&#8221;), &#8220;SAVE&#8221; (or &#8220;TRUE&#8221;) and
&#8220;VERBOSE&#8221; to set the policy to False, True and &#8220;VERBOSE&#8221;
respectively.  The special value &#8220;DEFAULT&#8221; can be used to reset
the policy to the default value</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.4.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="tables.HDF5ExtError.h5backtrace">
<tt class="descname">h5backtrace</tt><em class="property"> = None</em><a class="headerlink" href="#tables.HDF5ExtError.h5backtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the HDF5 back trace as a (possibly empty) list of
tuples.  Each tuple has the following format:</p>
<div class="highlight-python"><pre>(filename, line number, function name, text)</pre>
</div>
<p>Depending on the value of the <em>h5bt</em> parameter passed to the
initializer the h5backtrace attribute can be set to None.
This means that the HDF5 back trace has been simply ignored
(not retrieved from the HDF5 C library error stack) or that
there has been an error (silently ignored) during the HDF5 back
trace retrieval.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.4.</span></p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">traceback.format_list()</span></tt></p>
</div>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="tables.ClosedNodeError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">ClosedNodeError</tt><a class="headerlink" href="#tables.ClosedNodeError" title="Permalink to this definition">¶</a></dt>
<dd><p>The operation can not be completed because the node is closed.</p>
<p>For instance, listing the children of a closed group is not allowed.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.ClosedFileError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">ClosedFileError</tt><a class="headerlink" href="#tables.ClosedFileError" title="Permalink to this definition">¶</a></dt>
<dd><p>The operation can not be completed because the hosting file is closed.</p>
<p>For instance, getting an existing node from a closed file is not
allowed.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.FileModeError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">FileModeError</tt><a class="headerlink" href="#tables.FileModeError" title="Permalink to this definition">¶</a></dt>
<dd><p>The operation can not be carried out because the mode in which the
hosting file is opened is not adequate.</p>
<p>For instance, removing an existing leaf from a read-only file is not
allowed.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.NodeError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">NodeError</tt><a class="headerlink" href="#tables.NodeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalid hierarchy manipulation operation requested.</p>
<p>This exception is raised when the user requests an operation on the
hierarchy which can not be run because of the current layout of the
tree.  This includes accessing nonexistent nodes, moving or copying
or creating over an existing node, non-recursively removing groups
with children, and other similarly invalid operations.</p>
<p>A node in a PyTables database cannot be simply overwritten by
replacing it.  Instead, the old node must be removed explicitely
before another one can take its place.  This is done to protect
interactive users from inadvertedly deleting whole trees of data by
a single erroneous command.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.NoSuchNodeError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">NoSuchNodeError</tt><a class="headerlink" href="#tables.NoSuchNodeError" title="Permalink to this definition">¶</a></dt>
<dd><p>An operation was requested on a node that does not exist.</p>
<p>This exception is raised when an operation gets a path name or a
<tt class="docutils literal"><span class="pre">(where,</span> <span class="pre">name)</span></tt> pair leading to a nonexistent node.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.UndoRedoError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">UndoRedoError</tt><a class="headerlink" href="#tables.UndoRedoError" title="Permalink to this definition">¶</a></dt>
<dd><p>Problems with doing/redoing actions with Undo/Redo feature.</p>
<p>This exception indicates a problem related to the Undo/Redo
mechanism, such as trying to undo or redo actions with this
mechanism disabled, or going to a nonexistent mark.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.UndoRedoWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">UndoRedoWarning</tt><a class="headerlink" href="#tables.UndoRedoWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Issued when an action not supporting Undo/Redo is run.</p>
<p>This warning is only shown when the Undo/Redo mechanism is enabled.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.NaturalNameWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">NaturalNameWarning</tt><a class="headerlink" href="#tables.NaturalNameWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Issued when a non-pythonic name is given for a node.</p>
<p>This is not an error and may even be very useful in certain
contexts, but one should be aware that such nodes cannot be
accessed using natural naming (instead, <tt class="docutils literal"><span class="pre">getattr()</span></tt> must be
used explicitly).</p>
</dd></dl>

<dl class="exception">
<dt id="tables.PerformanceWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">PerformanceWarning</tt><a class="headerlink" href="#tables.PerformanceWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning for operations which may cause a performance drop.</p>
<p>This warning is issued when an operation is made on the database
which may cause it to slow down on future operations (i.e. making
the node tree grow too much).</p>
</dd></dl>

<dl class="exception">
<dt id="tables.FlavorError">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">FlavorError</tt><a class="headerlink" href="#tables.FlavorError" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported or unavailable flavor or flavor conversion.</p>
<p>This exception is raised when an unsupported or unavailable flavor
is given to a dataset, or when a conversion of data between two
given flavors is not supported nor available.</p>
<p>A supported flavor may be unavailable if the package which
implements it is not installed locally, e.g. you may specify the
<tt class="docutils literal"><span class="pre">numeric</span></tt> flavor, which is supported by PyTables, but if Numeric
is not installed on your machine, you will get this error.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.FlavorWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">FlavorWarning</tt><a class="headerlink" href="#tables.FlavorWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported or unavailable flavor conversion.</p>
<p>This warning is issued when a conversion of data between two given
flavors is not supported nor available, and raising an error would
render the data inaccessible (e.g. on a dataset of an unavailable
flavor in a read-only file).</p>
<p>See the <cite>FlavorError</cite> class for more information.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.FiltersWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">FiltersWarning</tt><a class="headerlink" href="#tables.FiltersWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Unavailable filters.</p>
<p>This warning is issued when a valid filter is specified but it is
not available in the system.  It may mean that an available default
filter is to be used instead.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.OldIndexWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">OldIndexWarning</tt><a class="headerlink" href="#tables.OldIndexWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported index format.</p>
<p>This warning is issued when an index in an unsupported format is
found.  The index will be marked as invalid and will behave as if
doesn&#8217;t exist.</p>
</dd></dl>

<dl class="exception">
<dt id="tables.DataTypeWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">DataTypeWarning</tt><a class="headerlink" href="#tables.DataTypeWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported data type.</p>
<p>This warning is issued when an unsupported HDF5 data type is found
(normally in a file created with other tool than PyTables).</p>
</dd></dl>

<dl class="exception">
<dt id="tables.Incompat16Warning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">Incompat16Warning</tt><a class="headerlink" href="#tables.Incompat16Warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Format incompatible with HDF5 1.6.x format.</p>
<p>This warning is issued when using a functionality that is
incompatible with the HDF5 1.6.x format and that may create issues
for reading the files with PyTables compiled against HDF5 1.6.x.</p>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 2.4.</span></p>
</dd></dl>

<dl class="exception">
<dt id="tables.ExperimentalFeatureWarning">
<em class="property">exception </em><tt class="descclassname">tables.</tt><tt class="descname">ExperimentalFeatureWarning</tt><a class="headerlink" href="#tables.ExperimentalFeatureWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic warning for experimental features.</p>
<p>This warning is issued when using a functionality that is still
experimental and that users have to use with care.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="../index.html">
          <img class="logo" src="../_static/logo-pytables-small.png" alt="Logo"/>
        </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Library Reference</a><ul>
<li><a class="reference internal" href="#tables-variables-and-functions">tables variables and functions</a><ul>
<li><a class="reference internal" href="#global-variables">Global variables</a></li>
<li><a class="reference internal" href="#global-functions">Global functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-file-class">The File Class</a></li>
<li><a class="reference internal" href="#the-node-class">The Node class</a></li>
<li><a class="reference internal" href="#the-group-class">The Group class</a></li>
<li><a class="reference internal" href="#the-leaf-class">The Leaf class</a></li>
<li><a class="reference internal" href="#the-table-class">The Table class</a></li>
<li><a class="reference internal" href="#the-cols-class">The Cols class</a></li>
<li><a class="reference internal" href="#the-column-class">The Column class</a></li>
<li><a class="reference internal" href="#the-row-class">The Row class</a></li>
<li><a class="reference internal" href="#the-description-class">The Description class</a></li>
<li><a class="reference internal" href="#the-col-class-and-its-descendants">The Col class and its descendants</a></li>
<li><a class="reference internal" href="#the-isdescription-class">The IsDescription class</a></li>
<li><a class="reference internal" href="#the-array-class">The Array class</a></li>
<li><a class="reference internal" href="#the-carray-class">The CArray class</a></li>
<li><a class="reference internal" href="#the-earray-class">The EArray class</a></li>
<li><a class="reference internal" href="#the-vlarray-class">The VLArray class</a></li>
<li><a class="reference internal" href="#the-link-class">The Link class</a></li>
<li><a class="reference internal" href="#the-softlink-class">The SoftLink class</a></li>
<li><a class="reference internal" href="#the-externallink-class">The ExternalLink class</a></li>
<li><a class="reference internal" href="#the-unimplemented-class">The UnImplemented class</a></li>
<li><a class="reference internal" href="#the-unknown-class">The Unknown class</a></li>
<li><a class="reference internal" href="#the-attributeset-class">The AttributeSet class</a></li>
<li><a class="reference internal" href="#declarative-classes">Declarative classes</a><ul>
<li><a class="reference internal" href="#the-atom-class-and-its-descendants">The Atom class and its descendants</a><ul>
<li><a class="reference internal" href="#atom-constructors">Atom Constructors</a></li>
<li><a class="reference internal" href="#pseudo-atoms">Pseudo atoms</a><ul>
<li><a class="reference internal" href="#object-atom">Object Atom</a></li>
<li><a class="reference internal" href="#vlstringatom">VLStringAtom</a></li>
<li><a class="reference internal" href="#vlunicodeatom">VLUnicodeAtom</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#helper-classes">Helper classes</a></li>
<li><a class="reference internal" href="#the-filters-class">The Filters class</a></li>
<li><a class="reference internal" href="#the-index-class">The Index class</a></li>
<li><a class="reference internal" href="#the-indexarray-class">The IndexArray class</a></li>
<li><a class="reference internal" href="#the-enum-class">The Enum class</a></li>
<li><a class="reference internal" href="#the-expr-class-a-general-purpose-expression-evaluator">The Expr class - a general-purpose expression evaluator</a></li>
<li><a class="reference internal" href="#exceptions-module">Exceptions module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorials.html"
                        title="previous chapter">Tutorials</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="optimization.html"
                        title="next chapter">Optimization tips</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/usersguide/libref.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="optimization.html" title="Optimization tips"
             >next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             >previous</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">PyTables 2.4.0b1 documentation</a> &raquo;</li>

          <li><a href="index.html" >PyTables User&#8217;s Guide</a> &raquo;</li> 
      </ul>
    </div>
    </div>

    <div class="footer">
        &copy; Copyright 2011-2012, The PyTables Governance Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
    <!-- cloud_sptheme 1.3 -->
  </body>
</html>